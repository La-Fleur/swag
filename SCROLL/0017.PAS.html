<html>
<head><title> "Window Scrolling" by JOHN BALDWIN</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to SCROLL SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0017.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt; I'd like to do left &amp; right screen scrolling, like the INT 10 functions
&gt; for up &amp; down screen scrolling.
}

</i></font><font color="#FF0000"><b>procedure </b></font>scroll_left<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">; 
 
</font><font color="#FF0000"><b>asm 
   </b></font><font color="#FF00FF">mov al,[y1]     </font><font color="#008000"><i>{put y1 coordinate in al} 
   </i></font><font color="#FF00FF">xor ah,ah       </font><font color="#008000"><i>{set ah to 0 so we can deal with ax} 
   </i></font><font color="#FF00FF">mov bx,80       </font><font color="#008000"><i>{set bx=80} 
   </i></font><font color="#FF00FF">mul bl          </font><font color="#008000"><i>{multiply by bl, which equals 80 by the previous statement} 
   </i></font><font color="#FF00FF">mov bl,[x1]     </font><font color="#008000"><i>{put x1 coordinate in bl} 
   </i></font><font color="#FF00FF">add ax,bx       </font><font color="#008000"><i>{add the x1 coord. to y1*80 since there are 80 cols in a row
   shl ax,1        {multiply by 2 because info is stored as words, attribute 
                    in the high byte and the ASCII code for the character in 
                    the low byte} 
   </i></font><font color="#FF00FF">mov si,ax       </font><font color="#008000"><i>{all this calculated the offset in video memory of the
upper}                    {left-hand corner, which is put in si for later use} 
   </i></font><font color="#FF00FF">mov al,[x2]     </font><font color="#008000"><i>{put x2 coord. in al} 
   </i></font><font color="#FF00FF">xor ah,ah       </font><font color="#008000"><i>{set ah=0 so we can deal with ax} 
   </i></font><font color="#FF00FF">sub al,bl       </font><font color="#008000"><i>{subtract bl, which still contains x1, from al} 
   </i></font><font color="#FF00FF">mov dx,ax       </font><font color="#008000"><i>{put this in dx, this is the number of cols to copy at 
                    to move} 
   </i></font><font color="#FF00FF">mov bx,80       </font><font color="#008000"><i>{put 80 in bx} 
   </i></font><font color="#FF00FF">sub bx,ax       </font><font color="#008000"><i>{subtract this from ax, this value is the number of columns 
                    we will skip over to get to the next value} 
   </i></font><font color="#FF00FF">shl bx,1        </font><font color="#008000"><i>{multiply by 2 since the data is stored as words} 
   </i></font><font color="#FF00FF">mov di,si       </font><font color="#008000"><i>{set di=si, di points to the offset in memory to move the 
                    characters to, in this case to the left} 
   </i></font><font color="#FF00FF">inc si          </font><font color="#008000"><i>{add one to si} 
   </i></font><font color="#FF00FF">inc si          </font><font color="#008000"><i>{add one to si, this places si one character ahead of di} 
   </i></font><font color="#FF00FF">mov cl,[y2]     </font><font color="#008000"><i>{put y2 coord. in cl} 
   </i></font><font color="#FF00FF">mov ch,[y1]     </font><font color="#008000"><i>{put y1 coord. in ch} 
   </i></font><font color="#FF00FF">sub cl,ch       </font><font color="#008000"><i>{subtract ch from cl, this value is the number of lines to 
                    scroll} 
   </i></font><font color="#FF00FF">xor ch,ch       </font><font color="#008000"><i>{set ch=0 since we don't need that anymore, and because the 
                    the CPU will use all of cx to calculate the number of
lines}    </i></font><font color="#FF00FF">inc cx          </font><font color="#008000"><i>{add one to cx because the subtraction only counts
one of                     the y-coords., this accounts for the other} 
   </i></font><font color="#FF00FF">push ds         </font><font color="#008000"><i>{save the ds register, which points to the data segment} 
   </i></font><font color="#FF00FF">mov ax,0b800h   </font><font color="#008000"><i>{put $b800, the video segment for 80x25 text mode on color 
                    monitors in ax, if the mode you are using has its video 
                    segment different from $b800, put the other value here} 
   </i></font><font color="#FF00FF">mov es,ax       </font><font color="#008000"><i>{put ax into es because one cannot move a value into a 
                    segment register, nor can one move one segment register 
                    into another} 
   </i></font><font color="#FF00FF">mov ds,ax       </font><font color="#008000"><i>{put ax in ds} 
   </i></font><font color="#FF00FF">cld             </font><font color="#008000"><i>{clear direction flag so we will write forward in memory} 
</i></font><font color="#FF00FF">@copyloopl:        </font><font color="#008000"><i>{this loops scrolls one line from x1 to x2 left one space}
   </i></font><font color="#FF00FF">push cx         </font><font color="#008000"><i>{save cx (number of lines to do)}
   </i></font><font color="#FF00FF">mov cx,dx       </font><font color="#008000"><i>{put dx (number of cols to scroll) in cx}
   </i></font><font color="#FF00FF">rep movsw       </font><font color="#008000"><i>{movsw moves a word from ds:si to es:di, the first register
                    being the segment in memory and the second the offset, rep
                    repeats the following instruction, in this case movsw, the
                    number of times in cx}
   </i></font><font color="#FF00FF">mov [WORD PTR ds:si-2],0720h  </font><font color="#008000"><i>{this puts a word with the value $0720 at
                                  ds:si-2, this puts a space with attribute
                                  lightgray on black at the beginning of the
                                  line, to change the character output,
                                  replace the 20 part with the hex number
                                  for the character, to change the color,
                                  change the 07 to the hex number for the
                                  attribute you want}
   </i></font><font color="#FF00FF">pop cx          </font><font color="#008000"><i>{restores cx from where we saved it earlier}
   </i></font><font color="#FF00FF">add si,bx       </font><font color="#008000"><i>{adds bx to si to make get ready to do the next line}
   </i></font><font color="#FF00FF">add di,bx       </font><font color="#008000"><i>{do the same for di}
   </i></font><font color="#FF00FF">loop @copyloopl </font><font color="#008000"><i>{loop loops to the label after it cx number of times}
   </i></font><font color="#FF00FF">pop ds          </font><font color="#008000"><i>{restore ds from where we saved it earlier}
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;


</font><font color="#FF0000"><b>procedure </b></font>scroll_right<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">; 
 
</font><font color="#FF0000"><b>asm 
   </b></font><font color="#FF00FF">mov al,[y1]     </font><font color="#008000"><i>{put y1 into al} 
   </i></font><font color="#FF00FF">xor ah,ah       </font><font color="#008000"><i>{set ah to 0 so we can work with ax} 
   </i></font><font color="#FF00FF">mov bx,80       </font><font color="#008000"><i>{set bx=80} 
   </i></font><font color="#FF00FF">mul bl          </font><font color="#008000"><i>{mulitiply ax by bl} 
   </i></font><font color="#FF00FF">mov bl,[x2]     </font><font color="#008000"><i>{put x2 in bl} 
   </i></font><font color="#FF00FF">add ax,bx       </font><font color="#008000"><i>{add ax to bx} 
   </i></font><font color="#FF00FF">shl ax,1        </font><font color="#008000"><i>{multiply ax by 2 since data stored as words} 
   </i></font><font color="#FF00FF">mov si,ax       </font><font color="#008000"><i>{set si (source index) equal to ax} 
   </i></font><font color="#FF00FF">mov al,[x1]     </font><font color="#008000"><i>{put x1 into al} 
   </i></font><font color="#FF00FF">xor ah,ah       </font><font color="#008000"><i>{set ah=0} 
   </i></font><font color="#FF00FF">sub bl,al       </font><font color="#008000"><i>{subtract bl from al to get number of characters to scroll} 
   </i></font><font color="#FF00FF">xchg ax,bx      </font><font color="#008000"><i>{switch ax with bx} 
   </i></font><font color="#FF00FF">mov dx,ax       </font><font color="#008000"><i>{put ax (# of cols to scroll) in dx} 
   </i></font><font color="#FF00FF">mov bx,ax       </font><font color="#008000"><i>{put ax in bx} 
   </i></font><font color="#FF00FF">shl bx,1        </font><font color="#008000"><i>{multiply bx by 2 since dealing with words} 
   </i></font><font color="#FF00FF">add bx,0a0h     </font><font color="#008000"><i>{add $00A0 to bx, this is the number of bytes in one row 
                    of data, the reason being that in scroll_left we wrote 
                    forward in video memory, in scroll_right we have to write 
                    backward since otherwise we would destroy the data we were 
                    scrolling and fill the window with the first row of 
                    characters.  When we add this to si and di as in 
                    scroll_left, the # of cols part will take si and di back 
                    to where they started, and the $00a0 part will send them 
                    down one line} 
   </i></font><font color="#FF00FF">mov di,si       </font><font color="#008000"><i>{set di = si} 
   </i></font><font color="#FF00FF">dec si          </font><font color="#008000"><i>{decrement si because si needs to be behind di one 
                    character, since we are going backwards, si will be 
                    &quot;ahead&quot; of di which is how we keep from losing data} 
   </i></font><font color="#FF00FF">dec si          </font><font color="#008000"><i>{decrement si again since we are dealing with words} 
   </i></font><font color="#FF00FF">mov cl,[y2]     </font><font color="#008000"><i>{put y2 in cl} 
   </i></font><font color="#FF00FF">mov ch,[y1]     </font><font color="#008000"><i>{put y1 in ch} 
   </i></font><font color="#FF00FF">sub cl,ch       </font><font color="#008000"><i>{subtract ch (y1) from cl (y2) to get # or rows} 
   </i></font><font color="#FF00FF">xor ch,ch       </font><font color="#008000"><i>{clear ch since CPU uses all of cx} 
   </i></font><font color="#FF00FF">inc cx          </font><font color="#008000"><i>{increment cx to include both y-coords.} 
   </i></font><font color="#FF00FF">push ds         </font><font color="#008000"><i>{save ds so your program want lose its data segment, 
                    which would be REALLY bad} 
   </i></font><font color="#FF00FF">mov ax,0b800h   </font><font color="#008000"><i>{set ax = $B800, video memory segment} 
   </i></font><font color="#FF00FF">mov es,ax       </font><font color="#008000"><i>{set es = ax} 
   </i></font><font color="#FF00FF">mov ds,ax       </font><font color="#008000"><i>{set ds = ax} 
   </i></font><font color="#FF00FF">std             </font><font color="#008000"><i>{set direction flag since we want to go backwards in 
                    memory this time} 
</i></font><font color="#FF00FF">@copyloopr:        </font><font color="#008000"><i>{label for loop that scrolls one line right}
   </i></font><font color="#FF00FF">push cx         </font><font color="#008000"><i>{save cx}
   </i></font><font color="#FF00FF">mov cx,dx       </font><font color="#008000"><i>{put dx (#of cols) in cx so the rep instruction will
                    repeat the right number of times}
   </i></font><font color="#FF00FF">rep movsw       </font><font color="#008000"><i>{scroll one line right}
   </i></font><font color="#FF00FF">mov [WORD PTR ds:si+2],0720h </font><font color="#008000"><i>{Put a space in the character at col x1,
                                 ds:si points to col x1+1 at the end of the
                                 movsw stuff, so ds:si+2 = col x1}
   </i></font><font color="#FF00FF">pop cx          </font><font color="#008000"><i>{restore cx from where it was saved earlier}
   </i></font><font color="#FF00FF">add si,bx       </font><font color="#008000"><i>{add bx to si to send si to the next line}
   </i></font><font color="#FF00FF">add di,bx       </font><font color="#008000"><i>{ditto for di}
   </i></font><font color="#FF00FF">loop @copyloopr </font><font color="#008000"><i>{loop back to @copyloopr to do the next line until done}
   </i></font><font color="#FF00FF">pop ds          </font><font color="#008000"><i>{restore ds so your program will know where all its data
                    is}
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{
These procedures scroll the text in the window with the upper righthand
corner being (x1,y1) and the lower lefthand corner being (x1,y2).  The text
will not scroll outside of the window and the empty columns will be filled
with spaces with an attribute of lightgray on black.  To change what
character and color to put in the new columns, determine the hex number
for the character and color you want, then put the color byte in front of
the character byte and replace the 0720h with it.  For example, to select
character $20 with a color of $04, change the 0720h to 0420h like so:

   mov [WORD PTR ds:si+2],0420h  (in scroll_right)
      or
   mov [WORD PTR ds:si-2],0420h  (in scroll_left)

these procs simply copy chunks of video memory.  One thing that might help
understand the value for bx and other stuff: the movsw copys the word from
ds:si to es:di, then if the direction flag is clear, it adds 2 to si and to
di, if the direction flag is set, it subtracts 2 from si and di.
}</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to SCROLL SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0017.PAS">Original</a><b>]</b></p></body>
</html>
