<html>
<head><title> "Chained or Linked lists, the sort" by GLENN GROTZINGER</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to TUTOR SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0021.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#000000">                       Turbo <font color="#FF0000"><b>Pascal for </b></font>DOS Tutorial
                            by Glenn Grotzinger
          Part <font color="#800000">18</font><font color="#000080">: </font>Chained <font color="#FF0000"><b>or </b></font>Linked lists<font color="#000080">, </font>the linked list sort
                copyright<font color="#000080">(</font>c<font color="#000080">) </font><font color="#800000">1995</font><font color="#000080">-</font><font color="#800000">96 </font>by Glenn Grotzinger

Here <font color="#FF0000"><b>is </b></font>a solution from last time<font color="#000080">...

</font><font color="#008000"><i>{$M 64000,0,655360}
</i></font><font color="#FF0000"><b>program </b></font>part17<font color="#000080">; </font><font color="#FF0000"><b>uses </b></font>crt<font color="#000080">;

  </font><font color="#FF0000"><b>type
    </b></font>arptr <font color="#000080">= ^</font>atype<font color="#000080">;
    </font>atype <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">15000</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>integer<font color="#000080">;
  </font><font color="#FF0000"><b>var
    </b></font>a<font color="#000080">: </font>arptr<font color="#000080">;
    </font>number<font color="#000080">: </font>integer<font color="#000080">;
    </font>c<font color="#000080">, </font>i<font color="#000080">, </font>j<font color="#000080">, </font>PIVOT<font color="#000080">, </font>t<font color="#000080">: </font>integer<font color="#000080">;
    </font>found<font color="#000080">: </font>boolean<font color="#000080">;
    </font>location<font color="#000080">: </font>integer<font color="#000080">;
    </font>outfile<font color="#000080">: </font>text<font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>quicksort<font color="#000080">(</font>L<font color="#000080">, </font>R<font color="#000080">: </font>integer<font color="#000080">);
    </font><font color="#008000"><i>{ nothing to say we couldn't sort the data... }
    </i></font><font color="#FF0000"><b>begin
      if </b></font>wherex <font color="#000080">= </font><font color="#800000">79 </font><font color="#FF0000"><b>then
        begin
          </b></font>gotoxy<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">, </font>wherey<font color="#000080">);
          </font>clreol<font color="#000080">;
        </font><font color="#FF0000"><b>end
      else
        </b></font>write<font color="#000080">(</font><font color="#800000">#254</font><font color="#000080">);

      </font><font color="#FF0000"><b>if </b></font>L <font color="#000080">&lt; </font>R <font color="#FF0000"><b>then
        begin
          </b></font>i <font color="#000080">:= </font>L <font color="#000080">+ </font><font color="#800000">1</font><font color="#000080">;
          </font>j <font color="#000080">:= </font>R<font color="#000080">;
          </font>PIVOT <font color="#000080">:= </font>A<font color="#000080">^[</font>L<font color="#000080">];

          </font><font color="#FF0000"><b>repeat
            while </b></font>a<font color="#000080">^[</font>i<font color="#000080">] &lt;= </font>PIVOT <font color="#FF0000"><b>do </b></font>inc<font color="#000080">(</font>i<font color="#000080">);
            </font><font color="#FF0000"><b>while </b></font>a<font color="#000080">^[</font>j<font color="#000080">] &gt; </font>PIVOT <font color="#FF0000"><b>do </b></font>dec<font color="#000080">(</font>j<font color="#000080">);
            </font><font color="#FF0000"><b>if </b></font>i <font color="#000080">&lt; </font>j <font color="#FF0000"><b>then
              begin
                </b></font>t <font color="#000080">:= </font>A<font color="#000080">^[</font>i<font color="#000080">];
                </font>A<font color="#000080">^[</font>i<font color="#000080">] := </font>a<font color="#000080">^[</font>j<font color="#000080">];
                </font>A<font color="#000080">^[</font>j<font color="#000080">] := </font>t<font color="#000080">;
              </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
          </font><font color="#FF0000"><b>until </b></font>i <font color="#000080">&gt; </font>j<font color="#000080">;

          </font>a<font color="#000080">^[</font>l<font color="#000080">] := </font>A<font color="#000080">^[</font>j<font color="#000080">];
          </font>a<font color="#000080">^[</font>j<font color="#000080">] := </font>PIVOT<font color="#000080">;

          </font>quicksort<font color="#000080">(</font>L<font color="#000080">, </font>j<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);
          </font>quicksort<font color="#000080">(</font>i<font color="#000080">, </font>R<font color="#000080">);
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>bsearch<font color="#000080">(</font>number<font color="#000080">, </font>lowend<font color="#000080">, </font>highend<font color="#000080">: </font>integer<font color="#000080">; </font><font color="#FF0000"><b>var </b></font>found<font color="#000080">: </font>boolean<font color="#000080">);
    </font><font color="#FF0000"><b>var
      </b></font>midpoint<font color="#000080">: </font>integer<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      if </b></font>lowend <font color="#000080">&gt; </font>highend <font color="#FF0000"><b>then
        </b></font>found <font color="#000080">:= </font>false
      <font color="#FF0000"><b>else
        begin
          </b></font>midpoint <font color="#000080">:= (</font>lowend <font color="#000080">+ </font>highend<font color="#000080">) </font><font color="#FF0000"><b>div </b></font><font color="#800000">2</font><font color="#000080">;
          </font><font color="#FF0000"><b>if </b></font>number <font color="#000080">= </font>a<font color="#000080">^[</font>midpoint<font color="#000080">] </font><font color="#FF0000"><b>then
            begin
              </b></font>found <font color="#000080">:= </font>true<font color="#000080">;
              </font>location <font color="#000080">:= </font>midpoint<font color="#000080">;
            </font><font color="#FF0000"><b>end
          else if </b></font>number <font color="#000080">&lt; </font>a<font color="#000080">^[</font>midpoint<font color="#000080">] </font><font color="#FF0000"><b>then
            </b></font>bsearch<font color="#000080">(</font>number<font color="#000080">, </font>lowend<font color="#000080">, </font>midpoint<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">, </font>found<font color="#000080">)
          </font><font color="#FF0000"><b>else if </b></font>number <font color="#000080">&gt; </font>a<font color="#000080">^[</font>midpoint<font color="#000080">] </font><font color="#FF0000"><b>then
            </b></font>bsearch<font color="#000080">(</font>number<font color="#000080">, </font>midpoint<font color="#000080">+</font><font color="#800000">1</font><font color="#000080">, </font>highend<font color="#000080">, </font>found<font color="#000080">);
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>begin
    if </b></font>maxavail <font color="#000080">- </font>sizeof<font color="#000080">(</font>a<font color="#000080">) &gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>then
      </b></font>new<font color="#000080">(</font>a<font color="#000080">)
    </font><font color="#FF0000"><b>else
      begin
        </b></font>writeln<font color="#000080">(</font><font color="#800000">'Out of memory!'</font><font color="#000080">);
        </font>halt<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">);
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font>randomize<font color="#000080">;
    </font>assign<font color="#000080">(</font>outfile<font color="#000080">, </font><font color="#800000">'LOCAT2.TXT'</font><font color="#000080">);
    </font>rewrite<font color="#000080">(</font>outfile<font color="#000080">);

    </font><font color="#FF0000"><b>for </b></font>c <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font><font color="#800000">15000 </font><font color="#FF0000"><b>do
      </b></font>a<font color="#000080">^[</font>c<font color="#000080">] := </font>random<font color="#000080">(</font><font color="#800000">25000</font><font color="#000080">) + </font><font color="#800000">1</font><font color="#000080">;

    </font>quicksort<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">, </font><font color="#800000">15000</font><font color="#000080">);

    </font><font color="#FF0000"><b>for </b></font>c <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font><font color="#800000">15000 </font><font color="#FF0000"><b>do
      begin
        </b></font>number <font color="#000080">:= </font>random<font color="#000080">(</font><font color="#800000">25000</font><font color="#000080">) + </font><font color="#800000">1</font><font color="#000080">;
        </font>bsearch<font color="#000080">(</font>number<font color="#000080">, </font><font color="#800000">1</font><font color="#000080">, </font><font color="#800000">15000</font><font color="#000080">, </font>found<font color="#000080">);
        </font><font color="#FF0000"><b>if </b></font>found <font color="#FF0000"><b>then
          </b></font>writeln<font color="#000080">(</font>outfile<font color="#000080">, </font>c<font color="#000080">, </font><font color="#800000">') '</font><font color="#000080">, </font>number<font color="#000080">, </font><font color="#800000">' was found at position '</font><font color="#000080">,
                  </font>location<font color="#000080">, </font><font color="#800000">'.'</font><font color="#000080">);
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font>dispose<font color="#000080">(</font>a<font color="#000080">);
    </font>close<font color="#000080">(</font>outfile<font color="#000080">);

</font><font color="#FF0000"><b>end</b></font><font color="#000080">.


</font>Now we will discuss the idea <font color="#FF0000"><b>of </b></font>the linked list <font color="#FF0000"><b>or </b></font>chained list<font color="#000080">.  </font>Basically<font color="#000080">,
</font>there are <font color="#800000">4 </font>types <font color="#FF0000"><b>of </b></font>linked lists that we can discuss<font color="#000080">, </font>the singularly linked
linear list <font color="#000080">(</font>SLLL<font color="#000080">), </font>singularly linked circular list <font color="#000080">(</font>SLCL<font color="#000080">), </font>doubly linked
linear list <font color="#000080">(</font>DLLL<font color="#000080">), </font><font color="#FF0000"><b>and </b></font>the doubly linked circular list <font color="#000080">(</font>DLCL<font color="#000080">).  </font>I will
use the abbreviations I placed <font color="#FF0000"><b>in </b></font>the parentheses <font color="#FF0000"><b>for </b></font>any future references
<font color="#FF0000"><b>to </b></font>these data types<font color="#000080">.

</font>These are basically the preferred ways <font color="#FF0000"><b>to </b></font>allocate large amounts <font color="#FF0000"><b>of </b></font>storage
space <font color="#FF0000"><b>on </b></font>the heap<font color="#000080">.  </font>All linked lists are basically describable <font color="#FF0000"><b>in </b></font>the best
analogy <font color="#FF0000"><b>as </b></font>a chain<font color="#000080">.  </font>They are <font color="#FF0000"><b>record </b></font>structures which have pointers that
interconnect them<font color="#000080">.  </font>The method that these structures are connected
distinguish the <font color="#FF0000"><b>type of </b></font>linked list it <font color="#FF0000"><b>is</b></font><font color="#000080">.  </font>We will look at an example <font color="#FF0000"><b>of
</b></font>the use <font color="#FF0000"><b>of </b></font>SLLL<font color="#800000">'s, observe the advantages of linked lists through what we
</font><font color="#FF0000"><b>do with </b></font>the example<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>study the things <font color="#FF0000"><b>to </b></font>look <font color="#FF0000"><b>out for on </b></font>all <font color="#800000">4 </font>types<font color="#000080">.

</font>SLLL Concepts
<font color="#000080">=============
</font>This <font color="#FF0000"><b>is </b></font>the simplest <font color="#FF0000"><b>type</b></font><font color="#000080">, </font><font color="#FF0000"><b>in </b></font>sense<font color="#000080">.  </font>It involves a <font color="#FF0000"><b>record </b></font>structure which
<font color="#FF0000"><b>is </b></font>connected <font color="#FF0000"><b>in </b></font>a chain <font color="#FF0000"><b>in </b></font>a linear fashion <font color="#FF0000"><b>with </b></font>one link <font color="#FF0000"><b>forward to </b></font>the
next link<font color="#000080">.  </font>A sample <font color="#FF0000"><b>record </b></font>structure <font color="#FF0000"><b>for </b></font>an SLLL follows below<font color="#000080">.

</font><font color="#FF0000"><b>type
  </b></font>nodeptr <font color="#000080">= ^</font>node<font color="#000080">;
  </font>nodetype <font color="#000080">= </font><font color="#FF0000"><b>record
    </b></font>ourinfo<font color="#000080">: </font>integer<font color="#000080">;
    </font>nextnode<font color="#000080">: </font>nodeptr<font color="#000080">;
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font>An example <font color="#FF0000"><b>of </b></font>an SLLL conceptually <font color="#FF0000"><b>is </b></font>something like this<font color="#000080">:

</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font><font color="#FF0000"><b>nil

As </b></font>we remember from earlier<font color="#000080">, </font><font color="#FF0000"><b>nil is </b></font>what we <font color="#FF0000"><b>set </b></font>a pointer <font color="#FF0000"><b>to</b></font><font color="#000080">, </font><font color="#FF0000"><b>if </b></font>we <font color="#FF0000"><b>do not
</b></font>want it <font color="#FF0000"><b>to </b></font>point <font color="#FF0000"><b>to </b></font>anything<font color="#000080">...</font><font color="#FF0000"><b>In </b></font>the use <font color="#FF0000"><b>of </b></font>an SLLL<font color="#000080">, </font>it <font color="#FF0000"><b>is </b></font>also what we
will use <font color="#FF0000"><b>to </b></font>indicate whether we are at the <font color="#FF0000"><b>end of </b></font>the list <font color="#FF0000"><b>or not</b></font><font color="#000080">.

</font>We will see from the slll_demo <font color="#FF0000"><b>program </b></font>that there are several specialized
issues we need <font color="#FF0000"><b>to </b></font>take into consideration <font color="#FF0000"><b>with </b></font>working <font color="#FF0000"><b>with </b></font>any linked <font color="#FF0000"><b>or
</b></font>chained list<font color="#000080">.

</font><font color="#800000">1</font><font color="#000080">) </font>We need <font color="#FF0000"><b>to </b></font>make a special <font color="#FF0000"><b>case to </b></font>insert <font color="#FF0000"><b>or </b></font>delete a node from the start
<font color="#FF0000"><b>of </b></font>the list<font color="#000080">.
</font><font color="#800000">2</font><font color="#000080">) </font>We need <font color="#FF0000"><b>to </b></font>be sure <font color="#FF0000"><b>to </b></font>maintain <font color="#FF0000"><b>nil </b></font>pointers <font color="#FF0000"><b>in </b></font>any insert <font color="#FF0000"><b>or </b></font>delete
operation<font color="#000080">.
</font><font color="#800000">3</font><font color="#000080">) </font>NEVER NEVER NEVER WORK DIRECTLY <font color="#FF0000"><b>WITH </b></font>THE HEAD TRACKING POINTER WE
ORIGINALLY ALLOCATE UNLESS WE DESIGN OUR CODE COMPLETELY AROUND RECURSION<font color="#000080">.
</font><font color="#FF0000"><b>As </b></font>a result<font color="#000080">, </font>you will cause what <font color="#FF0000"><b>is </b></font>called a heap leak<font color="#000080">.  </font>This <font color="#FF0000"><b>is </b></font>where
the pointer loses track <font color="#FF0000"><b>of </b></font>where the data it points <font color="#FF0000"><b>to is </b></font>stored<font color="#000080">.  </font>Logically<font color="#000080">,
</font>looking at the model above<font color="#000080">, </font><font color="#FF0000"><b>if </b></font>we disconnect one <font color="#FF0000"><b>of </b></font>the pointers<font color="#000080">, </font>represented
by the arrows<font color="#000080">, </font>we lose track <font color="#FF0000"><b>of </b></font>the rest <font color="#FF0000"><b>of </b></font>the list<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>chain<font color="#000080">.  </font>Work <font color="#FF0000"><b>with
</b></font>a temporary pointer <font color="#FF0000"><b>for </b></font>each linked list <font color="#FF0000"><b>function</b></font><font color="#000080">. </font>What I say by recursion<font color="#000080">,
</font>you will see later <font color="#FF0000"><b>in </b></font>this document<font color="#000080">.
</font><font color="#800000">4</font><font color="#000080">) </font><font color="#FF0000"><b>With </b></font>regards <font color="#FF0000"><b>to </b></font>the example I wrote<font color="#000080">, </font>I tried <font color="#FF0000"><b>to </b></font>demonstrate any <font color="#FF0000"><b>and </b></font>all
functions that we might need <font color="#FF0000"><b>with </b></font>an SLLL<font color="#000080">.
</font><font color="#800000">5</font><font color="#000080">) </font>Pointers that point at <font color="#FF0000"><b>nil </b></font>CAN <font color="#FF0000"><b>NOT </b></font>be deallocated<font color="#000080">.  </font>You will see this
fact manifest itself by the memory statement at the <font color="#FF0000"><b>end </b></font>being <font color="#800000">8 </font>bytes
smaller than it was at the start<font color="#000080">.

</font>SLLLs Demonstrated
<font color="#000080">==================
</font>Here <font color="#FF0000"><b>is </b></font>the SLLL_DEMO <font color="#FF0000"><b>program</b></font><font color="#000080">.  </font>I will place stop notes <font color="#FF0000"><b>in </b></font>there<font color="#000080">, </font><font color="#FF0000"><b>as </b></font>well
<font color="#FF0000"><b>as </b></font>comments<font color="#000080">.

</font>Advantages <font color="#FF0000"><b>of </b></font>linked lists<font color="#000080">: </font>We will see here<font color="#000080">, </font>that the data <font color="#FF0000"><b>is not </b></font>static<font color="#000080">,
</font>we can place data independently at different positions WITHOUT shuffling
data<font color="#000080">, </font>remove data <font color="#FF0000"><b>in </b></font>the same fashion<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>definitely are capable <font color="#FF0000"><b>of </b></font>handling
<font color="#000080">*</font>A LOT<font color="#000080">* </font>more data than <font color="#800000">64</font>KB<font color="#000080">, </font>since we only have a <font color="#800000">4 </font>byte stub <font color="#FF0000"><b>in </b></font>that area<font color="#000080">.

</font>Take a good look at this <font color="#FF0000"><b>program and </b></font>seek <font color="#FF0000"><b>to </b></font>understand EXACTLY how it works<font color="#000080">.
</font><font color="#FF0000"><b>As </b></font>you will remember from last time<font color="#000080">, </font>a direct assignment <font color="#FF0000"><b>to </b></font>a pointer <font color="#FF0000"><b>is
</b></font>making it point <font color="#FF0000"><b>to </b></font>something <font color="#FF0000"><b>while </b></font>a reference <font color="#FF0000"><b>to </b></font>the pointer <font color="#000080">(</font>via <font color="#000080">^) </font>changes
the contents <font color="#FF0000"><b>of </b></font>the data it points <font color="#FF0000"><b>to</b></font><font color="#000080">.  </font>I recommend you draw <font color="#FF0000"><b>out </b></font>what <font color="#FF0000"><b>is
</b></font>going <font color="#FF0000"><b>on </b></font>via pencil <font color="#FF0000"><b>and </b></font>paper<font color="#000080">, </font>using boxes <font color="#FF0000"><b>to </b></font>represent the records <font color="#FF0000"><b>and
</b></font>arrows representing pointers<font color="#000080">.  </font>It will help you VASTLY <font color="#FF0000"><b>to do </b></font>this <font color="#FF0000"><b>in
</b></font>understanding what <font color="#FF0000"><b>is </b></font>going <font color="#FF0000"><b>on</b></font><font color="#000080">.  </font>Remember a pointer can only point <font color="#FF0000"><b>to </b></font>one
thing at a time<font color="#000080">.  </font>When you look at this <font color="#FF0000"><b>program</b></font><font color="#000080">, </font>seek <font color="#FF0000"><b>to </b></font>answer the
following questions taking any <font color="#000080">&quot;</font>housekeeping functions<font color="#000080">&quot; </font><font color="#FF0000"><b>out of </b></font>consideration<font color="#000080">:

</font><font color="#800000">1</font><font color="#000080">) </font>Why <font color="#FF0000"><b>is </b></font>the insert code different than the build code<font color="#000080">?
</font><font color="#800000">2</font><font color="#000080">) </font>Why <font color="#FF0000"><b>is </b></font>the delete code different than the cleanup code<font color="#000080">?
</font><font color="#800000">3</font><font color="#000080">) </font><font color="#FF0000"><b>On </b></font>the <font color="#000080">&quot;</font>divisible by <font color="#800000">8</font><font color="#000080">&quot; </font>search<font color="#000080">, </font>why <font color="#FF0000"><b>is </b></font>the NEXT node being searched <font color="#FF0000"><b>for
</b></font>this <font color="#FF0000"><b>and not </b></font>the current node<font color="#000080">?
</font><font color="#800000">4</font><font color="#000080">) </font>Why did I say <font color="#FF0000"><b>to </b></font>always use a temporary variable<font color="#000080">? </font><font color="#FF0000"><b>Or </b></font>Why does the
statement p <font color="#000080">:= </font>list<font color="#000080">; </font>always occur<font color="#000080">?
</font><font color="#800000">5</font><font color="#000080">) </font>Observe methods <font color="#FF0000"><b>of </b></font>moving through the list<font color="#000080">.

</font><font color="#FF0000"><b>program </b></font>slll_demo<font color="#000080">; </font><font color="#FF0000"><b>uses </b></font>crt<font color="#000080">;

  </font><font color="#008000"><i>{ Program written by Glenn Grotzinger for a demonstration of all of the
    functions/uses of a linked list that the author could think of.
    the variable used throughout called p, and sometimes t, are temporary
    variables.

    Note: This probably isn't completely optimized. }

  </i></font><font color="#FF0000"><b>type
    </b></font>nodeptr <font color="#000080">= ^</font>nodetype<font color="#000080">;
    </font>nodetype <font color="#000080">= </font><font color="#FF0000"><b>record
      </b></font>thenum<font color="#000080">: </font>integer<font color="#000080">;
      </font>nextnode<font color="#000080">: </font>nodeptr<font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>var
    </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>buildlist<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure builds up the list for us. }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">: </font>nodeptr<font color="#000080">;
      </font>i<font color="#000080">: </font>integer<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>new<font color="#000080">(</font>list<font color="#000080">);       </font><font color="#008000"><i>{ This is creating the head of the list }
      </i></font>list<font color="#000080">^.</font>thenum <font color="#000080">:= </font><font color="#800000">1</font><font color="#000080">;
      </font>p <font color="#000080">:= </font>list<font color="#000080">;       </font><font color="#008000"><i>{ Set and move temporary pointer }
      </i></font><font color="#FF0000"><b>for </b></font>i <font color="#000080">:= </font><font color="#800000">2 </font><font color="#FF0000"><b>to </b></font><font color="#800000">18 </font><font color="#FF0000"><b>do
        begin
          </b></font>new<font color="#000080">(</font>p<font color="#000080">^.</font>nextnode<font color="#000080">);
          </font>p<font color="#000080">^.</font>nextnode<font color="#000080">^.</font>thenum <font color="#000080">:= </font>i<font color="#000080">;
          </font>p <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">;
         </font><font color="#008000"><i>{ p := p^.nextnode advances the temporary pointer to the next node.
           this is a memory storage address or pointer and not a direct
           variable, referencing a node of the linked list.  Anything, in
           reality does not become a pointer until the new function is used. }
        </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
      </font>p<font color="#000080">^.</font>nextnode <font color="#000080">:= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;   </font><font color="#008000"><i>{ set last pointer to nothing }
    </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>writelist<font color="#000080">(</font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure serves the function of writing out the list for us
      to the screen when called }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">: </font>nodeptr<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>p <font color="#000080">:= </font>list<font color="#000080">;
      </font><font color="#FF0000"><b>while </b></font>p <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil do </b></font><font color="#008000"><i>{ while we're not at the end of the list }
        </i></font><font color="#FF0000"><b>begin
          </b></font>write<font color="#000080">(</font>p<font color="#000080">^.</font>thenum<font color="#000080">:</font><font color="#800000">3</font><font color="#000080">);
          </font>p <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">;
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>insert<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure will serve to insert a node into the list either in
      the middle or the end.  The logic can be done for the head of the
      list. }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">: </font>nodeptr<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>new<font color="#000080">(</font>p<font color="#000080">);
      </font>p<font color="#000080">^.</font>thenum <font color="#000080">:= </font><font color="#800000">20</font><font color="#000080">;
      </font>p<font color="#000080">^.</font>nextnode <font color="#000080">:= </font>list<font color="#000080">;
      </font><font color="#FF0000"><b>if </b></font>p<font color="#000080">^.</font>nextnode <font color="#000080">= </font><font color="#FF0000"><b>nil then  </b></font><font color="#008000"><i>{ maintenance of the end of list marker }
        </i></font>p<font color="#000080">^.</font>nextnode<font color="#000080">^.</font>nextnode <font color="#000080">:= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
      </font>list <font color="#000080">:= </font>p<font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>delete<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);
    </font><font color="#008000"><i>{ This is a procedure that will serve to delete a node from the list,
      and consequently deallocate the memory.  It is possible to remove
      the node without deallocating the memory, though it is a bad practice
      to do so }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">, </font>t<font color="#000080">: </font>nodeptr<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>p <font color="#000080">:= </font>list<font color="#000080">;
      </font>t <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">^.</font>nextnode<font color="#000080">;
      </font>dispose<font color="#000080">(</font>p<font color="#000080">^.</font>nextnode<font color="#000080">);
      </font>p<font color="#000080">^.</font>nextnode <font color="#000080">:= </font>t<font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>insertbythree<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure moves through the linked list and determines where
      the new nodes needs to be inserted, then calls the insert function
      written before }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">: </font>nodeptr<font color="#000080">;
      </font>i<font color="#000080">: </font>integer<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>p <font color="#000080">:= </font>list<font color="#000080">;
      </font>i <font color="#000080">:= </font><font color="#800000">1</font><font color="#000080">;
      </font><font color="#FF0000"><b>while </b></font>p <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil do
        begin
          </b></font>p <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">;
          </font>inc<font color="#000080">(</font>i<font color="#000080">);
          </font><font color="#FF0000"><b>if </b></font>i <font color="#FF0000"><b>mod </b></font><font color="#800000">3 </font><font color="#000080">= </font><font color="#800000">0 </font><font color="#FF0000"><b>then
            </b></font>insert<font color="#000080">(</font>p<font color="#000080">^.</font>nextnode<font color="#000080">);
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>findanddispose<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure finds and disposes the first number in the list
      divisible by 8. }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">, </font>t<font color="#000080">: </font>nodeptr<font color="#000080">;

    </font><font color="#FF0000"><b>begin
      </b></font>p <font color="#000080">:= </font>list<font color="#000080">;
      </font><font color="#FF0000"><b>while </b></font><font color="#000080">(</font>p<font color="#000080">^.</font>nextnode <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil</b></font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>p<font color="#000080">^.</font>nextnode<font color="#000080">^.</font>thenum <font color="#FF0000"><b>mod </b></font><font color="#800000">8 </font><font color="#000080">&lt;&gt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>do
        </b></font>p <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">;
      </font>delete<font color="#000080">(</font>p<font color="#000080">);
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>cleanup<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>list<font color="#000080">: </font>nodeptr<font color="#000080">);

    </font><font color="#008000"><i>{ This procedure removes the list from memory. }

    </i></font><font color="#FF0000"><b>var
      </b></font>p<font color="#000080">, </font>t<font color="#000080">: </font>nodeptr<font color="#000080">;
    </font><font color="#FF0000"><b>begin
      </b></font>p <font color="#000080">:= </font>list<font color="#000080">;
      </font><font color="#FF0000"><b>while </b></font>p <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil do
        begin
          </b></font>t <font color="#000080">:= </font>p<font color="#000080">^.</font>nextnode<font color="#000080">;
          </font>dispose<font color="#000080">(</font>p<font color="#000080">);
          </font>p <font color="#000080">:= </font>t<font color="#000080">;
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>begin
    </b></font>clrscr<font color="#000080">;
    </font>writeln<font color="#000080">;</font>writeln<font color="#000080">;
    </font>writeln<font color="#000080">(</font><font color="#800000">'Free memory available: '</font><font color="#000080">, </font>memavail<font color="#000080">, </font><font color="#800000">' bytes.'</font><font color="#000080">);
    </font>buildlist<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">(</font><font color="#800000">'Free memory available: '</font><font color="#000080">, </font>memavail<font color="#000080">, </font><font color="#800000">' bytes.'</font><font color="#000080">);
    </font>write<font color="#000080">(</font><font color="#800000">'The list is: '</font><font color="#000080">);
    </font>writelist<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">;</font>writeln<font color="#000080">;
    </font>writeln<font color="#000080">(</font><font color="#800000">'Now we will insert a 20 in every third position'</font><font color="#000080">);
    </font>insertbythree<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">(</font><font color="#800000">'Free memory available: '</font><font color="#000080">, </font>memavail<font color="#000080">, </font><font color="#800000">' bytes.'</font><font color="#000080">);
    </font>write<font color="#000080">(</font><font color="#800000">'The list is: '</font><font color="#000080">);
    </font>writelist<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">;</font>writeln<font color="#000080">;
    </font>write<font color="#000080">(</font><font color="#800000">'Now we will search for and take the first # divisible by 8 '</font><font color="#000080">);
    </font>writeln<font color="#000080">(</font><font color="#800000">'out of the list.'</font><font color="#000080">);
    </font>findanddispose<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">(</font><font color="#800000">'Free memory available: '</font><font color="#000080">, </font>memavail<font color="#000080">, </font><font color="#800000">' bytes.'</font><font color="#000080">);
    </font>write<font color="#000080">(</font><font color="#800000">'The list is: '</font><font color="#000080">);
    </font>writelist<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">;</font>writeln<font color="#000080">;
    </font>writeln<font color="#000080">(</font><font color="#800000">'Now we will be good little programmers and clean up our list. :)'</font><font color="#000080">);
    </font>cleanup<font color="#000080">(</font>list<font color="#000080">);
    </font>writeln<font color="#000080">(</font><font color="#800000">'Free memory available: '</font><font color="#000080">, </font>memavail<font color="#000080">, </font><font color="#800000">' bytes.'</font><font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font>Hopefully<font color="#000080">, </font>you can go through here<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>follow the logic <font color="#000080">(</font>actually<font color="#000080">, </font>you will
need <font color="#FF0000"><b>to do </b></font>that successfully <font color="#FF0000"><b>to </b></font>understand what <font color="#FF0000"><b>is </b></font>going <font color="#FF0000"><b>on</b></font><font color="#000080">).

</font>Linked lists are very modular <font color="#FF0000"><b>in </b></font>nature<font color="#000080">.  </font>Therefore<font color="#000080">, </font>a good understanding
<font color="#FF0000"><b>of </b></font>what <font color="#FF0000"><b>is </b></font>going <font color="#FF0000"><b>on </b></font>here <font color="#FF0000"><b>is </b></font>essential<font color="#000080">.  </font><font color="#FF0000"><b>As </b></font>a proof <font color="#FF0000"><b>to </b></font>be able <font color="#FF0000"><b>to </b></font>think
through the logic <font color="#FF0000"><b>of </b></font>using pointers <font color="#FF0000"><b>in </b></font>linked structures<font color="#000080">, </font>write <font color="#FF0000"><b>out and
</b></font>logically explain <font color="#FF0000"><b>on </b></font>your sheet <font color="#FF0000"><b>of </b></font>paper how <font color="#FF0000"><b>to </b></font>perform the following
<font color="#000080">(</font>I will <font color="#FF0000"><b>not </b></font>provide a solution <font color="#FF0000"><b>for </b></font>this one <font color="#000080">-- </font>code it up yourself <font color="#FF0000"><b>and
try and </b></font>figure it <font color="#FF0000"><b>out </b></font><font color="#000080">-- </font>this <font color="#FF0000"><b>is </b></font>an important skill you will need <font color="#FF0000"><b>to </b></font>start
developing <font color="#FF0000"><b>as </b></font>a programmer at this point<font color="#000080">, </font>since you<font color="#800000">'re at a pretty advanced
</font>level now <font color="#000080">(:))), </font><font color="#FF0000"><b>and then </b></font>code it up <font color="#FF0000"><b>as </b></font>a <font color="#FF0000"><b>program</b></font><font color="#000080">:

</font><font color="#800000">1</font><font color="#000080">) </font>Create <font color="#800000">1000 </font>nodes <font color="#FF0000"><b>in </b></font>an SLLL that consists <font color="#FF0000"><b>of </b></font>integers numbered from <font color="#800000">1
</font><font color="#FF0000"><b>to </b></font><font color="#800000">1000.
2</font><font color="#000080">) </font>Print this list <font color="#FF0000"><b>to </b></font>a text <font color="#FF0000"><b>file</b></font><font color="#000080">.
</font><font color="#800000">3</font><font color="#000080">) </font>Reverse the direction <font color="#FF0000"><b>of </b></font>the linked list<font color="#000080">.  </font>By doing this<font color="#000080">, </font>I mean<font color="#000080">, </font>instead
<font color="#FF0000"><b>of </b></font>the linked list looking like this conceptually<font color="#000080">:

                   </font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font>NODE<font color="#000080">--&gt;</font><font color="#FF0000"><b>nil

</b></font>make it look like this<font color="#000080">:

                   </font><font color="#FF0000"><b>nil</b></font><font color="#000080">&lt;--</font>NODE<font color="#000080">&lt;--</font>NODE<font color="#000080">&lt;--</font>NODE

<font color="#FF0000"><b>DO NOT </b></font>CREATE ANOTHER LINKED LIST <font color="#FF0000"><b>IN </b></font>MEMORY<font color="#000080">.  </font>USE THE CURRENT ONE YOU HAVE
BUILT<font color="#000080">.

</font><font color="#800000">4</font><font color="#000080">) </font>Print the new list <font color="#FF0000"><b>to </b></font>the same text <font color="#FF0000"><b>file</b></font><font color="#000080">.  </font>Instead <font color="#FF0000"><b>of </b></font>it being from <font color="#800000">1
</font><font color="#FF0000"><b>to </b></font><font color="#800000">1000 </font><font color="#FF0000"><b>as </b></font>the first printing was<font color="#000080">, </font>it should be from <font color="#800000">1000 </font><font color="#FF0000"><b>to </b></font><font color="#800000">1.

</font>CLUE<font color="#000080">: </font>Think about how many temporary variables you will need <font color="#000080">(</font><font color="#800000">1</font><font color="#000080">?  </font>Maybe <font color="#800000">2</font><font color="#000080">?,
</font>Possibly <font color="#800000">3</font><font color="#000080">?).

</font>SLCL Concepts
<font color="#000080">=============
</font>This <font color="#FF0000"><b>is </b></font>essentially the same <font color="#FF0000"><b>as </b></font>an SLLL<font color="#000080">, </font><font color="#FF0000"><b>except </b></font>instead <font color="#FF0000"><b>of </b></font>being <font color="#FF0000"><b>nil </b></font>at the
<font color="#FF0000"><b>end of </b></font>the list<font color="#000080">, </font>the <font color="#FF0000"><b>end of </b></font>the list points at the beginning <font color="#FF0000"><b>of </b></font>the list<font color="#000080">.
</font>This <font color="#FF0000"><b>type uses </b></font>the same <font color="#FF0000"><b>record </b></font>format <font color="#FF0000"><b>as </b></font>the SLLL<font color="#000080">.

</font>Conceptually<font color="#000080">, </font>an SLCL looks like this<font color="#000080">:

  </font>NODE<font color="#000080">---&gt;</font>NODE<font color="#000080">---&gt;</font>NODE<font color="#000080">---&gt;</font>NODE<font color="#000080">---&gt;</font>NODE
   <font color="#000080">^                               |
   |                               </font>V
  NODE                            NODE
   <font color="#000080">^                               |
   |                               </font>V
  NODE<font color="#000080">&lt;---</font>NODE<font color="#000080">&lt;---</font>NODE<font color="#000080">&lt;---</font>NODE<font color="#000080">&lt;---</font>NODE

<font color="#FF0000"><b>As </b></font>before <font color="#FF0000"><b>with </b></font>the SLLL<font color="#000080">, </font>one <font color="#FF0000"><b>of </b></font>these nodes would be denoted <font color="#FF0000"><b>as </b></font>the head
<font color="#FF0000"><b>of </b></font>the list<font color="#000080">.

</font>The only consideration that would differ that I could note<font color="#000080">, </font><font color="#FF0000"><b>is </b></font>that you
would use a comparison <font color="#FF0000"><b>of </b></font>your temporary pointer <font color="#FF0000"><b>with </b></font>your head pointer
<font color="#FF0000"><b>in </b></font>order <font color="#FF0000"><b>to </b></font>move through the list<font color="#000080">.

</font>So instead <font color="#FF0000"><b>of while </b></font>p <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil</b></font><font color="#000080">, </font>it would be <font color="#FF0000"><b>while </b></font>p <font color="#000080">&lt;&gt; </font>list <font color="#FF0000"><b>in </b></font>the above
example <font color="#FF0000"><b>to </b></font>make it that way<font color="#000080">.

</font>DLLL Concepts
<font color="#000080">=============
</font>This <font color="#FF0000"><b>type of </b></font>linked list <font color="#FF0000"><b>uses </b></font>a different kind <font color="#FF0000"><b>of record </b></font>format<font color="#000080">.  </font>It looks
like this<font color="#000080">:

</font><font color="#FF0000"><b>type
  </b></font>nodeptr <font color="#000080">= ^</font>node<font color="#000080">;
  </font>node <font color="#000080">= </font><font color="#FF0000"><b>record
    </b></font>ourinfo<font color="#000080">: </font>integer<font color="#000080">;
    </font>lastnode<font color="#000080">, </font>nextnode<font color="#000080">: </font>nodeptr<font color="#000080">;
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font>Conceptually<font color="#000080">, </font>a DLLL looks like this<font color="#000080">:

                </font><font color="#FF0000"><b>nil </b></font><font color="#000080">&lt;--    &lt;--    &lt;--    &lt;--
                       </font>NODE   NODE   NODE   NODE
                           <font color="#000080">--&gt;    --&gt;    --&gt;    --&gt; </font><font color="#FF0000"><b>nil

If </b></font>you study up your logic from previously<font color="#000080">, </font>this one shouldn<font color="#800000">'t be too awfully
</font>bad <font color="#FF0000"><b>to </b></font>figure <font color="#FF0000"><b>out</b></font><font color="#000080">.

</font>DLCL Concepts
<font color="#000080">=============
</font>This <font color="#FF0000"><b>type of </b></font>list <font color="#FF0000"><b>uses </b></font>the same <font color="#FF0000"><b>record </b></font>format <font color="#FF0000"><b>as </b></font>the DLLL<font color="#000080">.  </font>The conceptual
diagram looks much like the SLCL diagram<font color="#000080">, </font>but <font color="#FF0000"><b>with </b></font>double links much like
the DLLL diagram<font color="#000080">, </font>instead <font color="#FF0000"><b>of </b></font>single links<font color="#000080">.

</font>Final Thoughts <font color="#FF0000"><b>on </b></font>Linked Lists
<font color="#000080">==============================
</font>I did <font color="#FF0000"><b>not </b></font>provide examples <font color="#FF0000"><b>of </b></font>SLCLs<font color="#000080">, </font>DLLLs<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>DLCLs <font color="#000080">, </font>merely <font color="#FF0000"><b>for </b></font>space<font color="#000080">,
</font><font color="#FF0000"><b>and </b></font>also by the fact that I have never had reason <font color="#FF0000"><b>to </b></font>use the other three
types<font color="#000080">.  </font>I am presenting their basics here<font color="#000080">, </font>merely <font color="#FF0000"><b>for </b></font>people<font color="#800000">'s study, and
</font>learning<font color="#000080">.  </font>Using the knowledge learned from doing those logic problems
presented <font color="#FF0000"><b>in </b></font>the SLLLs<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>references <font color="#000080">(</font>though I find those <font color="#FF0000"><b>to </b></font>be VERY
sparse <font color="#FF0000"><b>on </b></font>the types other than SLLL<font color="#000080">), </font>you should be able <font color="#FF0000"><b>to </b></font>come up <font color="#FF0000"><b>with
</b></font>the code <font color="#FF0000"><b>to do </b></font>the other three types pretty readily<font color="#000080">.  </font>Always remember that
the best thing <font color="#FF0000"><b>to do to </b></font>work <font color="#FF0000"><b>out </b></font>the logic <font color="#FF0000"><b>of </b></font>what <font color="#FF0000"><b>to do with </b></font>the pointers
<font color="#FF0000"><b>is to </b></font>draw it <font color="#FF0000"><b>out </b></font>using the boxes <font color="#FF0000"><b>and </b></font>the arrows<font color="#000080">.

</font>An Idea <font color="#FF0000"><b>on </b></font>Sorting Data Using Linked Lists
<font color="#000080">==========================================
</font>Here<font color="#000080">, </font>I will now present the reasoning behind my <font color="#000080">&quot;</font>recursion<font color="#000080">&quot; </font>statement<font color="#000080">,
</font>plus an idea <font color="#FF0000"><b>of </b></font>sorting data upon build<font color="#000080">.  </font>I don<font color="#800000">'t have any stats on
</font>this being more <font color="#FF0000"><b>or </b></font>less efficient than using one <font color="#FF0000"><b>of </b></font>the <font color="#FF0000"><b>array </b></font>sorts<font color="#000080">,
</font>but <font color="#FF0000"><b>if </b></font>you can<font color="#800000">'t use an array to sort in memory, you would have to resort
</font><font color="#FF0000"><b>to </b></font>this<font color="#000080">.

</font>Here <font color="#FF0000"><b>is </b></font>a little code<font color="#000080">/</font>pseudocode <font color="#000080">(</font><font color="#FF0000"><b>with </b></font>a bent toward sorting names
alphabetically<font color="#000080">)  </font><font color="#FF0000"><b>For </b></font>purposes <font color="#FF0000"><b>of </b></font>the recursion<font color="#000080">, </font>we will call the
<font color="#FF0000"><b>function </b></font>INSERT<font color="#000080">:

</font><font color="#FF0000"><b>IF </b></font>WE ARE <font color="#FF0000"><b>TO </b></font>PUT NODE HERE
  GET DATA <font color="#FF0000"><b>TO </b></font>PUT INTO NODE <font color="#000080">(</font>read data from <font color="#FF0000"><b>file</b></font><font color="#000080">, </font><font color="#FF0000"><b>or </b></font>elsewhere<font color="#000080">)
</font><font color="#FF0000"><b>WHILE </b></font>DATA <font color="#FF0000"><b>IS NOT </b></font>DONE <font color="#FF0000"><b>DO
  BEGIN
    IF NIL </b></font>LIST <font color="#FF0000"><b>THEN
      </b></font>PUT NODE HERE
    <font color="#FF0000"><b>ELSE
      </b></font>PUT NODE HERE <font color="#000080">= </font>NEWNAME <font color="#000080">&lt;= </font>NODE<font color="#000080">^.</font>NAME
    <font color="#FF0000"><b>IF </b></font>WE ARE <font color="#FF0000"><b>TO </b></font>PUT NODE HERE <font color="#FF0000"><b>THEN
      BEGIN
        </b></font>new<font color="#000080">(</font>p<font color="#000080">);
        </font><font color="#FF0000"><b>SET </b></font>DATA <font color="#FF0000"><b>TO </b></font>NODE
        p<font color="#000080">^.</font>nextnode <font color="#000080">:= </font>LIST<font color="#000080">;
        </font><font color="#FF0000"><b>if </b></font>p<font color="#000080">^.</font>nextnode <font color="#000080">= </font><font color="#FF0000"><b>nil then
          </b></font>p<font color="#000080">^.</font>nextnode<font color="#000080">^.</font>nextnode <font color="#000080">= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
        </font>list <font color="#000080">:= </font>p<font color="#000080">;
      </font><font color="#FF0000"><b>END
    ELSE
      </b></font>INSERT<font color="#000080">(</font>LIST<font color="#000080">^.</font>NEXTNODE<font color="#000080">);
    </font><font color="#FF0000"><b>IF </b></font>WE ARE <font color="#FF0000"><b>TO </b></font>PUT NODE HERE <font color="#FF0000"><b>THEN
      BEGIN
        </b></font>GET INFO<font color="#000080">.
        </font><font color="#FF0000"><b>DO NOT </b></font>PUT NODE HERE <font color="#000080">(</font>boolean variable <font color="#FF0000"><b>set to </b></font>false<font color="#000080">).
      </font><font color="#FF0000"><b>END</b></font><font color="#000080">.
  </font><font color="#FF0000"><b>END</b></font><font color="#000080">.

</font>This general code does work <font color="#FF0000"><b>for </b></font>a high capacity<font color="#000080">.  </font>I have used this code 
<font color="#FF0000"><b>to </b></font>sort a maximum <font color="#FF0000"><b>of </b></font>an <font color="#800000">86</font>KB list <font color="#FF0000"><b>of </b></font><font color="#800000">150 </font>char items per line alphabetically
using memory alone<font color="#000080">, </font>no disk swapping<font color="#000080">.

</font><font color="#FF0000"><b>For </b></font>practice<font color="#000080">: </font><font color="#FF0000"><b>Do </b></font>things <font color="#FF0000"><b>as </b></font>I have suggested throughout this document<font color="#000080">.
</font>No real practice problem<font color="#000080">.

</font>Next Time
<font color="#000080">=========
</font>We will talk about binary trees<font color="#000080">.  </font>Be sure <font color="#FF0000"><b>to </b></font>send comments <font color="#FF0000"><b>to
</b></font>ggrotz<font color="#000080">@</font><font color="#800000">2</font>sprint<font color="#000080">.</font>net<font color="#000080">.  </font>I will say again that I apologize <font color="#FF0000"><b>for </b></font>the long
period <font color="#FF0000"><b>of </b></font>time it took <font color="#FF0000"><b>to </b></font>get this <font color="#FF0000"><b>out</b></font><font color="#000080">.  </font>I also apologize <font color="#FF0000"><b>for </b></font>the length
this document has become<font color="#000080">.  </font>Be sure <font color="#FF0000"><b>to </b></font>please comment <font color="#FF0000"><b>on </b></font>how this
part <font color="#FF0000"><b>is</b></font><font color="#000080">.
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to TUTOR SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0021.PAS">Original</a><b>]</b></p></body>
</html>
