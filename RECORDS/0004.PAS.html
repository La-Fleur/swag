<html>
<head><title> "RECINFO1.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to RECORDS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0004.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#000080">&gt;</font>Can anyone tell me how I can delete a <font color="#FF0000"><b>Record </b></font>from a <font color="#FF0000"><b>File</b></font><font color="#000080">?

</font>Two ways<font color="#000080">.

</font><font color="#800000">1</font><font color="#000080">) </font>Mark the <font color="#FF0000"><b>Record With </b></font>a value that tells your <font color="#FF0000"><b>Program </b></font>that
   <font color="#FF0000"><b>Record is </b></font>classified <font color="#FF0000"><b>as </b></font>deleted<font color="#000080">. (</font>Most DB Programs work this
   way<font color="#000080">)

</font><font color="#800000">2</font><font color="#000080">) </font>Read the WHOLE <font color="#FF0000"><b>File in</b></font><font color="#000080">, </font>one <font color="#FF0000"><b>Record </b></font>at a time<font color="#000080">. </font>Copy these
   Records into the new <font color="#FF0000"><b>File</b></font><font color="#000080">. </font><font color="#FF0000"><b>While </b></font>you are copying<font color="#000080">, </font>ignore any
   <font color="#FF0000"><b>Record</b></font><font color="#000080">(</font>s<font color="#000080">) </font>you want <font color="#FF0000"><b>to </b></font>delete<font color="#000080">.

   </font>Once the copy <font color="#FF0000"><b>is </b></font>Complete<font color="#000080">, </font>delete the old <font color="#FF0000"><b>File and </b></font>rename the
   new <font color="#FF0000"><b>to </b></font>the old Filename<font color="#000080">...

</font>You could also open the <font color="#FF0000"><b>File as </b></font>unTyped <font color="#000080">:-), </font><font color="#FF0000"><b>and </b></font>use blockRead <font color="#FF0000"><b>to </b></font>read big
chunks <font color="#FF0000"><b>Until </b></font>you<font color="#800000">'ve read (recSize * number of Records beFore bad one) Bytes,
</font><font color="#FF0000"><b>and </b></font>blockWrite <font color="#FF0000"><b>to </b></font>Write them <font color="#FF0000"><b>out to </b></font>the temp <font color="#FF0000"><b>File</b></font><font color="#000080">.  </font>This might be faster<font color="#000080">,
</font>depending <font color="#FF0000"><b>on </b></font>the number <font color="#FF0000"><b>of </b></font>Records <font color="#FF0000"><b>and </b></font>how big they are<font color="#000080">.

&gt; </font>How would I pack a <font color="#FF0000"><b>File of </b></font>Records <font color="#FF0000"><b>to </b></font>save space<font color="#000080">?

    </font><font color="#FF0000"><b>if </b></font>you have seen other posts by me about packing Database <font color="#FF0000"><b>Type
</b></font>Files<font color="#000080">, </font>you will see I normally recommend against it<font color="#000080">.

</font>I usually go <font color="#FF0000"><b>With </b></font>a <font color="#000080">&quot;</font>Deleted<font color="#000080">&quot; </font>indicator <font color="#FF0000"><b>and </b></font>Records marked <font color="#FF0000"><b>as
</b></font>deleted are re<font color="#000080">-</font>used<font color="#000080">. </font>It <font color="#FF0000"><b>is </b></font>my personnal experience that such Files
normally grow <font color="#FF0000"><b>in </b></font>size <font color="#FF0000"><b>Until </b></font>they reach a balanced state<font color="#000080">. </font>A state <font color="#FF0000"><b>in
</b></font>which the <font color="#FF0000"><b>File </b></font>does <font color="#FF0000"><b>not </b></font>grow anymore <font color="#FF0000"><b>and </b></font>where balance <font color="#FF0000"><b>is </b></font>reached
between Additions <font color="#FF0000"><b>and </b></font>Deletions<font color="#000080">.

</font><font color="#FF0000"><b>if </b></font>you Really want <font color="#FF0000"><b>to </b></font>pack it <font color="#FF0000"><b>then</b></font><font color="#000080">,

    </font><font color="#800000">1</font><font color="#000080">- </font>Build a list <font color="#FF0000"><b>of </b></font>deleted Records
    <font color="#800000">2</font><font color="#000080">- </font>take the last <font color="#FF0000"><b>Record in </b></font>the <font color="#FF0000"><b>File
    </b></font><font color="#800000">3</font><font color="#000080">- </font>Keep a note that that <font color="#FF0000"><b>Record is </b></font>now empty
    <font color="#800000">4</font><font color="#000080">- </font>OverWrite the FIRST DELETED <font color="#FF0000"><b>Record</b></font><font color="#800000">'s space With it
    5</font><font color="#000080">- </font><font color="#FF0000"><b>Repeat </b></font>steps <font color="#800000">2</font><font color="#000080">-</font><font color="#800000">4 </font><font color="#FF0000"><b>Until </b></font>all deleted Records have been filled<font color="#000080">.
    </font><font color="#800000">6</font><font color="#000080">- </font>Seek <font color="#FF0000"><b>to </b></font>the first <font color="#FF0000"><b>Record </b></font>marked empty<font color="#000080">, </font>this should be the last
       one you moved<font color="#000080">.
       </font><font color="#FF0000"><b>or </b></font>you could simply seek <font color="#FF0000"><b>to </b></font>Record_COunt since the <font color="#FF0000"><b>File </b></font>should
       now contain no empty space all valid Records should be at the
       head <font color="#FF0000"><b>of </b></font>the <font color="#FF0000"><b>File and </b></font>thus seeking <font color="#FF0000"><b>to </b></font>Record_Count ensures you
       <font color="#FF0000"><b>of </b></font>being positionned at the very <font color="#FF0000"><b>end</b></font><font color="#000080">.
    </font><font color="#800000">7</font><font color="#000080">- </font>Truncate the <font color="#FF0000"><b>File </b></font>there by using the Truncate command<font color="#000080">.
    </font><font color="#800000">8</font><font color="#000080">- </font>Be sure <font color="#FF0000"><b>to </b></font>close <font color="#FF0000"><b>and </b></font>re<font color="#000080">-</font>open the <font color="#FF0000"><b>File </b></font>beFore any more processing
       so that Directory <font color="#FF0000"><b>and </b></font>FAT are updated<font color="#000080">.


&gt; </font>Could someone please give me an example <font color="#FF0000"><b>of </b></font>a good way <font color="#000080">(</font>the best way<font color="#000080">?) </font><font color="#FF0000"><b>to
</b></font><font color="#000080">&gt; </font>delete Records from a Typed <font color="#FF0000"><b>File</b></font><font color="#000080">?  </font>My only guess<font color="#000080">, </font>after looking at all
<font color="#000080">&gt; </font><font color="#FF0000"><b>of </b></font>the TP documentation<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>my one TP book<font color="#000080">, </font><font color="#FF0000"><b>is </b></font>that I will have <font color="#FF0000"><b>to </b></font>read
<font color="#000080">&gt; </font>the <font color="#FF0000"><b>File</b></font><font color="#000080">, </font><font color="#FF0000"><b>and </b></font>Write a new <font color="#FF0000"><b>File</b></font><font color="#000080">, </font>excluding the <font color="#000080">&quot;</font>deleted<font color="#000080">&quot; </font><font color="#FF0000"><b>Record</b></font><font color="#000080">.  </font>This
<font color="#000080">&gt; </font>will require another <font color="#000080">(</font>identical<font color="#000080">) </font><font color="#FF0000"><b>Type </b></font>statment<font color="#000080">, </font><font color="#FF0000"><b>and File </b></font>Variable<font color="#000080">, </font>etc<font color="#000080">.,
&gt; </font><font color="#FF0000"><b>and </b></font>will require me <font color="#FF0000"><b>to then </b></font>rename the smaller <font color="#FF0000"><b>File</b></font><font color="#000080">...
&gt;
&gt; </font>Isn<font color="#800000">'t there a more efficient way????

</font>YES THERE <font color="#FF0000"><b>IS</b></font><font color="#000080">!!!

</font>Modify your <font color="#FF0000"><b>Record to </b></font>this<font color="#000080">:

</font><font color="#FF0000"><b>Type
  </b></font>My_Record <font color="#000080">= </font><font color="#FF0000"><b>Record
    </b></font>Deleted <font color="#000080">: </font>Boolean<font color="#000080">;
    &lt; </font>Rest <font color="#FF0000"><b>of </b></font>your usual stuff <font color="#000080">&gt;
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

    </font>Now <font color="#FF0000"><b>if </b></font>you use index Files<font color="#000080">, </font>create an index <font color="#FF0000"><b>File With </b></font>the DELETED
field <font color="#FF0000"><b>as </b></font>the key <font color="#FF0000"><b>to </b></font>that index<font color="#000080">.

</font>Pseudo code ahead<font color="#000080">:

    </font>Adding a <font color="#FF0000"><b>Record</b></font><font color="#000080">:
        </font><font color="#800000">1</font><font color="#000080">- </font><font color="#FF0000"><b>Set </b></font>index <font color="#FF0000"><b>to </b></font>DELETED
        <font color="#800000">2</font><font color="#000080">- </font>Go <font color="#FF0000"><b>to </b></font>first <font color="#FF0000"><b>Record
        </b></font><font color="#800000">3</font><font color="#000080">- </font><font color="#FF0000"><b>Is </b></font>it deleted
        <font color="#800000">4</font><font color="#000080">- </font>Yes<font color="#000080">, </font>use it <font color="#FF0000"><b>as </b></font>our new <font color="#FF0000"><b>Record
            </b></font><font color="#800000">4</font>a Change the Deleted field <font color="#FF0000"><b>to </b></font>False<font color="#000080">;
            </font><font color="#800000">4</font>b Write our new <font color="#FF0000"><b>Record to </b></font>this one overwriting it<font color="#000080">.
        </font><font color="#800000">5</font><font color="#000080">- </font>No<font color="#000080">, </font>Add a new phisical <font color="#FF0000"><b>Record to </b></font>the <font color="#FF0000"><b>File</b></font><font color="#000080">,
            </font><font color="#800000">5</font>a Remember <font color="#FF0000"><b>to Set </b></font>Deleted <font color="#FF0000"><b>to </b></font>False <font color="#FF0000"><b>on </b></font>this one
            <font color="#800000">5</font>b Write our <font color="#FF0000"><b>Record to </b></font>the new <font color="#FF0000"><b>Record</b></font><font color="#000080">.

    </font>Deleting a <font color="#FF0000"><b>Record</b></font><font color="#000080">:
        </font><font color="#800000">1</font><font color="#000080">- </font>Go <font color="#FF0000"><b>to Record</b></font><font color="#000080">,
        </font><font color="#800000">2</font><font color="#000080">- </font>Read it <font color="#FF0000"><b>in
        </b></font><font color="#800000">3</font><font color="#000080">- </font><font color="#FF0000"><b>Set </b></font>the deleted field <font color="#FF0000"><b>to </b></font>True<font color="#000080">.
            </font><font color="#008000"><i>{ This allows UnDeleting a Record With it's original data}

    </i></font>Listing Records<font color="#000080">:
        </font>Remember <font color="#FF0000"><b>to </b></font>skip deleted Records<font color="#000080">.

</font>you will soon find that using this management method your applications
will perForm at speeds vastly faster than others<font color="#000080">. </font>Simply because the
<font color="#FF0000"><b>File is </b></font>never moved<font color="#000080">, </font>truncated etc<font color="#000080">.. </font>Eliminating fragentation <font color="#FF0000"><b>on </b></font>the
disk<font color="#000080">. </font>You will also find that <font color="#FF0000"><b>as </b></font>you open new databases<font color="#000080">, </font>they will
quickly grow <font color="#FF0000"><b>and then </b></font>attain a stable size where new Records are mostly
reusing deleted Records<font color="#000080">.

    </font>This <font color="#FF0000"><b>is </b></font>how my dBase applications are handled<font color="#000080">. </font>Our last project
<font color="#FF0000"><b>While </b></font>I was at the Justice Departement was re<font color="#000080">-</font>written <font color="#FF0000"><b>to </b></font>use this
principle <font color="#FF0000"><b>of </b></font>management instead <font color="#FF0000"><b>of </b></font>using dBase<font color="#800000">'s Pack and delete
</font>routines<font color="#000080">. </font>The efficiency was greatly augmented both <font color="#FF0000"><b>in </b></font>speed <font color="#FF0000"><b>and in </b></font>disk
occupation<font color="#000080">. </font>We no longer needed <font color="#FF0000"><b>to </b></font>perForm unfragmentation routines
periodically <font color="#FF0000"><b>and </b></font>we also could reverse any error our users might have
commited<font color="#000080">.

    </font>By adding additionnal info such <font color="#FF0000"><b>as </b></font>deletion date<font color="#000080">, </font>user ID that
requested the delete etc<font color="#000080">... </font>we were able <font color="#FF0000"><b>to </b></font>offer options that were <font color="#FF0000"><b>not
</b></font>available beFore<font color="#000080">. </font>An added benefit was that we didn<font color="#800000">'t need to reindex
</font>the whole database<font color="#000080">. </font>Affected Index Files were open during operations <font color="#FF0000"><b>and
</b></font>were thus opdated <font color="#FF0000"><b>on </b></font>the fly<font color="#000080">. </font>So our Deleted index was allways uptodate<font color="#000080">.
</font>Generating a <font color="#FF0000"><b>message </b></font>when physical space was added <font color="#FF0000"><b>to </b></font>the database<font color="#000080">, </font>we
were able <font color="#FF0000"><b>to </b></font>perForm defragementation only when Really needed<font color="#000080">. </font><font color="#FF0000"><b>and </b></font>those
operations were greatly shortened <font color="#FF0000"><b>in </b></font>time because <font color="#800000">98</font><font color="#000080">% </font><font color="#FF0000"><b>of </b></font>the database
was allready defragmentated<font color="#000080">.

</font>It<font color="#800000">'s the sensible way to do it, and it can be done in any language.

</font><font color="#008000"><i>{------------------------------------------------------------------------}

</i></font><font color="#000080">&gt;   </font>Can someone tell me how <font color="#FF0000"><b>to </b></font>search through a Typed <font color="#FF0000"><b>File</b></font><font color="#000080">.
&gt;   </font>Example<font color="#000080">:
&gt;      </font><font color="#FF0000"><b>Type </b></font>Dummy <font color="#000080">= </font><font color="#FF0000"><b>Record
</b></font><font color="#000080">&gt;                     </font>Name <font color="#000080">: </font><font color="#FF0000"><b>String
</b></font><font color="#000080">&gt;                     </font>Age  <font color="#000080">: </font>Integer
<font color="#000080">&gt;                   </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
&gt;           </font>DummyFile <font color="#000080">= </font><font color="#FF0000"><b>File of </b></font>Dummy<font color="#000080">;

&gt;   </font>How could I find a <font color="#FF0000"><b>Record </b></font>that has AGE <font color="#000080">= </font><font color="#800000">20 </font><font color="#000080">?

</font><font color="#FF0000"><b>Do </b></font>something like this<font color="#000080">:

</font><font color="#FF0000"><b>Var
  </b></font>PersonRecord <font color="#000080">: </font>Dummy<font color="#000080">;

</font><font color="#FF0000"><b>Procedure </b></font>searchForAge<font color="#000080">(</font>PersonsAge<font color="#000080">: </font>Integer<font color="#000080">);
</font><font color="#FF0000"><b>begin
   </b></font><font color="#000080">... </font>Open the <font color="#FF0000"><b>File </b></font><font color="#000080">...
   </font>Seek<font color="#000080">(</font>DummyFile<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">);        </font><font color="#008000"><i>{start at beginning of File}
   </i></font>PersonRecord<font color="#000080">.</font>Age<font color="#000080">:= </font><font color="#800000">1000</font><font color="#000080">;   </font><font color="#008000"><i>{Init to unused value}
   </i></font><font color="#FF0000"><b>While not</b></font><font color="#000080">(</font>Eof<font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>PersonRecord<font color="#000080">.</font>Age <font color="#000080">&lt;&gt; </font>PersonsAge<font color="#000080">) </font><font color="#FF0000"><b>do
   begin
       </b></font>Read<font color="#000080">(</font>DummyFile<font color="#000080">, </font>PersonRecord<font color="#000080">);
   </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
   ... </font>Close the <font color="#FF0000"><b>File </b></font><font color="#000080">...
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;


</font>This might work<font color="#000080">:
 </font><font color="#FF0000"><b>Type
   </b></font>rec <font color="#000080">= </font><font color="#FF0000"><b>Record
     </b></font>age<font color="#000080">: </font>Integer<font color="#000080">;
     </font>etc<font color="#000080">...
   </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 </font><font color="#FF0000"><b>Var
   </b></font>f<font color="#000080">: </font><font color="#FF0000"><b>File of </b></font>rec<font color="#000080">;
   </font>r<font color="#000080">: </font>rec<font color="#000080">;
 </font><font color="#FF0000"><b>begin
   </b></font>assign<font color="#000080">(</font>f<font color="#000080">, </font><font color="#800000">'FileNAME.EXT'</font><font color="#000080">);
   </font>reset<font color="#000080">(</font>f<font color="#000080">, </font>sizeof<font color="#000080">(</font>rec<font color="#000080">));           </font><font color="#008000"><i>(* have to indicate Record size *)

   </i></font><font color="#FF0000"><b>While not </b></font>eof<font color="#000080">(</font>f<font color="#000080">) </font><font color="#FF0000"><b>do begin
     </b></font>blockread<font color="#000080">(</font>f<font color="#000080">, </font>r<font color="#000080">, </font><font color="#800000">1</font><font color="#000080">);            </font><font color="#008000"><i>(* read one rec from f into r *)
     </i></font><font color="#FF0000"><b>if </b></font>r<font color="#000080">.</font>age <font color="#000080">= </font><font color="#800000">20 </font><font color="#FF0000"><b>then
       </b></font><font color="#008000"><i>(* do something interesting *)
   </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
   </font>close<font color="#000080">(</font>f<font color="#000080">);
 </font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font>The trick <font color="#FF0000"><b>is to </b></font>inForm the runtime <font color="#FF0000"><b>library of </b></font>the size <font color="#FF0000"><b>of </b></font>each <font color="#FF0000"><b>Record in </b></font>the
<font color="#FF0000"><b>File</b></font><font color="#000080">; </font>you <font color="#FF0000"><b>do </b></font>this <font color="#FF0000"><b>in </b></font>the call <font color="#FF0000"><b>to </b></font>reset<font color="#000080">.  </font>Blockread takes a <font color="#FF0000"><b>File</b></font><font color="#000080">, </font>an unTyped
buffer<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>the number <font color="#FF0000"><b>of </b></font>Records <font color="#FF0000"><b>to </b></font>read<font color="#000080">.





&gt;</font>I know that this <font color="#FF0000"><b>is </b></font>probably <font color="#FF0000"><b>as </b></font>common <font color="#FF0000"><b>as </b></font>the <font color="#000080">&quot;</font>I want <font color="#FF0000"><b>to </b></font>Write a BBS<font color="#000080">&quot;,
&gt;</font><font color="#FF0000"><b>and </b></font><font color="#000080">&quot;*.</font>MSG structures<font color="#000080">&quot; :) </font>but haven<font color="#800000">'t seen anything lately (and I'</font>ve
<font color="#000080">&gt;</font>been reading this <font color="#FF0000"><b>For </b></font>quite some time<font color="#000080">) </font>about tips <font color="#FF0000"><b>on </b></font>searching Records
<font color="#000080">&gt;</font><font color="#FF0000"><b>in </b></font>a <font color="#FF0000"><b>File</b></font><font color="#000080">.  </font>Any tips<font color="#000080">/</font>routines <font color="#FF0000"><b>on </b></font>fast searching<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>ways <font color="#FF0000"><b>to set </b></font>up the
<font color="#000080">&gt;</font><font color="#FF0000"><b>Record For </b></font>fast searching<font color="#000080">?  </font>Thanks<font color="#000080">.

   </font>Well<font color="#000080">, </font>you<font color="#800000">'re kinda restricting yourself by saying, &quot;in a File&quot;.  That means
</font>you have a <font color="#FF0000"><b>File of </b></font>some <font color="#FF0000"><b>Type</b></font><font color="#000080">, </font><font color="#FF0000"><b>and </b></font>you<font color="#800000">'re pretty-much confined to the ways
</font>appropriate <font color="#FF0000"><b>For </b></font>that <font color="#FF0000"><b>File Type</b></font><font color="#000080">.  </font>However<font color="#000080">, </font>there are some things you can <font color="#FF0000"><b>do
</b></font>which will make processing the data faster <font color="#FF0000"><b>and </b></font>more efficient<font color="#000080">:
 </font><font color="#800000">1. </font><font color="#FF0000"><b>For </b></font>Text Files<font color="#000080">:
   </font>a<font color="#000080">. </font>use large buffers <font color="#000080">(</font>SetTextBuf <font color="#FF0000"><b>Procedure</b></font><font color="#000080">)
   </font>b<font color="#000080">. </font>establish an Index <font color="#FF0000"><b>For </b></font>the Records <font color="#FF0000"><b>on </b></font>the <font color="#FF0000"><b>File</b></font><font color="#000080">, </font><font color="#FF0000"><b>and </b></font>use random i<font color="#000080">/</font>o <font color="#FF0000"><b>to
</b></font>access specific Records<font color="#000080">.  </font>Thgis does <font color="#FF0000"><b>not </b></font>imply reading all the Records each
time you <font color="#000080">&quot;</font>search it<font color="#000080">&quot;, </font>but you must have some <font color="#000080">&quot;</font>key<font color="#000080">&quot; </font><font color="#FF0000"><b>or </b></font>order <font color="#FF0000"><b>in </b></font>that <font color="#FF0000"><b>File </b></font>from
which you can assign <font color="#FF0000"><b>and </b></font>index key<font color="#000080">.  </font>This <font color="#FF0000"><b>is </b></font>a large subject<font color="#000080">, </font><font color="#FF0000"><b>and to </b></font>go
further<font color="#000080">, </font>I<font color="#800000">'d have to know more about your File.
   </font>c<font color="#000080">. </font>have the <font color="#FF0000"><b>File </b></font><font color="#000080">(</font>be <font color="#FF0000"><b>of</b></font><font color="#000080">) </font>fixed Records<font color="#000080">, </font>sort <font color="#FF0000"><b>on </b></font>some key field<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>use a
binary search<font color="#000080">/</font>random read scheme <font color="#FF0000"><b>to </b></font>search <font color="#FF0000"><b>For </b></font>Records<font color="#000080">.  </font>Also pretty
Complicated <font color="#FF0000"><b>in Implementation</b></font><font color="#000080">...
  </font><font color="#800000">2. </font>Random Files<font color="#000080">:
    </font>There are many options here<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>are mostly dependant <font color="#FF0000"><b>on </b></font>the <font color="#FF0000"><b>File </b></font>order <font color="#FF0000"><b>and
</b></font>data content<font color="#000080">/</font><font color="#FF0000"><b>Record </b></font>size<font color="#000080">.

   </font><font color="#FF0000"><b>Finally</b></font><font color="#000080">,  </font>suggest you read the entire <font color="#FF0000"><b>File </b></font>into memory <font color="#000080">(</font>using Heap<font color="#000080">, </font>Pointer
access<font color="#000080">, </font>etc<font color="#000080">.), </font><font color="#FF0000"><b>and do </b></font>all your work <font color="#FF0000"><b>in </b></font>memory<font color="#000080">.  </font>The above ideas are appropriate
<font color="#FF0000"><b>For </b></font>very large Files<font color="#000080">, </font>but anything under <font color="#800000">450</font>K can be stored <font color="#FF0000"><b>in </b></font>you system
memory <font color="#FF0000"><b>and </b></font>used there<font color="#000080">, </font>I<font color="#800000">'ll bet.  Once in memory, you can even sort the data in
</font>some fashion <font color="#FF0000"><b>and </b></font>use some fancy searching techniques<font color="#000080">, </font>too<font color="#000080">.




</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to RECORDS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0004.PAS">Original</a><b>]</b></p></body>
</html>
