<html>
<head><title> "Keyboard Latency as a Random Number" by JIM ROBB</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0063.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt; Bruce Schneier suggests keyboard latency as a good source of randomness.
&gt; I suspect you'd find the delays far more regular than you'd guess, but
&gt; it's worth looking at.  Show us an implementation!

Thanks, DJ.  (And I was hoping a simple appeal to a recognized authority
would suffice!  I guess I should have known better.)  But fair enough -
here's an admittedly crude implementation:
}

</i></font><font color="#FF0000"><b>program </b></font>TestKey<font color="#000080">;

</font><font color="#008000"><i>{ Test keyboard latency as a potential source of random numbers. }
{ NOTE - NO ERROR CHECKING!                                      }

</i></font><font color="#FF0000"><b>uses
  </b></font>Dos<font color="#000080">, </font>Crt<font color="#000080">;

</font><font color="#FF0000"><b>const
  </b></font>FileName <font color="#000080">= </font><font color="#800000">'RANDOM.TST'</font><font color="#000080">;

</font><font color="#FF0000"><b>var
  </b></font>PrevTime <font color="#000080">: </font>Word<font color="#000080">;
  </font>RandByte <font color="#000080">: </font>Byte<font color="#000080">;
  </font>Regs     <font color="#000080">: </font>Registers<font color="#000080">;
  </font>Bit      <font color="#000080">: </font>Word<font color="#000080">;
  </font>RandFile <font color="#000080">: </font><font color="#FF0000"><b>file of </b></font>Byte<font color="#000080">;
  </font>Ch       <font color="#000080">: </font>Char<font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font><font color="#008000"><i>{ open the file }
  </i></font>Assign<font color="#000080">( </font>RandFile<font color="#000080">, </font>FileName <font color="#000080">);
  </font>Rewrite<font color="#000080">( </font>RandFile <font color="#000080">);

  </font><font color="#008000"><i>{ get DOS time and save low word }
  </i></font>Regs<font color="#000080">.</font>AH <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font>Intr<font color="#000080">( </font><font color="#800000">$1A</font><font color="#000080">, </font>Regs <font color="#000080">);
  </font>PrevTime <font color="#000080">:= </font>Regs<font color="#000080">.</font>DX<font color="#000080">;

  </font>Bit <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font>RandByte <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font>WriteLn<font color="#000080">( </font><font color="#800000">'Start typing now.  Press &lt;ESC&gt; to quit.' </font><font color="#000080">);

  </font><font color="#FF0000"><b>repeat
    </b></font><font color="#008000"><i>{ get a keystroke }
    </i></font><font color="#FF0000"><b>repeat until </b></font>KeyPressed<font color="#000080">;
    </font>Ch <font color="#000080">:= </font>ReadKey<font color="#000080">;

    </font><font color="#008000"><i>{ if the Escape key }
    </i></font><font color="#FF0000"><b>if </b></font>Ch <font color="#000080">= </font><font color="#800000">#27 </font><font color="#FF0000"><b>then
      </b></font>Break<font color="#000080">;

    </font><font color="#008000"><i>{ get DOS time }
    </i></font>Regs<font color="#000080">.</font>AH <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
    </font>Intr<font color="#000080">( </font><font color="#800000">$1A</font><font color="#000080">, </font>Regs <font color="#000080">);

    </font><font color="#008000"><i>{ calculate the time difference, isolate the low-order bit, and }
    { use it to build the hopefully-random byte in progress.        }
    </i></font>RandByte <font color="#000080">:= </font>RandByte <font color="#000080">+ ( ( </font>Lo<font color="#000080">( </font>Regs<font color="#000080">.</font>DX <font color="#000080">- </font>PrevTime <font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#800000">1 </font><font color="#000080">) </font><font color="#FF0000"><b>shl </b></font>Bit <font color="#000080">);
    </font>PrevTime <font color="#000080">:= </font>Regs<font color="#000080">.</font>DX<font color="#000080">;
    </font>Inc<font color="#000080">( </font>Bit <font color="#000080">);

    </font><font color="#008000"><i>{ If we have a full byte, write it to the file and start over }
    </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">( </font>Bit <font color="#000080">&gt; </font><font color="#800000">7 </font><font color="#000080">) </font><font color="#FF0000"><b>then begin
      </b></font>Write<font color="#000080">( </font>RandFile<font color="#000080">, </font>RandByte <font color="#000080">);
      </font>RandByte <font color="#000080">:= </font><font color="#800000">0
      </font>Bit <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

    </font><font color="#008000"><i>{ Ignore special keys, display the rest }
    </i></font><font color="#FF0000"><b>if </b></font>Ch <font color="#000080">= </font><font color="#800000">#0 </font><font color="#FF0000"><b>then
      </b></font>Ch <font color="#000080">:= </font>ReadKey
    <font color="#FF0000"><b>else
      </b></font>Write<font color="#000080">( </font>Ch <font color="#000080">);
    </font><font color="#FF0000"><b>if </b></font>Ch <font color="#000080">= </font><font color="#800000">#13 </font><font color="#FF0000"><b>then
      </b></font>Write<font color="#000080">( </font><font color="#800000">#10 </font><font color="#000080">)

  </font><font color="#FF0000"><b>until </b></font>False<font color="#000080">;
  </font>Close<font color="#000080">( </font>RandFile <font color="#000080">)
</font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font><font color="#008000"><i>{
I ran this thing and typed in the first page of a DOC file.  This is what I
got:

  24  98  AD  94  E2  C8  00  58  20  83  09  F1  5D  F5  76  59
  31  A9  86  DC  32  6D  96  17  65  C4  75  31  A3  18  F5  97
  87  0A  69  B4  B6  E7  0A  C1  F8  09  BE  B0  7B  C5  4A  BA
  69  42  8C  D4  E4  71  12  DF  5E  19  5C  A0  0D  79  D7  F1
  66  BC  40  36  E9  8D  DB  B5  37  A9  7A  0C  02  90  05  04
  EA  53  38  CA  94  18  92  8A  46  A6  F1  56  D0  E7  38  97
  25  2D  C3  C8  7E  79  DE  02  58  FC  36  7E  BC  3C  F9  6D
  E6  2E  C0  28  06  AD  C1  4B  55  CD  C4  98  DD  08  DD  4E
  11  56  76  83  BC  7A  AF  05  F6  AC  C3  40  28  D5  2B  8E
  C1  93  B5  F9  54  E2  00  3D  5A  5D  37  36  C3  5F  37  3A
  AB  60  36  72  27  26  21  86  2F  B4  6B  D9  70  94  DE  00
  C8  23  34  5F  83  C9  FB  AF  F8  F5  CE  21  B3  40  FA  ED
  21  4B  65  00  D9  A0  6E  43  E4  FF  66  1B  BC  17  80  29
  FD  6F  10  4B  D7  D3  ED  5C  C9  18  0E  24  89  1F  03  BC
  B3  0B  CB  E5  1E  16  B8  DA  99  EC  93  84  7E  8A  FE  61
  9D  B7  2E  30  11  7F  0A  C6  83  C2  C1  97  3B  08  61  8D
  7B  5E  7E  69  99  F8  F3  36  BA  31  6E  41  60  8C  DC  B7
  48  FB  44  A2  78  D5  AF  88  D9  10  50  E7  C7  BE  68  41
  C2  E8  D8  1B

The distribution of bytes looks like this:

         0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
     +-----------------------------------------------------------------
 0   |   4   0   2   1   1   2   1   0   2   2   3   1   1   1   1   0
 1   |   2   2   1   0   0   0   1   2   3   1   0   2   0   0   1   1
 2   |   1   3   0   1   2   1   1   1   2   1   0   1   0   1   2   1
 3   |   1   3   1   0   1   0   5   3   2   0   1   1   1   1   0   0
 4   |   3   2   1   1   1   0   1   0   1   0   1   3   0   0   1   0
 5   |   1   0   0   1   1   1   2   0   2   1   1   0   2   2   2   2
 6   |   2   2   0   0   0   2   2   0   1   3   0   1   0   2   2   1
 7   |   1   1   1   0   0   1   2   0   1   2   2   2   0   0   4   1
 8   |   1   0   0   4   1   0   2   1   1   1   2   0   2   2   1   0
 9   |   1   0   1   2   3   0   1   3   2   2   0   0   0   1   0   0
 A   |   2   0   1   1   0   0   1   0   0   2   0   1   1   2   0   3
 B   |   1   0   0   2   2   2   1   2   1   0   2   0   5   0   2   0
 C   |   1   4   2   3   2   1   1   1   3   2   1   1   0   1   1   0
 D   |   1   0   0   1   1   2   0   2   1   3   1   1   2   2   2   1
 E   |   0   0   2   0   2   1   1   3   1   1   1   0   1   2   0   0
 F   |   0   3   0   1   0   3   1   0   3   2   1   2   1   1   1   1


Question - is it random?  Well, it's far too small a sample to be sure, and I
wasn't about to retype &quot;War and Peace&quot; to get a bigger sample.  It passes
one test of randomness - non-compressability.  LHA won't compress it, anyway.
(A text file of similar size compressed to 64%.)  I don't consider this
definite proof of randomness, although it looks hopeful.

Question - is it unpredictable?  Given the above source code and the list of
bytes generated, I don't think I could predict what the next byte would be.

Question - can it be reliably reproduced?  Not at my level of typing ability,
unless I cheat and just hold down a key.  Even then, there are minor
variations between bytes.

Problem - the timer is too coarse.  It uses the BIOS time-of-day count, which
ticks over about 18.2 times per second.  For a 30-wpm (3 character-per-second)
typist like me, it _seems_ to produce acceptable results.  For a professional
typist, churning out 110 wpm (11 characters per second), it probably won't.
Something using the 8253 timer (a modification of the Abrash &quot;Zen Timer&quot;, for
example) would probably be adequate for even the fastest typist, but that's a
bit too exotic for me to attempt.

Problem - it takes a lot of typing to generate a decent pad.  By my
calculations, a 110-wpm typist would have to type for 20 minutes to create a
pad big enough to encrypt one double-spaced typewritten page.  Possible
solution - rewrite the thing as a TSR, so that a typist can do useful work
while generating random (?) numbers in the background.  Then, turn the whole
typing pool loose on the problem.

Does anyone have a better timer routine and a faster typist?
}
</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0063.PAS">Original</a><b>]</b></p></body>
</html>
