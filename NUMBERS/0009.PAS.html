<html>
<head><title> "BYTEINFO.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0009.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt;Also, how would I simply read each bit?
}
{ Test if a bit is set. }
</i></font><font color="#FF0000"><b>Function </b></font>IsBitSet<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>INByte <font color="#000080">: </font>Byte<font color="#000080">; </font>Bit2Test <font color="#000080">: </font>Byte<font color="#000080">) : </font>Boolean<font color="#000080">;
</font><font color="#FF0000"><b>begin
  if </b></font><font color="#000080">(</font>Bit2Test <font color="#FF0000"><b>in </b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">7</font><font color="#000080">]) </font><font color="#FF0000"><b>then
    </b></font>IsBitSet <font color="#000080">:= ((</font>INByte <font color="#FF0000"><b>and </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>Bit2Test<font color="#000080">)) &lt;&gt; </font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>else
    </b></font>Writeln<font color="#000080">(</font><font color="#800000">'ERROR! Bit to check is out of range!'</font><font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ IsBitSet. }

{
&gt;How on earth can I manipulate an individual bit?

...One method is to use the bit-operators:  AND, OR, XOR, NOT
}

{ Manipulate an individual BIT within a single Byte. }
</i></font><font color="#FF0000"><b>Procedure </b></font>SetBit<font color="#000080">(</font>Bit2Change <font color="#000080">: </font>Byte<font color="#000080">; </font>TurnOn <font color="#000080">: </font>Boolean<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>INByte <font color="#000080">: </font>Byte<font color="#000080">);
</font><font color="#FF0000"><b>begin
  if </b></font>Bit2Change <font color="#FF0000"><b>in </b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">7</font><font color="#000080">] </font><font color="#FF0000"><b>then
  begin
    if </b></font>TurnOn <font color="#FF0000"><b>then
      </b></font>INByte <font color="#000080">:= </font>INByte <font color="#FF0000"><b>or </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>Bit2Change<font color="#000080">)
    </font><font color="#FF0000"><b>else
      </b></font>INByte <font color="#000080">:= </font>INByte <font color="#FF0000"><b>and NOT</b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>Bit2Change<font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
</font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ SetBit. }

{
&gt;...but I'm not sure exactly what the shifting is doing.
}

    { Check if the bit is to be turned on or off. }
    </i></font><font color="#FF0000"><b>If </b></font>TurnOn <font color="#FF0000"><b>then

    </b></font><font color="#008000"><i>{
      SHL 1 (which has a bit map of 0000 0001) to the bit
      position we want to turn-on.

        ie: 1 SHL 4 = bit-map of 0001 0000

      ...Then use a &quot;logical OR&quot; to set this bit.

      ie: Decimal:     2      or      16     =    18
          Binary : 0000 0010  or  0001 0000  = 0001 0010
    }

      </i></font>INByte <font color="#000080">:= </font>INByte <font color="#FF0000"><b>or </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>Bit2Change<font color="#000080">)
    </font><font color="#FF0000"><b>else

    </b></font><font color="#008000"><i>{
      Else turn-off bit.

      SHL 1 (which has a bit map of 0000 0001) to the bit
      position we want to turn-off.

         ie: 1 SHL 4 = bit-map of 0001 0000

       ...Then use a &quot;logical NOT&quot; to flip all the bits.

       ie: Decimal:  not (   16    ) =      239
           Binary :  not (0001 0000) =  (1110 1111)

       ...Than use a &quot;logical AND&quot; to turn-off the bit.

       ie: Decimal:     255     and     239    = 239
           Binary :  1111 1111  and  1110 1111 = 1110 1111
    }

     </i></font>INByte <font color="#000080">:= </font>INByte <font color="#FF0000"><b>and NOT</b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>Bit2Change<font color="#000080">);

</font><font color="#008000"><i>{
&gt;Also, how can you assign a Byte (InByte) a Boolean value (OR/AND/NOT)

  or / xor / and / not are &quot;logical&quot; bit operators, that can be use on
  &quot;scalar&quot; Types. (They also Function in the same manner For &quot;Boolean&quot;
  logic.)

&gt;If I have, say 16 bits in one Byte, the interrupt list says that for
&gt;instance the BIOS calls (INT 11), AX is returned With the values. It
&gt;says that the bits from 9-11 tell how many serial portss there are.
&gt;How do I read 3 bits?

  To modify the two routines I posted wo work With 16 bit Variables,
  you'll need to change:

     INByte : Byte;  ---&gt;  INWord : Word;

  ...Also:

     in [0..7]  ---&gt;  in [0..15]

  ...If you don't want to use the IsBitSet Function listed above
  (modified to accept 16-bit Word values) you could do the following
  to check if bits  9, 10, 11 are set in a 16-bit value:

  The following is the correct code For reading bits 9, 10, 11
  of the 16-bit Variable &quot;AX_Value&quot; :

      Port_Count :=  ((AX_Value and $E00) SHR 9);

    NOTE: Bit-map For $E00 = 0000 1110 0000 0000

  ...If you've got a copy of Tom Swan's &quot;Mastering Turbo Pascal&quot;,
  check the section on &quot;logical operators&quot;.


{
&gt;Var Regs : Registers;
&gt;begin
&gt;  Intr($11,Regs);
&gt;  Writeln(Regs.AX);
&gt;end.

&gt;How do I manipulate that to read each bit (or multiple bits like
&gt;the number of serial ports installed (bits 9-11) ?
}

</i></font><font color="#FF0000"><b>Uses
  </b></font>Dos<font color="#000080">;

</font><font color="#FF0000"><b>Var
  </b></font>Port_Count <font color="#000080">: </font>Byte<font color="#000080">;
  </font>Regs       <font color="#000080">: </font>Registers<font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font>Intr<font color="#000080">(</font><font color="#800000">$11</font><font color="#000080">, </font>Regs<font color="#000080">);
  </font>Port_Count <font color="#000080">:= ((</font>Regs<font color="#000080">.</font>AX <font color="#FF0000"><b>and </b></font><font color="#800000">$E00</font><font color="#000080">) </font><font color="#FF0000"><b>SHR </b></font><font color="#800000">9</font><font color="#000080">);
  </font>Writeln<font color="#000080">(</font><font color="#800000">'Number of serial-ports = '</font><font color="#000080">, </font>Port_Count<font color="#000080">)
</font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font><font color="#008000"><i>{
NOTE: The hex value of $E00 is equivalent to a 16-bit value with
      only bits 9, 10, 11 set to a binary 1. The SHR 9 shifts the
      top Byte of the 16-bit value, to the lower Byte position.
}
{
&gt;Is $E00 the same as $0E00 (ie, can you just omit leading zeros)?

Yeah, it's up to you if you want to use the leading zeros or not.

The SHR 9 comes in because once the value has been &quot;AND'd&quot; with
$E00, the 3 bits (9, 10, 11) must be placed at bit positions:
0, 1, 2  ...to correctly read their value.

For example, say bits 9 and 11 were set, but not bit 10. If we
&quot;AND&quot; this With $E00, the result is $A00.

1011 1010 0111 1110  and  0000 1110 0000 0000  =  0000 1010 0000 0000
       ^ ^
(bits 9,11 are set)  and  (      $E00       )  =  $A00
...Taking the result of $A00, and shifting it right 9 bit positions

         $A00         SHR 9  =           5

 0000 1010 0000 0000  SHR 9  =  0000 0000 0000 0101

...Which evalutates to 5. (ie: 5 serial ports)
}









{
Get Equipment Bit-Map
---------------------

         AH       AL
      76543210 76543210
AX =  ppxgrrrx ffvvmmci

...
...
rrr = # of RS232 ports installed
...
...

 (* reports the number of RS232 ports installed *)
Function NumRS232 : Byte;
Var Regs : Registers;                 (* Uses Dos *)
begin
  Intr($11,Regs);
  NumRS232 := (AH and $0E) shr 1;
end;


...When you call Int $11, it will return the number of RS232 ports installed
in bits 1-3 in register AH.

For example if AH = 01001110 , you can mask out the bits you *don't* want
by using AND, like this:

              01001110      &lt;---  AH
        and   00001110      &lt;---- mask $0E
        &Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;
              00001110      &lt;---- after masking


Then shift the bits to the right With SHR,

              00001110      &lt;---- after masking
         SHR         1      &lt;---- shift-right one bit position
         &Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;
              00000111      &lt;---- result you want
}

{
-&gt; How do I know to use $4 For the third bit?  Suppose I want to read
-&gt; the fifth bit. Do I simply use b := b or $6?

    Binary is a number system just like decimal.  Let me explain.
First, consider the number &quot;123&quot; in decimal.  What this means,
literally, is

1*(10^2) + 2*(10^1) + 3*(10^0), which is 100 + 20 + 3.

    Binary works just the same, however instead of a 10, a 2 is used as
the base.  So the number &quot;1011&quot; means

1*(2^3) + 0*(2^2) + 1*(2^1) + 1*(2^0), or 8+0+2+1, or 11.

     This should make it clear why if you wish to set the nth bit to
True, you simply use a number equal to 2^(n-1).  (The -1 is there
because you probably count from 1, whereas the powers of two, as you may
note, start at 0.)

-&gt; b or (1 SHL 2) Would mean that b := 1 (True) if b is already equal to
-&gt; one (1) and/OR the bit two (2) to the left is one (1) ???

    Aha.  You are not familiar With bitwise or operations.  When one
attempts to or two non-Boolean values (Integers), instead of doing a
logical or as you are familiar with, each individual BIT is or'd.  I.E.
imagine a Variables A and B had the following values:

a := 1100 (binary);
b := 1010 (binary);

then, a or b would be equal to 1110 (binary);  Notice that each bit of a
has been or'd With the corresponding bit of b?  The same goes For and.
Here's an example.

a := 1100 (binary);
b := 1010 (binary);

a and b would be equal to 1000;

I hope this clears up the confusion.  And just to be sure, I'm going to
briefly show a SHL and SHR operation to make sure you know.  Consider
the number

a := 10100 (binary);

This being the number, A SHL 2 would be equal to 1010000 (binary) --
notice that it has been &quot;shifted to the left&quot; by 2 bits.

A SHR 1 would be 1010 (binary), which is a shifted to the right by 2
bits.
}

</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0009.PAS">Original</a><b>]</b></p></body>
</html>
