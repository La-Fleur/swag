<html>
<head><title> "Binary and Hexidecimal" by DAVID DUNSON</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0049.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
I've seen requests for these two procedures several times, and finally got
around to writing them in ASM.

{ ------- CUT HERE ------- }

(* Hex converts a number (num) to Hexadecimal.                      *)
(*    num  is the number to convert                                 *)
(*    nib  is the number of Hexadecimal digits to return            *)
(* Example: Hex(31, 4) returns '001F'                               *)

</i></font><font color="#FF0000"><b>Function </b></font>Hex<font color="#000080">(</font>num<font color="#000080">: </font>Word<font color="#000080">; </font>nib<font color="#000080">: </font>Byte<font color="#000080">): </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>ASM
      </b></font><font color="#FF00FF">PUSHF
      LES  DI, @Result
      XOR  CH, CH
      MOV  CL, nib
      MOV  ES:[DI], CL
      JCXZ @@3
      ADD  DI, CX
      MOV  BX, num
      STD
@@1:  MOV  AL, BL
      AND  AL, $0F
      OR   AL, $30
      CMP  AL, $3A
      JB   @@2
      ADD  AL, $07
@@2:  STOSB
      SHR  BX, 1
      SHR  BX, 1
      SHR  BX, 1
      SHR  BX, 1
      LOOP @@1
@@3:  POPF
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;


</font><font color="#008000"><i>(* Binary converts a number (num) to Binary.                        *)
(*    num  is the number to convert                                 *)
(*    bits is the number of Binary digits to return                 *)
(* Example: Binary(31, 16) returns '0000000000011111'               *)

</i></font><font color="#FF0000"><b>Function </b></font>Binary<font color="#000080">(</font>num<font color="#000080">: </font>Word<font color="#000080">; </font>bits<font color="#000080">: </font>Byte<font color="#000080">): </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>ASM
      </b></font><font color="#FF00FF">PUSHF
      LES  DI, @Result
      XOR  CH, CH
      MOV  CL, bits
      MOV  ES:[DI], CL
      JCXZ @@3
      ADD  DI, CX
      MOV  BX, num
      STD
@@1:  MOV  AL, BL
      AND  AL, $01
      OR   AL, $30
      STOSB
      SHR  BX, 1
      LOOP @@1
@@3:  POPF
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;

</font><font color="#008000"><i>{ ------- CUT HERE ------- }

</i></font>These procedures are fully optomized <font color="#FF0000"><b>to </b></font>my knowledge <font color="#FF0000"><b>and </b></font>have been tested
against normal <font color="#FF0000"><b>Pascal </b></font>routines that perform the same functions<font color="#000080">.  </font>Test results
returned that Hex performed aprox<font color="#000080">. </font><font color="#800000">2.14 </font>times faster than it<font color="#800000">'s Pascal
</font>equivilent<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>Binary performed aprox<font color="#000080">. </font><font color="#800000">14 </font>times faster than it<font color="#800000">'s Pascal
</font>equivilent<font color="#000080">.

</font>Enjoy<font color="#000080">!
</font>David

</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to NUMBERS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0049.PAS">Original</a><b>]</b></p></body>
</html>
