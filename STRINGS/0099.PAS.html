<html>
<head><title> "Boolean String Search" by BRUCE J. LACKORE</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to STRINGS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0099.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#FF0000"><b>Unit </b></font>BoolPos<font color="#000080">;
</font><font color="#008000"><i>{$Define Test}
{        Once debugging is complete, remove the above line to turn off debug mode. }

{        Version 1.3.5.P.

        Requires Borland Turbo Pascal version 6.0 or later to compile.

        Author:  Bruce J. Lackore.  Created Friday, July 23, 1993.
        Copyright (c) 1993 Bruce J. Lackore.  ALL RIGHTS RESERVED.
}

{$IFDEF Test}
        {$A+,B-,D+,F-,G-,I+,L+,O-,R+,S+,V-,X+}
{$ELSE}
        {$A+,B-,D-,F-,G-,I-,L-,O-,R-,S-,V-,X+}
{$ENDIF}

{        This unit comprises a function capable of searching a string for multiple
        occurences of substrings using Boolean operators.  In the search string,
        Boolean operators And and Or are defined as follows:

                &amp; - And
                | - Or

        Parentheses are supported for doing multiple searches.  Search strings are
        submitted as follows:

                i.e. In the source string &quot;The quick brown fox jumped over the lazy dog&quot;
                                        and the search is for the word blue and the words quick or fox,
                                        the search string is entered as follows:

                                                (blue&amp;(quick|fox))

        The way the function is currently written, And (&amp;) and Or (|) have the same
        precedence level hence the above search string without parentheses would be
        interpretted to be (blue&amp;quick|fox):

                blue And quick would be searched for first, the result Or'd with the
                results of the search for fox.

        Notice the difference in that (blue&amp;(quick|fox)) is a False statement whilst
        (blue&amp;quick|fox) is True.

        The function will automatically scan for () pairs, adding the necessary )
        at the end of the search string or ( at the beginning if required.

        The function will also search for (|, |), (&amp; and &amp;) symbols, these being
        illegal.

        It should also be noted that although excess parens will not cause the
        function to fail, they DO cause the function to loop unnecessarily through
        the token search (once for each set of parens) while bringing the final
        answer out of the final set of parens.

}

{        Bug fixes:

                07/04/1994: Thought the 06/01 fix did the job.  It didn't.  This time,
                                                                I went back into the token processor and found that it was
                                                                missing a left paren when the tokenized search string was in
                                                                the form of (b@b...)@(b@b...) where b is a boolean designator
                                                                (T or F) and @ is a boolean operator (| or &amp;).  Thanx to
                                                                Michael Jarmulowicz for pointing this out.
                                                                The fix was to go into the Process_token_str function and
                                                                ensure that a multi-pass required token string has sufficient
                                                                parens so as to not confuse the token processor.
                                                                Also defined BPos return value should the Fixup_srch_str
                                                                function fail.  The default is False (as set in the first
                                                                line of the BPos function itself) and is triggered by
                                                                Fixup_srch_str returning a null string.  Removed the &quot;fix&quot;
                                                                that was suggested in the 06/01 bug fix and replaced it with
                                                                code that scans the first and last letters of the Srch_str
                                                                to ensure that they are parens, if not, add a pair.

                06/01/1994: After returning from WestPac, I received a couple of emails
                                                                telling me that if the function was called with NO
                                                                parentheses, it would fail.  The fix is simply to add a set of
                                                                parens in the Fixup_srch_str function just before the
                                                                function returns if the first character of the Srch_str is NOT
                                                                a left paren equivalent.  I have had one report of the unit
                                                                not working in protected mode.  As I don't yet know much about
                                                                protected mode programming, I am still working on that
                                                                particular bug but I WILL fix it if the error is in here.  I
                                                                also tightened up one of the assembly replacement functions,
                                                                see the docs for the change.

                10/04/1993:        Noticed that length of Src_str in function Next_CPos was
                                                                incorrectly calculated because of positioning of INC DI.
                                                                INC DI precedes the MOV CL,[ES:DI] causing the function to
                                                                consider the first character of Src_str to represent the
                                                                length rather than the actual length byte.  Fix is to move
                                                                the INC DI to the line following the MOV CL,[ES:DI].

}

</i></font><font color="#FF0000"><b>Interface

Function </b></font>BPos<font color="#000080">(</font>Srch_str<font color="#000080">, </font>Src_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;  </font>Ignore_case<font color="#000080">:  </font>Boolean<font color="#000080">):  </font>Boolean<font color="#000080">;

</font><font color="#008000"><i>{        This function accepts a source string and a search string as described above
        and returns a Boolean value based on whether or not the parsed search
        string was found.
}

{ ************************************************************************** }

</i></font><font color="#FF0000"><b>Implementation

Const
        </b></font>Lt_pn<font color="#000080">:                                                                                </font>Char <font color="#000080">= </font><font color="#800000">'('</font><font color="#000080">;
        </font>Rt_pn<font color="#000080">:                                                                                </font>Char <font color="#000080">= </font><font color="#800000">')'</font><font color="#000080">;

</font><font color="#FF0000"><b>Function </b></font>Cnt_ch<font color="#000080">(</font>Scan_char<font color="#000080">:  </font>Char<font color="#000080">;  </font>In_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font>Byte<font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function will scan a string for occurences of a particular character.
        The function will return the number of occurences.
}

        </i></font><font color="#FF0000"><b>Asm  </b></font><font color="#008000"><i>{ Function Cnt_ch }
                                                        </i></font><font color="#FF00FF">XOR                AX,AX                                        </font><font color="#008000"><i>{        0 AX }
                                                        </i></font><font color="#FF00FF">MOV                BL,Scan_char  </font><font color="#008000"><i>{        Put char to count in BL }
                                                        </i></font><font color="#FF00FF">LES                SI,In_str     </font><font color="#008000"><i>{        Set ES:SI to point to start of string }
                                                        </i></font><font color="#FF00FF">XOR                CX,CX         </font><font color="#008000"><i>{        0 CX }
                                                        </i></font><font color="#FF00FF">MOV                CL,[ES:SI]    </font><font color="#008000"><i>{        Move string length to CX }
                                                        </i></font><font color="#FF00FF">ADD                SI,CX         </font><font color="#008000"><i>{        Set ES:SI to point to END of string }
                </i></font><font color="#FF00FF">@LOOK:                CMP                BL,[ES:SI]    </font><font color="#008000"><i>{        Start Loop, compare current char and BL }
                                                        </i></font><font color="#FF00FF">JNE                @NEXT         </font><font color="#008000"><i>{        If not equal, jump to end of loop }
                                                        </i></font><font color="#FF00FF">INC                AX            </font><font color="#008000"><i>{ If equal, Inc char cnt (AX) }
                </i></font><font color="#FF00FF">@NEXT:                DEC                SI            </font><font color="#008000"><i>{        Set ES:SI back one character }
                                                        </i></font><font color="#FF00FF">LOOP        @LOOK         </font><font color="#008000"><i>{        Decrement CX and jump to start of loop }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Cnt_ch }

</i></font><font color="#FF0000"><b>Function </b></font>Fill_str<font color="#000080">(</font>Dupe_ch<font color="#000080">:  </font>Char<font color="#000080">;  </font>How_many<font color="#000080">:  </font>Byte<font color="#000080">):  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function returns How_many of Dupe_char.
}

        </i></font><font color="#FF0000"><b>Asm  </b></font><font color="#008000"><i>{ Function Fill_str }
                                                        </i></font><font color="#FF00FF">LES                DI, @Result                </font><font color="#008000"><i>{        Set ES:DI to function result area }
                                                        </i></font><font color="#FF00FF">CLD                 </font><font color="#008000"><i>{        Clear direction flag }
                                                        </i></font><font color="#FF00FF">XOR         CH,CH         </font><font color="#008000"><i>{        0 CH }
                                                        </i></font><font color="#FF00FF">MOV         CL,How_many          </font><font color="#008000"><i>{ Length in CX }
                                                        </i></font><font color="#FF00FF">MOV         AX,CX                </font><font color="#008000"><i>{ and in AX }
                                                        </i></font><font color="#FF00FF">STOSB                     </font><font color="#008000"><i>{ Store length byte }
                                                        </i></font><font color="#FF00FF">MOV         AL,Dupe_ch    </font><font color="#008000"><i>{        Put char to dupe in AL }
                                                        </i></font><font color="#FF00FF">REP         STOSB         </font><font color="#008000"><i>{ Fill string with char }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Fill_str }

</i></font><font color="#FF0000"><b>Function </b></font>PosC<font color="#000080">(</font>Srch_ch<font color="#000080">:  </font>Char<font color="#000080">;  </font>Src_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font>Boolean<font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function is similar to the Pos function of Pascal except that it
        accepts only a single character to search for.  This function returns a
        True if a Srch_ch is encountered, a False if not.
}

        </i></font><font color="#FF0000"><b>Asm  </b></font><font color="#008000"><i>{ Function PosC }
                                                        </i></font><font color="#FF00FF">XOR                BX,BX                                        </font><font color="#008000"><i>{        0 BX }
                                                        </i></font><font color="#FF00FF">MOV                AL,Srch_ch    </font><font color="#008000"><i>{        Put char to look for in AL }
                                                        </i></font><font color="#FF00FF">LES                DI,Src_str    </font><font color="#008000"><i>{        Set ES:DI to start of Src_str }
                                                        </i></font><font color="#FF00FF">XOR                CX,CX         </font><font color="#008000"><i>{        0 CX }
                                                        </i></font><font color="#FF00FF">MOV                CL,[ES:DI]    </font><font color="#008000"><i>{        Store length of Src_str in CL }
                                                        </i></font><font color="#FF00FF">ADD                DI,CX         </font><font color="#008000"><i>{        Set ES:DI to end of string }
                                                        </i></font><font color="#FF00FF">STD                 </font><font color="#008000"><i>{        Set direction flag }
                </i></font><font color="#FF00FF">@LOOK:                REPNZ        SCASB         </font><font color="#008000"><i>{        Look for AL in Src_str }
                                                        </i></font><font color="#FF00FF">JNZ                @DONE         </font><font color="#008000"><i>{        If not found, jump to end (BX = 0) }
                                                        </i></font><font color="#FF00FF">INC                BX            </font><font color="#008000"><i>{        If Found, Inc Bx  to 1 = Pascal True }
                </i></font><font color="#FF00FF">@DONE:                MOV                AX,BX         </font><font color="#008000"><i>{        Move BX to AX (return result) }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function PosC }

</i></font><font color="#FF0000"><b>Function </b></font>Last_Cpos<font color="#000080">(</font>Srch_ch<font color="#000080">:  </font>Char<font color="#000080">;  </font>Src_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font>Byte<font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function performs the same function as the Pascal POS function except
        that it works only with a single character and rather than returning the
        first position the character is found in, it returns the LAST position that
        the search character is found in.
}

        </i></font><font color="#FF0000"><b>Asm </b></font><font color="#008000"><i>{ Function Last_Cpos }
                                                        </i></font><font color="#FF00FF">MOV                AL,Srch_ch                </font><font color="#008000"><i>{        Put char to look for in AL }
                                                        </i></font><font color="#FF00FF">LES                DI,Src_str    </font><font color="#008000"><i>{        Set ES:DI to start of Src_str }
                                                        </i></font><font color="#FF00FF">XOR                CX,CX         </font><font color="#008000"><i>{        0 CX }
                                                        </i></font><font color="#FF00FF">MOV                CL,[ES:DI]    </font><font color="#008000"><i>{        Move length of Src_str to CL }
                                                        </i></font><font color="#FF00FF">ADD                DI,CX         </font><font color="#008000"><i>{        Set ES:DI to end of Src_str }
                                                        </i></font><font color="#FF00FF">INC                CX            </font><font color="#008000"><i>{ Add one to CX (correct for string length }
                                                        </i></font><font color="#FF00FF">STD                 </font><font color="#008000"><i>{        Set direction flag }
                                                        </i></font><font color="#FF00FF">REPNZ        SCASB         </font><font color="#008000"><i>{        Look for character in string }
                                                        </i></font><font color="#FF00FF">MOV                AX,CX         </font><font color="#008000"><i>{ If found CX indicates position, else 0 }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Last_Cpos }

</i></font><font color="#FF0000"><b>Function </b></font>Next_CPos
        <font color="#000080">(</font>Srch_ch<font color="#000080">:  </font>Char<font color="#000080">;  </font>Src_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;  </font>Strt_at<font color="#000080">:  </font>Byte<font color="#000080">):  </font>Byte<font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function searches for the next occurence of Srch_ch in Src_str AFTER
        position Strt_at.  The function returns the offset from the beginning of
        the string, NOT the offset from Strt_at.
}

        </i></font><font color="#FF0000"><b>Asm  </b></font><font color="#008000"><i>{ Function Next_CPos }
                                                        </i></font><font color="#FF00FF">XOR                AX,AX         </font><font color="#008000"><i>{        0 AX }
                                                        </i></font><font color="#FF00FF">MOV                AL,Strt_at    </font><font color="#008000"><i>{        Move position to start at to AL }
                                                        </i></font><font color="#FF00FF">LES                DI,Src_str    </font><font color="#008000"><i>{        Set ES:DI to start of Src_str }
                                                        </i></font><font color="#FF00FF">XOR                CX,CX         </font><font color="#008000"><i>{        0 CX }
                                                        </i></font><font color="#FF00FF">MOV                CL,[ES:DI]    </font><font color="#008000"><i>{        Store length of Src_str in CL }
                                                        </i></font><font color="#FF00FF">INC                DI            </font><font color="#008000"><i>{        Set ES:DI to first char of Src_str }
                                                        </i></font><font color="#FF00FF">MOV                BX,CX         </font><font color="#008000"><i>{        Move CX to BX }
                                                        </i></font><font color="#FF00FF">SUB                CX,AX         </font><font color="#008000"><i>{        Set CX to length of string after Strt_at }
                                                        </i></font><font color="#FF00FF">ADD                DI,AX         </font><font color="#008000"><i>{        Set ES:DI to char at Strt_at in Src_str }
                                                        </i></font><font color="#FF00FF">MOV                AL,Srch_ch    </font><font color="#008000"><i>{        Move Srch_ch to AL }
                                                        </i></font><font color="#FF00FF">CLD                 </font><font color="#008000"><i>{        Clear direction flag }
                                                        </i></font><font color="#FF00FF">REPNZ        SCASB         </font><font color="#008000"><i>{        Look for character following Strt_at }
                                                        </i></font><font color="#FF00FF">JNZ                @NOTFND       </font><font color="#008000"><i>{        If not found, jump to end of procedure }
                                                        </i></font><font color="#FF00FF">SUB                BX,CX         </font><font color="#008000"><i>{        Set BX to position char found in }
                                                        </i></font><font color="#FF00FF">JMP                @DONE         </font><font color="#008000"><i>{        Jump to end of procedure }
                </i></font><font color="#FF00FF">@NOTFND:        XOR                BX,BX         </font><font color="#008000"><i>{        Srch_ch not found, set BX to 0 }
                </i></font><font color="#FF00FF">@DONE:                MOV                AX,BX         </font><font color="#008000"><i>{        Move position found at (BX) to AX }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Next_CPos }

{$F+}
</i></font><font color="#FF0000"><b>Function </b></font>Up_cs<font color="#000080">(</font>In_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function converts In_str to all upper case characters.
}

        </i></font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function Up_cs }
                </i></font><font color="#FF0000"><b>Inline</b></font><font color="#000080">(
                        </font><font color="#800000">$1E</font><font color="#000080">/                                                                </font><font color="#008000"><i>{                                        PUSH DS  }
                        </i></font><font color="#800000">$C4</font><font color="#000080">/</font><font color="#800000">$7E</font><font color="#000080">/</font><font color="#800000">$0A</font><font color="#000080">/                                </font><font color="#008000"><i>{                                        LES         DI,[BP+$0A]  }
                        </i></font><font color="#800000">$C5</font><font color="#000080">/</font><font color="#800000">$76</font><font color="#000080">/</font><font color="#800000">$06</font><font color="#000080">/                                </font><font color="#008000"><i>{                                        LDS         SI,[BP+$06]  }
                        </i></font><font color="#800000">$30</font><font color="#000080">/</font><font color="#800000">$E4</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        XOR         AH,AH  }
                        </i></font><font color="#800000">$AC</font><font color="#000080">/                                                                </font><font color="#008000"><i>{                                        LODSB  }
                        </i></font><font color="#800000">$AA</font><font color="#000080">/                                                                </font><font color="#008000"><i>{                                        STOSB  }
                        </i></font><font color="#800000">$89</font><font color="#000080">/</font><font color="#800000">$C1</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        MOV         CX,AX  }
                        </i></font><font color="#800000">$E3</font><font color="#000080">/</font><font color="#800000">$0F</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        JCXZ DONE  }
                        </i></font><font color="#800000">$FC</font><font color="#000080">/                                                                </font><font color="#008000"><i>{                                        CLD  }
                        </i></font><font color="#800000">$AC</font><font color="#000080">/                                                                </font><font color="#008000"><i>{DOCHAR:        LODSB  }
                        </i></font><font color="#800000">$3C</font><font color="#000080">/</font><font color="#800000">$61</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        CMP         AL,'a'  }
                        </i></font><font color="#800000">$72</font><font color="#000080">/</font><font color="#800000">$06</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        JB         NEXTCH  }
                        </i></font><font color="#800000">$3C</font><font color="#000080">/</font><font color="#800000">$7A</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        CMP         AL,'z'  }
                        </i></font><font color="#800000">$77</font><font color="#000080">/</font><font color="#800000">$02</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        JA         NEXTCH  }
                        </i></font><font color="#800000">$24</font><font color="#000080">/</font><font color="#800000">$DF</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        AND         AL,$DF  }
                        </i></font><font color="#800000">$AA</font><font color="#000080">/                                                                </font><font color="#008000"><i>{NEXTCH:        STOSB  }
                        </i></font><font color="#800000">$E2</font><font color="#000080">/</font><font color="#800000">$F2</font><font color="#000080">/                                                </font><font color="#008000"><i>{                                        LOOP DOCHAR  }
                        </i></font><font color="#800000">$1F</font><font color="#000080">)                                                                </font><font color="#008000"><i>{DONE:                POP         DS  }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Up_cs }
{$F-}

</i></font><font color="#FF0000"><b>Function </b></font>Fixup_srch_str<font color="#000080">(</font>Srch_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This functions sole purpose in life is to count the number of parantheses
        pairs and correct for a deficient number of either by adding the appropriate
        character either at the beginning or the end of the search string.  This
        may not yield the correct result as the searcher intended but is a
        requirement of the algorithm (it searches for paran pairs).  Note that the
        function will add one set of parantheses if none are found.  This function
        also looks for illegal character pairs (&amp;, &amp;), (| and |), these pairs
        indicate an illegal Boolean search.  The function returns the corrected
        Srch_str if all is well, an empty string if not.
}

        </i></font><font color="#FF0000"><b>Var
                </b></font>Left_para<font color="#000080">,
                </font>Right_para<font color="#000080">,
                </font>How_many<font color="#000080">:                                                                </font>Integer<font color="#000080">;

        </font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function Fixup_srch_str }
                </i></font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>Srch_str<font color="#000080">[</font>Length<font color="#000080">(</font>Srch_str<font color="#000080">)] &lt;&gt; </font>Rt_pn<font color="#000080">) </font><font color="#FF0000"><b>Or </b></font><font color="#000080">(</font>Srch_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">] &lt;&gt; </font>Lt_pn<font color="#000080">) </font><font color="#FF0000"><b>Then
                        </b></font>Srch_str <font color="#000080">:= </font>Lt_pn <font color="#000080">+ </font>Srch_str <font color="#000080">+ </font>Rt_pn<font color="#000080">;
                </font>Left_para         <font color="#000080">:= </font>Cnt_ch<font color="#000080">(</font>Lt_pn<font color="#000080">, </font>Srch_str<font color="#000080">);                                        </font><font color="#008000"><i>{        Count the parens }
                </i></font>Right_para         <font color="#000080">:= </font>Cnt_ch<font color="#000080">(</font>Rt_pn<font color="#000080">, </font>Srch_str<font color="#000080">);
                </font>How_many                 <font color="#000080">:= </font>Abs<font color="#000080">(</font>Left_para <font color="#000080">- </font>Right_para<font color="#000080">);     </font><font color="#008000"><i>{ Get the difference }
                </i></font><font color="#FF0000"><b>If </b></font>How_many <font color="#000080">&gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>Then
                        If </b></font>Right_para <font color="#000080">&lt; </font>Left_para <font color="#FF0000"><b>Then
                                </b></font>Srch_str <font color="#000080">:= </font>Srch_str <font color="#000080">+ </font>Fill_str<font color="#000080">(</font>Rt_pn<font color="#000080">, </font>How_many<font color="#000080">)
                        </font><font color="#FF0000"><b>Else
                                </b></font>Srch_str <font color="#000080">:= </font>Fill_str<font color="#000080">(</font>Lt_pn<font color="#000080">, </font>How_many<font color="#000080">) + </font>Srch_str<font color="#000080">;
                </font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>Pos<font color="#000080">(</font>Lt_pn <font color="#000080">+ </font><font color="#800000">'&amp;'</font><font color="#000080">, </font>Srch_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>Or         </b></font><font color="#008000"><i>{ Illegal call? }
                        </i></font><font color="#000080">(</font>Pos<font color="#000080">(</font><font color="#800000">'&amp;' </font><font color="#000080">+ </font>Rt_pn<font color="#000080">, </font>Srch_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>Or
                        </b></font><font color="#000080">(</font>Pos<font color="#000080">(</font>Lt_pn <font color="#000080">+ </font><font color="#800000">'|'</font><font color="#000080">, </font>Srch_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>Or
                        </b></font><font color="#000080">(</font>Pos<font color="#000080">(</font><font color="#800000">'|' </font><font color="#000080">+ </font>Rt_pn<font color="#000080">, </font>Srch_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>Then
                                </b></font>Fixup_srch_str <font color="#000080">:= </font><font color="#800000">''
                </font><font color="#FF0000"><b>Else
                        </b></font>Fixup_srch_str <font color="#000080">:= </font>Srch_str                                                                                <font color="#008000"><i>{        All is well }
        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Fixup_srch_str }

</i></font><font color="#FF0000"><b>Function </b></font>Parse_srch_str<font color="#000080">(</font>Srch_str<font color="#000080">, </font>Src_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font><font color="#FF0000"><b>String</b></font><font color="#000080">;

</font><font color="#008000"><i>{        This function simply extracts each string to search for, tests to see if
        it exists in the original string and replaces the extracted substring with
        the appropriate token.  It should be noted that each substring is determined
        solely by the characters used for parantheses and operators.  Any other
        characters are assumed to be part of the search string.

        Each substring is searched for in the original Search_str and its presense
        or absense noted with a T or F respectively.
}

        </i></font><font color="#FF0000"><b>Var
                </b></font>Rtn_str<font color="#000080">,
                </font>Token_str<font color="#000080">:                                                        </font><font color="#FF0000"><b>String</b></font><font color="#000080">;
                </font>End_token<font color="#000080">:                                                        </font>Boolean<font color="#000080">;

        </font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function Parse_srch_str }
                </i></font>Token_str         <font color="#000080">:= </font><font color="#800000">''</font><font color="#000080">;
                </font>Rtn_str                        <font color="#000080">:= </font><font color="#800000">''</font><font color="#000080">;
                </font><font color="#FF0000"><b>While </b></font>Srch_str <font color="#000080">&lt;&gt; </font><font color="#800000">'' </font><font color="#FF0000"><b>Do
                        Begin
                                If </b></font><font color="#000080">(</font>Srch_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">] </font><font color="#FF0000"><b>In </b></font><font color="#000080">[</font>Lt_pn<font color="#000080">, </font>Rt_pn<font color="#000080">, </font><font color="#800000">'&amp;'</font><font color="#000080">, </font><font color="#800000">'|'</font><font color="#000080">]) </font><font color="#FF0000"><b>Then </b></font><font color="#008000"><i>{ Token starts? }
                                        </i></font><font color="#FF0000"><b>Begin
                                                </b></font>End_token <font color="#000080">:= (</font>Token_str <font color="#000080">&lt;&gt; </font><font color="#800000">''</font><font color="#000080">);       </font><font color="#008000"><i>{ End of token?  If not }
                                                </i></font><font color="#FF0000"><b>If Not</b></font><font color="#000080">(</font>End_token<font color="#000080">) </font><font color="#FF0000"><b>Then                </b></font><font color="#008000"><i>{ then start one.       }
                                                        </i></font>Rtn_str <font color="#000080">:= </font>Rtn_str <font color="#000080">+ </font>Srch_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">]
                                        </font><font color="#FF0000"><b>End
                                Else
                                        Begin
                                                </b></font>Token_str <font color="#000080">:= </font>Token_str <font color="#000080">+ </font>Srch_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">]; </font><font color="#008000"><i>{ Add a char to substring }
                                                </i></font>End_token        <font color="#000080">:= </font>False
                                        <font color="#FF0000"><b>End</b></font><font color="#000080">;
                                </font><font color="#FF0000"><b>If </b></font>End_token <font color="#FF0000"><b>Then                         </b></font><font color="#008000"><i>{ If complete token, look }
                                        </i></font><font color="#FF0000"><b>Begin                                   </b></font><font color="#008000"><i>{ for it in the source str }
                                                </i></font><font color="#FF0000"><b>If </b></font>Pos<font color="#000080">(</font>Token_str<font color="#000080">, </font>Src_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>Then
                                                        </b></font>Rtn_str <font color="#000080">:= </font>Rtn_str <font color="#000080">+ </font><font color="#800000">'T'            </font><font color="#008000"><i>{ If found, return T }
                                                </i></font><font color="#FF0000"><b>Else
                                                        </b></font>Rtn_str <font color="#000080">:= </font>Rtn_str <font color="#000080">+ </font><font color="#800000">'F'</font><font color="#000080">;           </font><font color="#008000"><i>{ If not, return F   }
                                                </i></font>Rtn_str         <font color="#000080">:= </font>Rtn_str <font color="#000080">+ </font>Srch_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">];
                                                </font>Token_str <font color="#000080">:= </font><font color="#800000">''</font><font color="#000080">;                      </font><font color="#008000"><i>{ Reset to look for more }
                                                </i></font>End_token        <font color="#000080">:= </font>False
                                        <font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ If End_token }
                                </i></font>Delete<font color="#000080">(</font>Srch_str<font color="#000080">, </font><font color="#800000">1</font><font color="#000080">, </font><font color="#800000">1</font><font color="#000080">)                    </font><font color="#008000"><i>{ Delete the char just
                                                                                                                                                                                                                processed and start again
                                                                                                                                                                                                        }
                        </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ While Srch_str &lt;&gt; '' }
                </i></font>Parse_srch_str <font color="#000080">:= </font>Rtn_str
        <font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Parse_srch_str }

</i></font><font color="#FF0000"><b>Function </b></font>Process_token_str<font color="#000080">(</font>Token_str<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font>Char<font color="#000080">;

        </font><font color="#FF0000"><b>Var
                </b></font>One_token<font color="#000080">:                                                        </font><font color="#FF0000"><b>String</b></font><font color="#000080">;
                </font>One_token_len<font color="#000080">,
                </font>Left_para<font color="#000080">:                                                        </font>Byte<font color="#000080">;

        </font><font color="#FF0000"><b>Function </b></font>Process_one_token_str<font color="#000080">(</font>The_token<font color="#000080">:  </font><font color="#FF0000"><b>String</b></font><font color="#000080">):  </font>Char<font color="#000080">;

                </font><font color="#FF0000"><b>Var
                        </b></font>Lcv<font color="#000080">:                                                                        </font>Byte<font color="#000080">;
                        </font>Curr_answer<font color="#000080">,
                        </font>Do_and<font color="#000080">:                                                                </font>Boolean<font color="#000080">;

                </font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function Process_one_token_str }
                        </i></font>Curr_answer <font color="#000080">:= (</font>The_token<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">] = </font><font color="#800000">'T'</font><font color="#000080">);      </font><font color="#008000"><i>{ Establish current answer
                                                                                                                                                                                                        by checking first token.
                                                                                                                                                                                                }
                        </i></font><font color="#FF0000"><b>For </b></font>Lcv <font color="#000080">:= </font><font color="#800000">2 </font><font color="#FF0000"><b>to </b></font>Length<font color="#000080">(</font>The_token<font color="#000080">) </font><font color="#FF0000"><b>Do      </b></font><font color="#008000"><i>{ Look at the rest of the
                                                                                                                                                                                                        token str.
                                                                                                                                                                                                }
                                </i></font><font color="#FF0000"><b>Case </b></font>The_token<font color="#000080">[</font>Lcv<font color="#000080">] </font><font color="#FF0000"><b>of                  </b></font><font color="#008000"><i>{ Boolean op is And }
                                        </i></font><font color="#800000">'&amp;'</font><font color="#000080">:        </font>Do_and <font color="#000080">:= </font>True<font color="#000080">;                 </font><font color="#008000"><i>{ Boolean op is Or }
                                        </i></font><font color="#800000">'|'</font><font color="#000080">:        </font>Do_and <font color="#000080">:= </font>False<font color="#000080">;
                                        </font><font color="#800000">'T'</font><font color="#000080">:        </font><font color="#FF0000"><b>If </b></font>Do_and <font color="#FF0000"><b>Then
                                                                        </b></font>Curr_answer <font color="#000080">:= </font>Curr_answer <font color="#FF0000"><b>And </b></font>True  <font color="#008000"><i>{ If And }
                                                                </i></font><font color="#FF0000"><b>Else
                                                                        </b></font>Curr_answer <font color="#000080">:= </font>True<font color="#000080">;                 </font><font color="#008000"><i>{ If Or }
                                        </i></font><font color="#800000">'F'</font><font color="#000080">:        </font><font color="#FF0000"><b>If </b></font>Do_and <font color="#FF0000"><b>Then                         </b></font><font color="#008000"><i>{ If And (Or stays T) }
                                                                        </i></font>Curr_answer <font color="#000080">:= </font>False<font color="#000080">;
                                </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Case }
                        </i></font><font color="#FF0000"><b>If </b></font>Curr_answer <font color="#FF0000"><b>Then                      </b></font><font color="#008000"><i>{ Final result }
                                </i></font>Process_one_token_str <font color="#000080">:= </font><font color="#800000">'T'
                        </font><font color="#FF0000"><b>Else
                                </b></font>Process_one_token_str        <font color="#000080">:= </font><font color="#800000">'F'
                </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Process_one_token_str }

        </i></font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function Process_token_str }

                { Are parens present?  If so process as tokenized phrase, if not, final
                        result has been received or can be processed in a single pass.
                }

                </i></font><font color="#FF0000"><b>If </b></font>PosC<font color="#000080">(</font>Lt_pn<font color="#000080">, </font>Token_str<font color="#000080">) </font><font color="#FF0000"><b>Then
                        Begin
                                While </b></font>Length<font color="#000080">(</font>Token_str<font color="#000080">) &gt; </font><font color="#800000">1 </font><font color="#FF0000"><b>Do
                                        Begin

                                                </b></font><font color="#008000"><i>{        Ensure that the token has enough parens to not confuse the
                                                        token string processor.  One need only check for a left paren
                                                        since the Fixup_srch_str function ensures that an equal number
                                                        of paren PAIRS exists.
                                                }

                                                </i></font><font color="#FF0000"><b>If Not</b></font><font color="#000080">(</font>PosC<font color="#000080">(</font>Lt_pn<font color="#000080">, </font>Token_str<font color="#000080">)) </font><font color="#FF0000"><b>Then
                                                        </b></font>Token_str <font color="#000080">:= </font>Lt_pn <font color="#000080">+ </font>Token_str <font color="#000080">+ </font>Rt_pn<font color="#000080">;

                                                </font><font color="#008000"><i>{ Find leftmost left paren }

                                                </i></font>Left_para                 <font color="#000080">:= </font>Last_Cpos<font color="#000080">(</font>Lt_pn<font color="#000080">, </font>Token_str<font color="#000080">);


                                                </font><font color="#008000"><i>{ Find first right paren after leftmost left paren }

                                                </i></font>One_token_len <font color="#000080">:=
                                                        </font>Succ<font color="#000080">(</font>Next_CPos<font color="#000080">(</font>Rt_pn<font color="#000080">, </font>Token_str<font color="#000080">, </font>Left_para<font color="#000080">) - </font>Left_para<font color="#000080">);

                                                </font><font color="#008000"><i>{ Copy everything between the two }

                                                </i></font>One_token <font color="#000080">:= </font>Copy<font color="#000080">(</font>Token_str<font color="#000080">, </font>Left_para<font color="#000080">, </font>One_token_len<font color="#000080">);

                                                </font><font color="#008000"><i>{ Remove the parens }

                                                </i></font>Dec<font color="#000080">(</font>One_token<font color="#000080">[</font><font color="#800000">0</font><font color="#000080">]);
                                                </font>Delete<font color="#000080">(</font>One_token<font color="#000080">, </font><font color="#800000">1</font><font color="#000080">, </font><font color="#800000">1</font><font color="#000080">);

                                                </font><font color="#008000"><i>{ Remove the original substring from the phrase }

                                                </i></font>Delete<font color="#000080">(</font>Token_str<font color="#000080">, </font>Left_para<font color="#000080">, </font>One_token_len<font color="#000080">);

                                                </font><font color="#008000"><i>{ Insert the resultant single character in place of the old
                                                        substring.
                                                }

                                                </i></font>Insert<font color="#000080">(</font>Process_one_token_str<font color="#000080">(</font>One_token<font color="#000080">), </font>Token_str<font color="#000080">, </font>Left_para<font color="#000080">)
                                        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ While Length(Token_str) &gt; 1 }
                                </i></font>Process_token_str <font color="#000080">:= </font>Token_str<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">]
                        </font><font color="#FF0000"><b>End
                Else
                        </b></font>Process_token_str <font color="#000080">:= </font>Process_one_token_str<font color="#000080">(</font>One_token<font color="#000080">)
        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function Process_token_str }

</i></font><font color="#FF0000"><b>Function </b></font>BPos<font color="#000080">;

        </font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Function BPos }
                </i></font>BPos <font color="#000080">:= </font>False<font color="#000080">;
                </font><font color="#FF0000"><b>If </b></font>Ignore_case <font color="#FF0000"><b>Then
                        Begin
                                </b></font>Srch_str         <font color="#000080">:= </font>Up_cs<font color="#000080">(</font>Srch_str<font color="#000080">);
                                </font>Src_str   <font color="#000080">:= </font>Up_cs<font color="#000080">(</font>Src_str<font color="#000080">)
                        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ If Ignore_case }

                {        Is this a Boolean expression?  If so process with this function, else
                        process with Pascal POS function.
                }

                </i></font><font color="#FF0000"><b>If </b></font>PosC<font color="#000080">(</font><font color="#800000">'|'</font><font color="#000080">, </font>Srch_str<font color="#000080">) </font><font color="#FF0000"><b>Or </b></font>PosC<font color="#000080">(</font><font color="#800000">'&amp;'</font><font color="#000080">, </font>Srch_str<font color="#000080">) </font><font color="#FF0000"><b>Then
                        Begin
                                </b></font>Srch_str <font color="#000080">:= </font>Parse_srch_str<font color="#000080">(</font>Fixup_srch_str<font color="#000080">(</font>Srch_str<font color="#000080">), </font>Src_str<font color="#000080">);
                                </font><font color="#FF0000"><b>If </b></font>Srch_str <font color="#000080">&lt;&gt; </font><font color="#800000">'' </font><font color="#FF0000"><b>Then
                                        </b></font>BPos <font color="#000080">:= (</font>Process_token_str<font color="#000080">(</font>Srch_str<font color="#000080">) = </font><font color="#800000">'T'</font><font color="#000080">)
                        </font><font color="#FF0000"><b>End
                Else
                        </b></font>BPos <font color="#000080">:= </font>Pos<font color="#000080">(</font>Srch_str<font color="#000080">, </font>Src_str<font color="#000080">) &lt;&gt; </font><font color="#800000">0
        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Function BPos }

</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">.  </font><font color="#008000"><i>{ Unit BoolPos }

</i></font><font color="#FF0000"><b>Program </b></font>Test<font color="#000080">;
</font><font color="#008000"><i>{$Define test}

{        Version 1.0.0.T

        Requires Borland Turbo Pascal version 6.0 or later to compile.

        Author:  Bruce J. Lackore.  Created Monday, June 13, 1994.
        Copyright (c) 1994 Bruce J. Lackore.  ALL RIGHTS RESERVED.
}

{$IFDEF Test}
        {$A+,B-,D+,E+,F-,G-,I+,L+,N-,R+,S+,V-,X+}
{$ELSE}
        {$A+,B-,D-,E+,F-,G-,I-,L-,N-,R-,S-,V-,X+}
{$ENDIF}

{$M 16384, 0, 655360}

{        This is a quick and really dirty test program for the Boolpos unit.  Just
        tinker with the search phrase in line 3 of the code and enjoy!
}

</i></font><font color="#FF0000"><b>Uses </b></font>Boolpos<font color="#000080">;

</font><font color="#FF0000"><b>Var
        </b></font>BResult<font color="#000080">: </font>Boolean<font color="#000080">;
        </font>Src_str<font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Procedure </b></font>Start_program<font color="#000080">;

        </font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Procedure Start_program }
                </i></font>BResult <font color="#000080">:= </font>False<font color="#000080">;
                </font>Src_str        <font color="#000080">:= </font><font color="#800000">'Now is the time for all good programmers to switch to OS/2'</font><font color="#000080">;
                </font>BResult <font color="#000080">:= </font>BPos<font color="#000080">(</font><font color="#800000">'(Now&amp;then)|(time&amp;bad)'</font><font color="#000080">, </font>Src_str<font color="#000080">, </font>False<font color="#000080">)
        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Procedure Start_program }

</i></font><font color="#FF0000"><b>Begin  </b></font><font color="#008000"><i>{ Program:  Test }
        </i></font>Start_program<font color="#000080">;
</font><font color="#FF0000"><b>End</b></font><font color="#000080">.  </font><font color="#008000"><i>{ Program:  Test }</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to STRINGS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0099.PAS">Original</a><b>]</b></p></body>
</html>
