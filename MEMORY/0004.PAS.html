<html>
<head><title> "DPMIINFO.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0004.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#000000">Hello All<font color="#000080">,

</font>Again<font color="#000080">, </font>interrupts from <font color="#FF0000"><b>protected </b></font>mode<font color="#000080">. </font>This <font color="#FF0000"><b>is </b></font>an updated version <font color="#FF0000"><b>of </b></font>my
previous article<font color="#000080">, </font>which<font color="#000080">, </font>by the way<font color="#000080">, </font>generated much less respons <font color="#000080">(</font>none<font color="#000080">)
</font>than I expected<font color="#000080">. </font>Where are the BTrieve Programmers<font color="#000080">, </font>the DesqView API
Writers<font color="#000080">, </font>the fossil Writers<font color="#000080">, </font>the <font color="#000080">.... </font>Maybe they know everything
already<font color="#000080">. </font>Well <font color="#FF0000"><b>then</b></font><font color="#000080">, </font>what has been changed<font color="#000080">?

* </font>little bugs fixed <font color="#000080">(</font>memory <font color="#FF0000"><b>not </b></font>freed<font color="#000080">, </font>SEG does <font color="#FF0000"><b>not </b></font>work<font color="#000080">, </font>etc<font color="#000080">.)
* </font>I stated that <font color="#FF0000"><b>if </b></font>you want <font color="#FF0000"><b>to </b></font>pass parameters <font color="#FF0000"><b>on </b></font>the stack you had <font color="#FF0000"><b>to
  do </b></font>low level stuff<font color="#000080">. </font>This <font color="#FF0000"><b>is not </b></font>necessary<font color="#000080">. </font>I <font color="#FF0000"><b>do </b></font>everything <font color="#FF0000"><b>in </b></font>high
  level<font color="#000080">(?) </font><font color="#FF0000"><b>pascal </b></font>now<font color="#000080">.
* </font>Point <font color="#800000">5 </font><font color="#FF0000"><b>of </b></font>the first <font color="#FF0000"><b>Type of </b></font>unsupported interrupts was inComplete<font color="#000080">.
  </font>There<font color="#800000">'s sometimes much more work involved :-(
</font><font color="#000080">* </font>A simple <font color="#FF0000"><b>Unit is </b></font>presented<font color="#000080">, </font>which helps <font color="#FF0000"><b>to </b></font>cut down code size<font color="#000080">. </font>See
  Appendix A

Compiling Real <font color="#FF0000"><b>to protected </b></font>mode has been very simple <font color="#FF0000"><b>For </b></font>most <font color="#FF0000"><b>of </b></font>us<font color="#000080">.
</font>Just Compile <font color="#FF0000"><b>and </b></font>go ahead<font color="#000080">. </font><font color="#800000">99.5</font><font color="#000080">% </font><font color="#FF0000"><b>of </b></font>your code works fine<font color="#000080">. </font>But the other
<font color="#800000">0.5</font><font color="#000080">% </font><font color="#FF0000"><b>is </b></font>going <font color="#FF0000"><b>to </b></font>give you some hard<font color="#000080">, </font>hard work<font color="#000080">.
   </font><font color="#FF0000"><b>In </b></font>this article I describe first how I first stuck <font color="#FF0000"><b>on </b></font>the <font color="#FF0000"><b>protected
</b></font>stone<font color="#000080">. </font>Than I <font color="#FF0000"><b>try to </b></font>give a general overview <font color="#FF0000"><b>of </b></font>problems one might
encounter when using interrupts<font color="#000080">. </font>Next I describe the solutions <font color="#FF0000"><b>or </b></font>give
at least some hints<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>I give a solution <font color="#FF0000"><b>to </b></font>the original <font color="#FF0000"><b>Program </b></font>which
made me aware <font color="#FF0000"><b>of protected </b></font>mode conversion problems<font color="#000080">. </font>Appendix A lists
the code <font color="#FF0000"><b>For </b></font>a <font color="#FF0000"><b>Unit </b></font>I found usefull when porting my DesqView API <font color="#FF0000"><b>to
protected </b></font>mode<font color="#000080">.
    </font>References can be found at the <font color="#FF0000"><b>end of </b></font>this article<font color="#000080">. </font><font color="#FF0000"><b>of </b></font>course<font color="#000080">, </font>all
disclaimers you can come up <font color="#FF0000"><b>With </b></font>apply<font color="#000080">!


</font>When Compiling a big <font color="#FF0000"><b>Program</b></font><font color="#000080">, </font>which supported DesqView<font color="#000080">, </font>a GP fault
occurred<font color="#000080">. </font>It was simple <font color="#FF0000"><b>to </b></font>trace the bug down<font color="#000080">: </font>TDX would show me the
offending code<font color="#000080">. </font>You can get the same error <font color="#FF0000"><b>if </b></font>you <font color="#FF0000"><b>try to </b></font>run the
following <font color="#FF0000"><b>Program in protected </b></font>mode<font color="#000080">:

========</font>cut here<font color="#000080">==========================
</font><font color="#FF0000"><b>Program </b></font>Test<font color="#000080">;

</font><font color="#FF0000"><b>Function  </b></font>dv_win_me <font color="#000080">: </font>LongInt<font color="#000080">;  </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
  </b></font><font color="#FF00FF">mov    bx,0001h
  mov    ah,12h
  int    15h       </font><font color="#008000"><i>{* push dWord handle on stack *}
  </i></font><font color="#FF00FF">pop    ax        </font><font color="#008000"><i>{* pop it *}
  </i></font><font color="#FF00FF">pop    dx        </font><font color="#008000"><i>{* and return it *}
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font>Writeln<font color="#000080">(</font>dv_win_me<font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">.
========</font>cut here<font color="#000080">==========================

</font>This little <font color="#FF0000"><b>Program </b></font>must be run under DesqView<font color="#000080">. </font>When run under DesqView
it returns the current Window handle <font color="#FF0000"><b>on </b></font>the stack<font color="#000080">. </font>BUT<font color="#000080">: </font>when Compiled
under <font color="#FF0000"><b>protected </b></font>mode NO dWord handle <font color="#FF0000"><b>is </b></font>returned <font color="#FF0000"><b>on </b></font>the stack<font color="#000080">. </font>So a
stack fault occurs<font color="#000080">.

</font>What happened<font color="#000080">? </font>I stuck <font color="#FF0000"><b>on </b></font>one <font color="#FF0000"><b>of </b></font>those unsupported interrupts<font color="#000080">. </font>Only
supported interupts guarantee <font color="#FF0000"><b>to </b></font>return correct results<font color="#000080">. </font>You can find a
list <font color="#FF0000"><b>of </b></font>all supported interrupts <font color="#FF0000"><b>in </b></font>the Borland Open Architecture
Handboek <font color="#FF0000"><b>For Pascal</b></font><font color="#000080">, </font>Chapter <font color="#800000">2 </font><font color="#000080">(</font>seperate sold by Borland<font color="#000080">, </font><font color="#FF0000"><b>not </b></font>included
<font color="#FF0000"><b>in </b></font>your BP7 <font color="#FF0000"><b>package</b></font><font color="#000080">). </font>Supported are the general Dos <font color="#FF0000"><b>and </b></font>Bios interrupts<font color="#000080">.

</font>BeFore eleborating <font color="#FF0000"><b>on </b></font>supported <font color="#FF0000"><b>and </b></font>unsupported interrupts<font color="#000080">, </font>I have <font color="#FF0000"><b>to
</b></font>explain a few issues which are probably new <font color="#FF0000"><b>to </b></font>us <font color="#FF0000"><b>Pascal </b></font>Programmers<font color="#000080">.
</font>Whenever a user interrupt occurs <font color="#FF0000"><b>in protected </b></font>mode <font color="#000080">(</font>you issue a int xx
call<font color="#000080">) </font>Borlands DPMI Extender switches <font color="#FF0000"><b>to </b></font>Real mode<font color="#000080">, </font>issues the
interrupt<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>switches back <font color="#FF0000"><b>to protected </b></font>mode<font color="#000080">.

</font>This works find <font color="#FF0000"><b>For </b></font>most Cases<font color="#000080">: </font>interrupts which only pass <font color="#FF0000"><b>register
</b></font>parameters work fine<font color="#000080">. </font>But what happens <font color="#FF0000"><b>if </b></font>you<font color="#000080">, </font><font color="#FF0000"><b>For </b></font>example<font color="#000080">, </font>called the
Print <font color="#FF0000"><b>String Function</b></font><font color="#000080">? (</font>int <font color="#800000">21</font>h<font color="#000080">, </font>ah<font color="#000080">=</font><font color="#800000">09</font>h<font color="#000080">). </font>You pass <font color="#FF0000"><b>as </b></font>parameters ds<font color="#000080">:</font>dx
pointing <font color="#FF0000"><b>to </b></font>the <font color="#FF0000"><b>String to </b></font>be printed<font color="#000080">. </font>But<font color="#000080">, </font>be aware<font color="#000080">: </font><font color="#FF0000"><b>in protected </b></font>mode
ds <font color="#FF0000"><b>contains not </b></font>a segment but a selector<font color="#000080">! </font><font color="#FF0000"><b>and </b></font>the selector <font color="#FF0000"><b>in </b></font>ds
probably points <font color="#FF0000"><b>to </b></font>an area above the <font color="#800000">1</font>MB boundary<font color="#000080">. </font>These two things are
going <font color="#FF0000"><b>to </b></font>give Real mode Dos big<font color="#000080">, </font>big problems<font color="#000080">. </font>Don<font color="#800000">'t even try it!
    </font>So Borland<font color="#800000">'s DPMI Extender does more than just switching from
</font><font color="#FF0000"><b>protected to </b></font>Real mode when an interrupt occurs<font color="#000080">: </font>it translates selectors
<font color="#FF0000"><b>to </b></font>segments when appropriate<font color="#000080">. </font>But<font color="#000080">, </font>it can only <font color="#FF0000"><b>do </b></font>so <font color="#FF0000"><b>For </b></font>interrupts it
KNOWS that they need a translation<font color="#000080">. </font>Such interrupts are called
supported<font color="#000080">. </font>Interrupts about which Borland<font color="#800000">'s DPMI Extender does not know
</font>about are unsupported<font color="#000080">. </font><font color="#FF0000"><b>and </b></font>they are going <font color="#FF0000"><b>to </b></font>give you Real problems<font color="#000080">!

</font>So you see<font color="#000080">, </font>when only data <font color="#FF0000"><b>is </b></font>passed <font color="#FF0000"><b>in </b></font>Registers<font color="#000080">, </font>everything works
fine<font color="#000080">. </font>But <font color="#FF0000"><b>if </b></font>you need <font color="#FF0000"><b>to </b></font>pass Pointers<font color="#000080">, </font>there <font color="#FF0000"><b>is </b></font>a problem<font color="#000080">. </font>But why did
the above <font color="#FF0000"><b>Program not </b></font>work<font color="#000080">? </font>It didn<font color="#800000">'t use selectors you might ask. Well,
</font>there <font color="#FF0000"><b>is </b></font>another <font color="#FF0000"><b>set of </b></font>interrupts that are unsupported<font color="#000080">: </font>those that
expect <font color="#FF0000"><b>or </b></font>return values <font color="#FF0000"><b>on </b></font>the stack<font color="#000080">. </font>This <font color="#FF0000"><b>is </b></font>the <font color="#FF0000"><b>Case With </b></font>the above
<font color="#FF0000"><b>Program</b></font><font color="#000080">.

</font>So<font color="#000080">, </font><font color="#FF0000"><b>to </b></font>conclude<font color="#000080">:
* </font>supported interrupts
  <font color="#000080">- </font>simple parameter passing using Registers<font color="#000080">, </font>no segments<font color="#000080">/</font>selectors
    <font color="#FF0000"><b>or </b></font>stacks included
  <font color="#000080">- </font>interrupts which Borland<font color="#800000">'s DPMI Extender knows about (too few For
    </font>most <font color="#FF0000"><b>of </b></font>us<font color="#000080">)
* </font>unsupported interrupts
  <font color="#000080">- </font>using segments<font color="#000080">/</font>selectors
  <font color="#000080">- </font>involving stacks

<font color="#FF0000"><b>In </b></font>the next two sections I will fix both Types <font color="#FF0000"><b>of </b></font>problems<font color="#000080">. </font>I make use
<font color="#FF0000"><b>of </b></font>the DPMI <font color="#FF0000"><b>Unit</b></font><font color="#000080">, </font>which comes <font color="#FF0000"><b>With </b></font>the Open Architecture Handbook<font color="#000080">. </font>You
<font color="#FF0000"><b>do not </b></font>need this <font color="#FF0000"><b>Unit</b></font><font color="#000080">. </font><font color="#FF0000"><b>As </b></font>this DPMI <font color="#FF0000"><b>Unit is </b></font>just a wrapper around the
DPMI interrupt <font color="#800000">31</font>h<font color="#000080">, </font>simply looking the interrupts up <font color="#FF0000"><b>in </b></font>Ralph Brown<font color="#800000">'s
</font>interrupts list <font color="#FF0000"><b>and </b></font>writing Functions<font color="#000080">/</font>Procedures <font color="#FF0000"><b>For </b></font>them<font color="#000080">, </font>works fine<font color="#000080">.


</font>Unsupported interrupts which need segments
<font color="#000080">------------------------------------------

</font>Because the data segment <font color="#FF0000"><b>and </b></font>stack segment reside <font color="#FF0000"><b>in protected </b></font>mode<font color="#000080">, </font>you
need <font color="#FF0000"><b>to </b></font>allocate memory <font color="#FF0000"><b>in </b></font>Real mode<font color="#000080">, </font>copy your data <font color="#000080">(</font>which resides
above <font color="#800000">1</font>MB<font color="#000080">) </font><font color="#FF0000"><b>and </b></font>issue the interrupt by calling the DPMI Simulate Real
Interrupt<font color="#000080">. </font>So our <font color="#FF0000"><b>to</b></font><font color="#000080">-</font><font color="#FF0000"><b>do </b></font>list <font color="#FF0000"><b>is</b></font><font color="#000080">:
</font><font color="#800000">1</font><font color="#000080">) </font>allocate Real mode memory
<font color="#800000">2</font><font color="#000080">) </font>copy data from <font color="#FF0000"><b>protected </b></font>mode <font color="#FF0000"><b>to </b></font>Real mode
<font color="#800000">3</font><font color="#000080">) </font><font color="#FF0000"><b>set </b></font>up the Real mode Registers
<font color="#800000">4</font><font color="#000080">) </font>issue interrupt
<font color="#800000">5</font><font color="#000080">) </font>examine results

<font color="#800000">1</font><font color="#000080">) </font>You can allocate Real mode memory by issueing a GlobalDosAlloc <font color="#000080">(</font><font color="#FF0000"><b>not
   </b></font>referenced <font color="#FF0000"><b>in </b></font>the online help<font color="#000080">, </font>but you can look it up <font color="#FF0000"><b>in </b></font>the
   Programmer<font color="#800000">'s refercence manual) request. The GlobalDosAlloc is in the
   </font>WinApi <font color="#FF0000"><b>Unit</b></font><font color="#000080">. </font><font color="#FF0000"><b>For </b></font>example<font color="#000080">:

     </font><font color="#FF0000"><b>Uses </b></font>WinAPI<font color="#000080">;
     </font><font color="#FF0000"><b>Var
       </b></font>Return <font color="#000080">: </font>LongInt<font color="#000080">;
       </font>MemSize <font color="#000080">: </font>LongInt<font color="#000080">;
     </font><font color="#FF0000"><b>begin
       </b></font>MemSize <font color="#000080">:= </font><font color="#800000">1024</font><font color="#000080">;
       </font>Return <font color="#000080">:= </font>GlobalDosAlloc<font color="#000080">(</font>MemSize<font color="#000080">);
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>This call allocates a block <font color="#FF0000"><b>of </b></font>memory<font color="#000080">, </font><font color="#800000">1</font>K <font color="#FF0000"><b>in </b></font>size<font color="#000080">, </font>below the <font color="#800000">1</font>MB
   boundary<font color="#000080">. </font>The value <font color="#FF0000"><b>in </b></font>Return should be split <font color="#FF0000"><b>in </b></font>LongRec<font color="#000080">(</font>Return<font color="#000080">).</font>Lo
   <font color="#FF0000"><b>and </b></font>LongRec<font color="#000080">(</font>Return<font color="#000080">).</font>Hi<font color="#000080">. </font>The Hi<font color="#000080">-</font>order Word <font color="#FF0000"><b>contains </b></font>the segment base
   address <font color="#FF0000"><b>of </b></font>the block<font color="#000080">. </font>The low<font color="#000080">-</font>order Word <font color="#FF0000"><b>contains </b></font>the selector <font color="#FF0000"><b>For
   </b></font>the block<font color="#000080">.

</font><font color="#800000">2</font><font color="#000080">) </font>You use the selector <font color="#FF0000"><b>to </b></font>acces the block from <font color="#FF0000"><b>protected </b></font>mode <font color="#FF0000"><b>and </b></font>you
   use the segment <font color="#FF0000"><b>of </b></font>the block <font color="#FF0000"><b>to </b></font>acces the block within Real mode <font color="#000080">(</font>your
   interrupt<font color="#000080">).
       </font><font color="#FF0000"><b>For </b></font>example<font color="#000080">: </font>we want <font color="#FF0000"><b>to </b></font>exchange messages <font color="#FF0000"><b>With </b></font>some interrupt<font color="#000080">. </font>The
   code <font color="#FF0000"><b>For </b></font>this would be<font color="#000080">:
     </font><font color="#FF0000"><b>Uses </b></font>WinAPI<font color="#000080">;
     </font><font color="#FF0000"><b>Var
       </b></font>Return <font color="#000080">: </font>LongInt<font color="#000080">;
       </font>MemSize <font color="#000080">: </font>LongInt<font color="#000080">;
       </font>RealModeSel <font color="#000080">: </font>Pointer<font color="#000080">;
       </font>RealModeSeg <font color="#000080">: </font>Pointer<font color="#000080">;
       </font><font color="#FF0000"><b>Message </b></font><font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">;
     </font><font color="#FF0000"><b>begin
       </b></font>MemSize <font color="#000080">:= </font><font color="#800000">256</font><font color="#000080">;
       </font>Return <font color="#000080">:= </font>GlobalDosAlloc<font color="#000080">(</font>MemSize<font color="#000080">);
       </font>PtrRec<font color="#000080">(</font>RealModeSel<font color="#000080">).</font>seg <font color="#000080">:= </font>LongRec<font color="#000080">(</font>Return<font color="#000080">).</font>Lo<font color="#000080">;
       </font>PtrRec<font color="#000080">(</font>RealModeSel<font color="#000080">).</font>ofs <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
       </font>PtrRec<font color="#000080">(</font>RealModeSeg<font color="#000080">).</font>seg <font color="#000080">:= </font>LongRec<font color="#000080">(</font>Return<font color="#000080">).</font>Hi<font color="#000080">;
       </font>PtrRec<font color="#000080">(</font>RealModeSeg<font color="#000080">).</font>ofs <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;

     </font><font color="#008000"><i>{* Both RealModeSel(ector) and RealModeSeg(ment) point to the same

        physical address now. *}

     {* move message from protected mode memory to the allocated selector *}
       </i></font><font color="#FF0000"><b>Message </b></font><font color="#000080">:= </font><font color="#800000">'How are your?'</font><font color="#000080">;
       </font>Move<font color="#000080">(</font><font color="#FF0000"><b>Message</b></font><font color="#000080">, </font>RealModeSel<font color="#000080">^, </font>Sizeof<font color="#000080">(</font><font color="#FF0000"><b>Message</b></font><font color="#000080">));

     </font><font color="#008000"><i>{* issue interupt, explained below *}
     { &lt;..code..&gt; }
     {* the interrupt returns a message *}

     {* move interrupt's message below 1MB to protected mode *}
       </i></font>Move<font color="#000080">(</font>RealModeSel<font color="#000080">^, </font><font color="#FF0000"><b>Message</b></font><font color="#000080">, </font>Sizeof<font color="#000080">(</font><font color="#FF0000"><b>Message</b></font><font color="#000080">));
       </font>Writeln<font color="#000080">(</font><font color="#FF0000"><b>Message</b></font><font color="#000080">);     </font><font color="#008000"><i>{* &quot;yes, I'm fine. Thank you!&quot; *}
     </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#800000">3</font><font color="#000080">) </font>We will now examine how <font color="#FF0000"><b>to </b></font>setup an interrupt <font color="#FF0000"><b>For </b></font>Real mode<font color="#000080">. </font>Most <font color="#FF0000"><b>of
   </b></font>the time this <font color="#FF0000"><b>is </b></font>transparantly done by Borland<font color="#800000">'s DPMI Extender, but
   </font>we are <font color="#FF0000"><b>on </b></font>our own now<font color="#000080">. </font><font color="#FF0000"><b>to </b></font>interrupt Dos<font color="#000080">, </font>we use the DPMI <font color="#FF0000"><b>Function
   </b></font><font color="#800000">31</font>h<font color="#000080">, </font><font color="#800000">0300</font>h<font color="#000080">. </font>This interrupt simulates an interrupt <font color="#FF0000"><b>in </b></font>Real mode<font color="#000080">.

   </font>The Simulate Real Mode Interrupt <font color="#FF0000"><b>Function </b></font>needs a Real mode <font color="#FF0000"><b>register
   </b></font>data structure<font color="#000080">. </font>We pass the interrupt <font color="#FF0000"><b>and </b></font>the Real mode <font color="#FF0000"><b>register </b></font>data
   structure <font color="#FF0000"><b>to </b></font>this <font color="#FF0000"><b>Function</b></font><font color="#000080">, </font>which will than start <font color="#FF0000"><b>to </b></font>simulate the
   interrupt<font color="#000080">.
       </font>This <font color="#FF0000"><b>Function </b></font>switches <font color="#FF0000"><b>to </b></font>Real mode<font color="#000080">, </font>copies the contents <font color="#FF0000"><b>of </b></font>the
   data structure into the Registers<font color="#000080">, </font>makes the interrupt<font color="#000080">, </font>copies the
   Registers back into the supplied data structure<font color="#000080">, </font>switches the
   processor back <font color="#FF0000"><b>to protected </b></font>mode <font color="#FF0000"><b>and </b></font>returns<font color="#000080">. </font>Voila<font color="#000080">: </font>you are <font color="#FF0000"><b>in
   </b></font>control again<font color="#000080">.
       </font>Maybe you ask<font color="#000080">: </font>why need I <font color="#FF0000"><b>to </b></font>setup such a data structure<font color="#000080">? </font>Why can
   I <font color="#FF0000"><b>not </b></font>simply pass Registers<font color="#000080">? </font>Several reasons exist<font color="#000080">, </font>but take <font color="#FF0000"><b>For
   </b></font>example the RealModeSeg <font color="#FF0000"><b>of </b></font>the previous example<font color="#000080">. </font>You cannot simply
   load a RealModeSeg <font color="#FF0000"><b>in </b></font>a <font color="#FF0000"><b>register</b></font><font color="#000080">. </font>Most likely a segment violation
   would occur <font color="#000080">(</font>referring <font color="#FF0000"><b>to </b></font>a non existing segment <font color="#FF0000"><b>or </b></font>you <font color="#FF0000"><b>do not </b></font>have
   enough rights etc<font color="#000080">.). </font>ThereFore only <font color="#FF0000"><b>in </b></font>Real mode can Real mode
   segments be loaded<font color="#000080">.

       </font>The data structure <font color="#FF0000"><b>to </b></font>pass Registers between <font color="#FF0000"><b>protected and </b></font>Real
   mode can be found <font color="#FF0000"><b>in </b></font>the DPMI <font color="#FF0000"><b>Unit </b></font>which I <font color="#FF0000"><b>Repeat </b></font>here<font color="#000080">:

     </font><font color="#FF0000"><b>Type
       </b></font>TRealModeRegs <font color="#000080">= </font><font color="#FF0000"><b>Record
         Case </b></font>Integer <font color="#FF0000"><b>of
           </b></font><font color="#800000">0</font><font color="#000080">: (
               </font>EDI<font color="#000080">, </font>ESI<font color="#000080">, </font>EBP<font color="#000080">, </font>EXX<font color="#000080">, </font>EBX<font color="#000080">, </font>EDX<font color="#000080">, </font>ECX<font color="#000080">, </font>EAX<font color="#000080">: </font>LongInt<font color="#000080">;
               </font>Flags<font color="#000080">, </font>ES<font color="#000080">, </font>DS<font color="#000080">, </font>FS<font color="#000080">, </font>GS<font color="#000080">, </font>IP<font color="#000080">, </font>CS<font color="#000080">, </font>SP<font color="#000080">, </font>SS<font color="#000080">: </font>Word<font color="#000080">);
           </font><font color="#800000">1</font><font color="#000080">: (
               </font>DI<font color="#000080">,</font>DIH<font color="#000080">, </font>SI<font color="#000080">, </font>SIH<font color="#000080">, </font>BP<font color="#000080">, </font>BPH<font color="#000080">, </font>XX<font color="#000080">, </font>XXH<font color="#000080">: </font>Word<font color="#000080">;
               </font><font color="#FF0000"><b>Case </b></font>Integer <font color="#FF0000"><b>of
                 </b></font><font color="#800000">0</font><font color="#000080">: (
                     </font>BX<font color="#000080">, </font>BXH<font color="#000080">, </font>DX<font color="#000080">, </font>DXH<font color="#000080">, </font>CX<font color="#000080">, </font>CXH<font color="#000080">, </font>AX<font color="#000080">, </font>AXH<font color="#000080">: </font>Word<font color="#000080">);

                 </font><font color="#800000">1</font><font color="#000080">: (
                     </font>BL<font color="#000080">, </font>BH<font color="#000080">, </font>BLH<font color="#000080">, </font>BHH<font color="#000080">, </font>DL<font color="#000080">, </font>DH<font color="#000080">, </font>DLH<font color="#000080">, </font>DHH<font color="#000080">,
                     </font>CL<font color="#000080">, </font>CH<font color="#000080">, </font>CLH<font color="#000080">, </font>CHH<font color="#000080">, </font>AL<font color="#000080">, </font>AH<font color="#000080">, </font>ALH<font color="#000080">, </font>AHH<font color="#000080">: </font>Byte<font color="#000080">));
         </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>This looks reasonably Complex<font color="#000080">, </font>doesn<font color="#800000">'t it! More simply is the
   </font>following structure <font color="#000080">(</font>found <font color="#FF0000"><b>in</b></font><font color="#000080">, </font><font color="#FF0000"><b>For </b></font>example<font color="#000080">, &quot;</font>Extending Dos<font color="#000080">&quot; </font>by Ray
   Duncan e<font color="#000080">.</font>a<font color="#000080">.)
   </font>offset  Lenght Contents
   <font color="#800000">00</font>h     <font color="#800000">4      </font>DI <font color="#FF0000"><b>or </b></font>EDI
   <font color="#800000">04</font>h     <font color="#800000">4      </font>SI <font color="#FF0000"><b>or </b></font>ESI
   <font color="#800000">08</font>h     <font color="#800000">4      </font>BP <font color="#FF0000"><b>or </b></font>EBP
   <font color="#800000">0</font>Ch     <font color="#800000">4      </font>reserved<font color="#000080">, </font>should be zero
   <font color="#800000">10</font>h     <font color="#800000">4      </font>BX <font color="#FF0000"><b>or </b></font>EBX
   <font color="#800000">14</font>h     <font color="#800000">4      </font>DX <font color="#FF0000"><b>or </b></font>EDX
   <font color="#800000">18</font>h     <font color="#800000">4      </font>CX <font color="#FF0000"><b>or </b></font>ECX
   <font color="#800000">1</font>Ch     <font color="#800000">4      </font>AX <font color="#FF0000"><b>or </b></font>EAX
   <font color="#800000">20</font>h     <font color="#800000">2      </font>CPU status flags
   <font color="#800000">22</font>h     <font color="#800000">2      </font>ES
   <font color="#800000">24</font>h     <font color="#800000">2      </font>DS
   <font color="#800000">26</font>h     <font color="#800000">2      </font>FS
   <font color="#800000">28</font>h     <font color="#800000">2      </font>GS
   <font color="#800000">2</font>Ah     <font color="#800000">2      </font>IP <font color="#000080">(</font>reserved<font color="#000080">, </font>ignored<font color="#000080">)
   </font><font color="#800000">2</font>Ch     <font color="#800000">2      </font>CS <font color="#000080">(</font>reserved<font color="#000080">, </font>ignored<font color="#000080">)
   </font><font color="#800000">2E</font>h     <font color="#800000">2      </font>SP <font color="#000080">(</font>ignored when zero<font color="#000080">)
   </font><font color="#800000">30</font>h     <font color="#800000">2      </font>SS <font color="#000080">(</font>ignored when zero<font color="#000080">)

   </font><font color="#FF0000"><b>In </b></font>the following example<font color="#000080">, </font>I <font color="#FF0000"><b>set </b></font>the Registers <font color="#FF0000"><b>For </b></font>the above <font color="#FF0000"><b>message
   </b></font>exchanging <font color="#FF0000"><b>Function</b></font><font color="#000080">. </font>It<font color="#800000">'s best to clear all Registers (or at least
   </font>the SS<font color="#000080">:</font>SP Registers<font color="#000080">) </font>beFore calling the Simulate Real Mode Interrupt<font color="#000080">.

     </font><font color="#FF0000"><b>Uses </b></font>DPMI<font color="#000080">;
     </font><font color="#FF0000"><b>Var
       </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">;
     </font><font color="#FF0000"><b>begin
       </b></font>FillChar<font color="#000080">(</font>Regs<font color="#000080">, </font>Sizeof<font color="#000080">(</font>TRealModeRegs<font color="#000080">), </font><font color="#800000">#0</font><font color="#000080">); </font><font color="#008000"><i>{* clear all Registers *}

       </i></font><font color="#FF0000"><b>With </b></font>Regs <font color="#FF0000"><b>do  begin
         </b></font>ah <font color="#000080">:= </font><font color="#800000">$</font>xx<font color="#000080">;
         </font>es <font color="#000080">:= </font>PtrRec<font color="#000080">(</font>RealModeSeg<font color="#000080">).</font>Seg<font color="#000080">;
         </font>di <font color="#000080">:= </font>PtrRec<font color="#000080">(</font>RealModeSeg<font color="#000080">).</font>ofs
       <font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ of With }
     </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>All this <font color="#FF0000"><b>is </b></font>fairly standard<font color="#000080">. </font>Just <font color="#FF0000"><b>set </b></font>up the Registers you interrupts
   expect<font color="#000080">, </font>very much like the Intr <font color="#FF0000"><b>Procedure</b></font><font color="#000080">.

</font><font color="#800000">4</font><font color="#000080">) </font>We can now issue the interrupt <font color="#FF0000"><b>in </b></font>Real mode using the RealModeInt
   <font color="#FF0000"><b>Procedure </b></font><font color="#000080">(</font><font color="#FF0000"><b>in </b></font>the DPMI <font color="#FF0000"><b>Unit</b></font><font color="#000080">). </font>Its definition <font color="#FF0000"><b>is

     Procedure </b></font>RealModeInt<font color="#000080">(</font>Int<font color="#000080">: </font>Byte<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>Regs<font color="#000080">: </font>TRealModeRegs<font color="#000080">);

   </font><font color="#FF0000"><b>or </b></font>you can call int <font color="#800000">31</font>h<font color="#000080">, </font><font color="#FF0000"><b>Function </b></font><font color="#800000">0300</font>h<font color="#000080">, </font>see Ralph Brown<font color="#800000">'s interrupt
   </font>list<font color="#000080">.
   </font><font color="#FF0000"><b>For </b></font>our <font color="#FF0000"><b>message </b></font>exchanging <font color="#FF0000"><b>Program </b></font>it would simply be<font color="#000080">:
     </font>RealModeInt<font color="#000080">(</font>xx<font color="#000080">, </font>Regs<font color="#000080">);

</font><font color="#800000">5</font><font color="#000080">) </font>Examine the results<font color="#000080">. </font>Modified Registers are passed <font color="#FF0000"><b>in </b></font>the Regs data
   structure so you can check the results<font color="#000080">.
       </font>It <font color="#FF0000"><b>is </b></font>necessary <font color="#FF0000"><b>to </b></font>discriminate between <font color="#FF0000"><b>to </b></font>Types <font color="#FF0000"><b>of </b></font>returned
   segments<font color="#000080">. </font><font color="#FF0000"><b>In </b></font>the example above<font color="#000080">, </font>I assumed that the Interrupt returned
   data <font color="#FF0000"><b>in </b></font>the allocated memory block<font color="#000080">. </font>I already have a selector <font color="#FF0000"><b>For
   </b></font>that block<font color="#000080">, </font>so I can examine the results<font color="#000080">.
   </font>Another <font color="#FF0000"><b>Type of </b></font>interrupt returns Pointers <font color="#FF0000"><b>to </b></font>segments it has
   allocated itself<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>we don<font color="#800000">'t have a selector For that memory block
   </font>we have <font color="#FF0000"><b>to </b></font>create one<font color="#000080">. </font>We need the following Functions<font color="#000080">:
   - </font>AllocSelectors<font color="#000080">, </font><font color="#FF0000"><b>to </b></font>allocate a selector
   <font color="#000080">- </font>SetSelectorBase<font color="#000080">, </font><font color="#FF0000"><b>to </b></font>let it point <font color="#FF0000"><b>to </b></font>a physical address
   <font color="#000080">- </font>SetSelectorLimit<font color="#000080">, </font><font color="#FF0000"><b>to set </b></font>the size
   An example <font color="#FF0000"><b>For </b></font>this situation<font color="#000080">: </font>Assume that a certain interrupt
   returns a Pointer <font color="#FF0000"><b>to </b></font>a memory area<font color="#000080">. </font>This Pointer <font color="#FF0000"><b>is in </b></font>es<font color="#000080">:</font>di<font color="#000080">.
   </font><font color="#FF0000"><b>Register </b></font>cs <font color="#FF0000"><b>contains </b></font>the size <font color="#FF0000"><b>of </b></font>that memorya rea<font color="#000080">. </font>I show you how <font color="#FF0000"><b>to
   </b></font>acces that segment<font color="#000080">.

     </font><font color="#FF0000"><b>Uses </b></font>DPMI<font color="#000080">;
     </font><font color="#FF0000"><b>Var
       </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">;
       </font>p <font color="#000080">: </font>Pointer<font color="#000080">;
     </font><font color="#FF0000"><b>begin
     </b></font><font color="#008000"><i>{* setup  Regs *}
     {* issue interrupt, returning es:di *}

     {* as we don't have a selector, create one *}
       </i></font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg <font color="#000080">:= </font>AllocSelectors<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">);
       </font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>ofs <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;

     </font><font color="#008000"><i>{* this selector points to no physical address and has size 0 *}
     {* so let the selector point to es:di *}
       </i></font>SetSelectorBase<font color="#000080">(</font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg<font color="#000080">, </font>Regs<font color="#000080">.</font>es<font color="#000080">*</font><font color="#800000">16</font><font color="#000080">+</font>Regs<font color="#000080">.</font>di<font color="#000080">);

     </font><font color="#008000"><i>{* Forgive me! This was a joke. The last statement does not work   *}
     {* of course. Regs.es*16+Regs.di will in the best Cases ({$R+,Q+}</i></font><font color="#000080">) *}
     </font><font color="#008000"><i>{* result in an overflow error. You have to Write:                 *}
       </i></font>SetSelectorBase<font color="#000080">(</font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg<font color="#000080">, </font>Regs<font color="#000080">.</font>es<font color="#000080">*</font>LongInt<font color="#000080">(</font><font color="#800000">16</font><font color="#000080">)+</font>Regs<font color="#000080">.</font>di<font color="#000080">);

     </font><font color="#008000"><i>{* the selector now points to a memory area of size 0 *}
       </i></font>SetSelectorLimit<font color="#000080">(</font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg<font color="#000080">, </font>Regs<font color="#000080">.</font>cx<font color="#000080">);

     </font><font color="#008000"><i>{* we don't have to set the accesrights (code/data, read/Write, etc. *}
     {* as they are almost ok *}

     {* we can now acces this memory using selector p *}
     { &lt;acces block&gt; }

     {* after using it, free selector *}
       </i></font>FreeSelector<font color="#000080">(</font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg<font color="#000080">);
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;


</font>Are there any questions<font color="#000080">? </font>No<font color="#000080">? </font>Let<font color="#800000">'s go ahead than to the next Type of
</font>interrupts<font color="#000080">.

</font>Unsupported interrupts which use the stack
<font color="#000080">------------------------------------------
</font>The second <font color="#FF0000"><b>Type of </b></font>unsupported interrupts are the ones which make use <font color="#FF0000"><b>of
</b></font>the stack<font color="#000080">. </font>We can distinguish between<font color="#000080">:
</font><font color="#800000">1. </font>interrupts which need parameters <font color="#FF0000"><b>on </b></font>the stack
<font color="#800000">2. </font>interrupts which return parameters <font color="#FF0000"><b>on </b></font>the stack

<font color="#800000">1</font><font color="#000080">) </font><font color="#FF0000"><b>For </b></font>the first <font color="#FF0000"><b>Type </b></font>we need <font color="#FF0000"><b>to </b></font>setup a stack<font color="#000080">. </font>There <font color="#FF0000"><b>is </b></font>an extra
   Compilication<font color="#000080">, </font>which I had <font color="#FF0000"><b>not </b></font>told yet<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>the stack <font color="#FF0000"><b>in protected
   </b></font>mode resides <font color="#FF0000"><b>in </b></font>a <font color="#FF0000"><b>protected </b></font>mode segment it <font color="#FF0000"><b>is </b></font>unusable <font color="#FF0000"><b>For </b></font>the Real
   mode interrups<font color="#000080">. </font>So Borland<font color="#800000">'s DPMI Extender switches from the
   </font><font color="#FF0000"><b>protected to </b></font>a Real mode stack <font color="#000080">(</font><font color="#FF0000"><b>and </b></font>back<font color="#000080">). </font>We can supply a <font color="#FF0000"><b>default
   </b></font>Real mode stack <font color="#FF0000"><b>if </b></font>we <font color="#FF0000"><b>set </b></font>the stack Registers <font color="#000080">(</font>ss <font color="#FF0000"><b>and </b></font>sp<font color="#000080">) </font><font color="#FF0000"><b>in </b></font>the Real
   mode <font color="#FF0000"><b>register </b></font>data structure <font color="#FF0000"><b>to </b></font>zero<font color="#000080">. </font><font color="#FF0000"><b>else </b></font>it <font color="#FF0000"><b>is </b></font>assumed that ss<font color="#000080">:</font>sp
   points <font color="#FF0000"><b>to </b></font>a Real mode stack<font color="#000080">. </font>Failure <font color="#FF0000"><b>to set </b></font>them up properly could
   have disastrous results<font color="#000080">!

   </font>We will have <font color="#FF0000"><b>to do</b></font><font color="#000080">:
   </font><font color="#800000">1</font><font color="#000080">) </font>create a Real mode stack using GlobalDosAlloc
   <font color="#800000">2</font><font color="#000080">) </font>fill this stack <font color="#FF0000"><b>With </b></font>values
   <font color="#800000">3</font><font color="#000080">) </font><font color="#FF0000"><b>set </b></font>ss <font color="#FF0000"><b>and </b></font>sp properly
   <font color="#800000">4</font><font color="#000080">) </font>issue interrupt

   All <font color="#FF0000"><b>in </b></font>one example <font color="#FF0000"><b>Program</b></font><font color="#000080">. </font>The following <font color="#FF0000"><b>Program </b></font>sets DesqView<font color="#800000">'s
   </font>mouse <font color="#FF0000"><b>on </b></font>a given location <font color="#FF0000"><b>on </b></font>the screen<font color="#000080">. </font>The supplied handle <font color="#FF0000"><b>is </b></font>the
   handle <font color="#FF0000"><b>of </b></font>the mouse<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>DesqView needs dWord values <font color="#FF0000"><b>on </b></font>the stack I
   allocated a LongIntArray stack which <font color="#FF0000"><b>is </b></font>defined <font color="#FF0000"><b>as</b></font><font color="#000080">:

     </font><font color="#FF0000"><b>Const
       </b></font>MaxLongIntArray <font color="#000080">= </font><font color="#800000">1000</font><font color="#000080">;
     </font><font color="#FF0000"><b>Type
       </b></font>PLongIntArray <font color="#000080">= ^</font>TLongIntArray<font color="#000080">;
       </font>TLongIntArray <font color="#000080">= </font><font color="#FF0000"><b>Array </b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>MaxLongIntArray<font color="#000080">] </font><font color="#FF0000"><b>of </b></font>LongInt<font color="#000080">;

   </font>The example <font color="#FF0000"><b>Program</b></font><font color="#000080">:

     </font><font color="#FF0000"><b>Procedure </b></font>SetMouse<font color="#000080">(</font>Handle<font color="#000080">, </font>x<font color="#000080">, </font>y <font color="#000080">: </font>LongInt<font color="#000080">);
     </font><font color="#FF0000"><b>Const
       </b></font>StackSize <font color="#000080">= </font><font color="#800000">3</font><font color="#000080">*</font>Sizeof<font color="#000080">(</font>LongInt<font color="#000080">);
     </font><font color="#FF0000"><b>Var
       </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">;
       </font>Stack <font color="#000080">: </font>PLongIntArray<font color="#000080">;
       </font>l <font color="#000080">: </font>LongInt<font color="#000080">;
     </font><font color="#FF0000"><b>begin
     </b></font><font color="#008000"><i>{* clear all Registers *}
       </i></font>FillChar<font color="#000080">(</font>Regs<font color="#000080">, </font>Sizeof<font color="#000080">(</font>TRealModeRegs<font color="#000080">), </font><font color="#800000">0</font><font color="#000080">);

     </font><font color="#008000"><i>{* setup the Registers *}
       </i></font>Regs<font color="#000080">.</font>ax <font color="#000080">:= </font><font color="#800000">$1200</font><font color="#000080">;
       </font>Regs<font color="#000080">.</font>bx <font color="#000080">:= </font><font color="#800000">$0500</font><font color="#000080">;

     </font><font color="#008000"><i>{* allocate the stack *}
       </i></font>l <font color="#000080">:= </font>GlobalDosAlloc<font color="#000080">(</font>StackSize<font color="#000080">);

     </font><font color="#008000"><i>{* set stacksegment register sp. ss should be set to the bottom of *}
     {* the stack = 0 *}
       </i></font>Regs<font color="#000080">.</font>sp <font color="#000080">:= </font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Hi<font color="#000080">;
       </font>Stack <font color="#000080">:= </font>Ptr<font color="#000080">(</font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Lo<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">);

     </font><font color="#008000"><i>{* fill the stack *}
       </i></font>Stack<font color="#000080">^[</font><font color="#800000">0</font><font color="#000080">] := </font>Handle<font color="#000080">;
       </font>Stack<font color="#000080">^[</font><font color="#800000">1</font><font color="#000080">] := </font>y<font color="#000080">;
       </font>Stack<font color="#000080">^[</font><font color="#800000">2</font><font color="#000080">] := </font>x<font color="#000080">;

     </font><font color="#008000"><i>{* issue the interrupt *}
       </i></font>RealModeInt<font color="#000080">(</font><font color="#800000">$15</font><font color="#000080">, </font>Regs<font color="#000080">);

     </font><font color="#008000"><i>{* free the stack *}
       </i></font>GlobalDosFree<font color="#000080">(</font>PtrRec<font color="#000080">(</font>Stack<font color="#000080">).</font>Seg<font color="#000080">);
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#800000">2</font><font color="#000080">) </font>Looks much like solution above<font color="#000080">. </font><font color="#FF0000"><b>if </b></font>only values are returned <font color="#FF0000"><b>on </b></font>the
   stack<font color="#000080">. </font>Don<font color="#800000">'t Forget to set sp to the top of the stack. In the above
   </font>example settings Regs<font color="#000080">.</font>sp <font color="#000080">:= </font>StackSize<font color="#000080">;
       </font>An example <font color="#FF0000"><b>is </b></font>given below<font color="#000080">, </font>where a solution <font color="#FF0000"><b>to </b></font>my original
   problem <font color="#FF0000"><b>is </b></font>given<font color="#000080">.


</font>Solution <font color="#FF0000"><b>For </b></font>the dv_win_me <font color="#FF0000"><b>Procedure</b></font><font color="#000080">:

  </font><font color="#FF0000"><b>Uses </b></font>DVAPI<font color="#000080">, </font>Objects<font color="#000080">, </font>WinApi<font color="#000080">, </font>WinTypes<font color="#000080">, </font>DPMI<font color="#000080">;

  </font><font color="#FF0000"><b>Function </b></font>dv_win_me <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#FF0000"><b>Const
    </b></font>StackSize <font color="#000080">= </font>Sizeof<font color="#000080">(</font>LongInt<font color="#000080">);
  </font><font color="#FF0000"><b>Var
    </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">;
    </font>RealStackSeg <font color="#000080">: </font>Word<font color="#000080">;
    </font>RealStackSel <font color="#000080">: </font>Word<font color="#000080">;
    </font>l <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#FF0000"><b>begin
  </b></font><font color="#008000"><i>{* clear all Registers *}
    </i></font>FillChar<font color="#000080">(</font>Regs<font color="#000080">, </font>Sizeof<font color="#000080">(</font>TRealModeRegs<font color="#000080">), </font><font color="#800000">#0</font><font color="#000080">);

  </font><font color="#008000"><i>{* allocate a 1 dWord stack *}
    </i></font>l <font color="#000080">:= </font>GlobalDosAlloc<font color="#000080">(</font>StackSize<font color="#000080">);
    </font>RealStackSeg <font color="#000080">:= </font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Hi<font color="#000080">;
    </font>RealStackSel <font color="#000080">:= </font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Lo<font color="#000080">;

  </font><font color="#008000"><i>{* clear the stack (not necessary) *}
    </i></font>FillChar<font color="#000080">(</font>Ptr<font color="#000080">(</font>RealStackSel<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">)^, </font>StackSize<font color="#000080">, </font><font color="#800000">#0</font><font color="#000080">);

  </font><font color="#008000"><i>{* set Registers *}
    </i></font><font color="#FF0000"><b>With </b></font>Regs <font color="#FF0000"><b>do  begin
      </b></font>bx <font color="#000080">:= </font><font color="#800000">$0001</font><font color="#000080">;
      </font>ah <font color="#000080">:= </font><font color="#800000">$12</font><font color="#000080">;
      </font>ss <font color="#000080">:= </font>RealStackSeg<font color="#000080">;
      </font>sp <font color="#000080">:= </font>StackSize<font color="#000080">;
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ of With }

  {* perForm Real mode interrupt *}
    </i></font>RealModeInt<font color="#000080">(</font><font color="#800000">$15</font><font color="#000080">, </font>Regs<font color="#000080">);
    </font>dv_win_me <font color="#000080">:= </font>PLongInt<font color="#000080">(</font>Ptr<font color="#000080">(</font>RealStackSel<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">))^;

  </font><font color="#008000"><i>{* free the stack *}
    </i></font>GlobalDosFree<font color="#000080">(</font>PtrRec<font color="#000080">(</font>RealStackSel<font color="#000080">).</font>Seg<font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>begin
    </b></font>Writeln<font color="#000080">(</font>dv_win_me<font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">.


</font>You see<font color="#000080">, </font>code size bloats <font color="#FF0000"><b>in protected </b></font>mode<font color="#000080">! (</font>ThereFore Borland gave us
<font color="#800000">16</font>MB<font color="#000080">....)


</font>Appendix A<font color="#000080">.
-----------

</font><font color="#FF0000"><b>As </b></font>promised<font color="#000080">, </font>some routines I found usefull when working <font color="#FF0000"><b>With </b></font>Real mode
segments<font color="#000080">.

====================</font>cut here<font color="#000080">====================
</font><font color="#FF0000"><b>Unit </b></font>DPMIUtil<font color="#000080">;

</font><font color="#FF0000"><b>Interface

Uses </b></font>Objects<font color="#000080">, </font>DPMI<font color="#000080">;

</font><font color="#FF0000"><b>Const
  </b></font>MaxLongIntArray <font color="#000080">= </font><font color="#800000">1000</font><font color="#000080">;
</font><font color="#FF0000"><b>Type
</b></font><font color="#008000"><i>{* this Type is usefull For DesqView stacks *}
  </i></font>PLongIntArray <font color="#000080">= ^</font>TLongIntArray<font color="#000080">;
  </font>TLongIntArray <font color="#000080">= </font><font color="#FF0000"><b>Array </b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>MaxLongIntArray<font color="#000080">] </font><font color="#FF0000"><b>of </b></font>LongInt<font color="#000080">;


</font><font color="#008000"><i>{* clear all Registers to zero *}

</i></font><font color="#FF0000"><b>Procedure </b></font>ClearRegs<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">);

</font><font color="#008000"><i>{* allocate memory using GlobalDosAlloc and split the returned *}
{* LongInt into a protected mode Pointer and a Real mode segment *}

</i></font><font color="#FF0000"><b>Function  </b></font>XGlobalDosAlloc<font color="#000080">(</font>Size <font color="#000080">: </font>LongInt<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>RealSeg <font color="#000080">: </font>Word<font color="#000080">) : </font>Pointer<font color="#000080">;

</font><font color="#008000"><i>{* free memory *}

</i></font><font color="#FF0000"><b>Procedure </b></font>XGlobalDosFree<font color="#000080">(</font>p <font color="#000080">: </font>Pointer<font color="#000080">);


</font><font color="#FF0000"><b>Implementation

Uses </b></font>WinAPI<font color="#000080">;

</font><font color="#FF0000"><b>Procedure </b></font>ClearRegs<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">);
</font><font color="#FF0000"><b>begin
  </b></font>FillChar<font color="#000080">(</font>Regs<font color="#000080">, </font>Sizeof<font color="#000080">(</font>TRealModeRegs<font color="#000080">), </font><font color="#800000">0</font><font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Function  </b></font>XGlobalDosAlloc<font color="#000080">(</font>Size <font color="#000080">: </font>LongInt<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>RealSeg <font color="#000080">: </font>Word<font color="#000080">) : </font>Pointer<font color="#000080">;
</font><font color="#FF0000"><b>Var
  </b></font>l <font color="#000080">: </font>LongInt<font color="#000080">;
</font><font color="#FF0000"><b>begin
  </b></font>l <font color="#000080">:= </font>GlobalDosAlloc<font color="#000080">(</font>Size<font color="#000080">);
  </font>RealSeg <font color="#000080">:= </font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Hi<font color="#000080">;
  </font>XGlobalDosAlloc <font color="#000080">:= </font>Ptr<font color="#000080">(</font>LongRec<font color="#000080">(</font>l<font color="#000080">).</font>Lo<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Procedure </b></font>XGlobalDosFree<font color="#000080">(</font>p <font color="#000080">: </font>Pointer<font color="#000080">);
</font><font color="#FF0000"><b>begin
  </b></font>GlobalDosFree<font color="#000080">(</font>PtrRec<font color="#000080">(</font>p<font color="#000080">).</font>Seg<font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>end</b></font><font color="#000080">.  </font><font color="#008000"><i>{ of Unit DPMIUtil }
</i></font><font color="#000080">====================</font>cut here<font color="#000080">====================


</font>Example code how <font color="#FF0000"><b>to </b></font>use it<font color="#000080">. </font>The above dv_win_me routine would look like<font color="#000080">:

  </font><font color="#FF0000"><b>Uses </b></font>DVAPI<font color="#000080">, </font>Objects<font color="#000080">, </font>WinApi<font color="#000080">, </font>WinTypes<font color="#000080">, </font>DPMI<font color="#000080">;

  </font><font color="#FF0000"><b>Function </b></font>dv_win_me <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#FF0000"><b>Const
    </b></font>StackSize <font color="#000080">= </font>Sizeof<font color="#000080">(</font>LongInt<font color="#000080">);
  </font><font color="#FF0000"><b>Var
    </b></font>Regs <font color="#000080">: </font>TRealModeRegs<font color="#000080">;
    </font>Stack <font color="#000080">: </font>PLongIntArray<font color="#000080">;
  </font><font color="#FF0000"><b>begin
  </b></font><font color="#008000"><i>{* clear all Registers *}
    </i></font>ClearReges<font color="#000080">(</font>Regs<font color="#000080">);

  </font><font color="#008000"><i>{* allocate a 1 dWord stack *}
    </i></font>Stack <font color="#000080">:= </font>XGlobalDosAlloc<font color="#000080">(</font>StackSize<font color="#000080">, </font>Regs<font color="#000080">.</font>ss<font color="#000080">);

  </font><font color="#008000"><i>{* set Registers *}
    </i></font>Regs<font color="#000080">.</font>bx <font color="#000080">:= </font><font color="#800000">$0001</font><font color="#000080">;
    </font>Regs<font color="#000080">.</font>ah <font color="#000080">:= </font><font color="#800000">$12</font><font color="#000080">;
    </font>Regs<font color="#000080">.</font>sp <font color="#000080">:= </font>StackSize<font color="#000080">;

  </font><font color="#008000"><i>{* perForm Real mode interrupt *}
    </i></font>RealModeInt<font color="#000080">(</font><font color="#800000">$15</font><font color="#000080">, </font>Regs<font color="#000080">);
    </font>dv_win_me <font color="#000080">:= </font>Stack<font color="#000080">^[</font><font color="#800000">0</font><font color="#000080">];

  </font><font color="#008000"><i>{* free the stack *}
    </i></font>XGlobalDosFree<font color="#000080">(</font>Stack<font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>begin
    </b></font>Writeln<font color="#000080">(</font>dv_win_me<font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font>Compare this <font color="#FF0000"><b>to </b></font>the previous code<font color="#000080">. </font>It just looks a bit prettier
according <font color="#FF0000"><b>to </b></font>my honest opininion<font color="#000080">.


</font>Conclusion
<font color="#000080">----------

</font><font color="#FF0000"><b>As </b></font>you saw<font color="#000080">, </font>the switch from Real <font color="#FF0000"><b>to protected </b></font>mode may be rather
painfull<font color="#000080">. </font>I hope <font color="#FF0000"><b>With </b></font>the above examples <font color="#FF0000"><b>and </b></font>explanations you can make
it a bit more enjoyable<font color="#000080">. </font>One question remains<font color="#000080">: </font>why did Borland <font color="#FF0000"><b>not
</b></font>clearly told us so<font color="#000080">? </font>Why <font color="#FF0000"><b>not </b></font>present a few examples<font color="#000080">, </font>warnings<font color="#000080">, </font>etc<font color="#000080">.?
</font>Maybe RiChard Nelson can answer this questions <font color="#FF0000"><b>For </b></font>us<font color="#000080">. </font>Everything he
says <font color="#FF0000"><b>is </b></font>his <font color="#FF0000"><b>private </b></font>opinion <font color="#FF0000"><b>of </b></font>course<font color="#000080">, </font>but a look <font color="#FF0000"><b>in </b></font>the kitchen could
be worthWhile<font color="#000080">.

</font><font color="#FF0000"><b>if </b></font>you still have questions<font color="#000080">, </font>I<font color="#800000">'m willing to answer them in either
</font>usenet<font color="#800000">'s Comp.LANG.PASCAL or fidonet'</font>s <font color="#FF0000"><b>PASCAL</b></font><font color="#000080">.</font><font color="#800000">028 </font><font color="#FF0000"><b>or PASCAL</b></font><font color="#000080">. </font>I can<font color="#800000">'t
</font>port your <font color="#FF0000"><b>library of </b></font>course but <font color="#FF0000"><b>if </b></font>the inFormation presented here <font color="#FF0000"><b>is not
</b></font>enough<font color="#000080">, </font>just ask<font color="#000080">.



</font>References
<font color="#000080">----------
- </font>The usual Borland <font color="#FF0000"><b>set of </b></font>handbooks

<font color="#000080">- &quot;</font>Borland Open Architecture Handbook <font color="#FF0000"><b>For Pascal</b></font><font color="#000080">&quot;, </font>sold separately by
Borland<font color="#000080">,
  </font><font color="#800000">184 </font>pages<font color="#000080">.

- &quot;</font>Extending Dos<font color="#000080">, </font>a Programmer<font color="#800000">'s Guide to protected-mode Dos&quot;, Ray
  </font>Duncan<font color="#000080">, </font>Charles Petzold<font color="#000080">, </font>andrew Schulman<font color="#000080">, </font>M<font color="#000080">. </font>Steven Baker<font color="#000080">, </font>Ross P<font color="#000080">.
  </font>Nelson<font color="#000080">, </font>Stephen R<font color="#000080">. </font>Davis <font color="#FF0000"><b>and </b></font>Robert Moote<font color="#000080">. </font>Addison<font color="#000080">-</font>Wesly<font color="#000080">, </font><font color="#800000">1992.
  </font>ISBN<font color="#000080">: </font><font color="#800000">0</font><font color="#000080">-</font><font color="#800000">201</font><font color="#000080">-</font><font color="#800000">56798</font><font color="#000080">-</font><font color="#800000">9

</font><font color="#000080">- &quot;</font>PC Magazine Programmer<font color="#800000">'s Technical Reference: The Processor and
   </font>Coprocessor<font color="#000080">&quot;, </font>Robert L<font color="#000080">. </font>Hummel<font color="#000080">. </font>Ziff<font color="#000080">-</font>Davis Press<font color="#000080">, </font><font color="#800000">1992.
  </font>ISBN<font color="#000080">: </font><font color="#800000">1</font><font color="#000080">-</font><font color="#800000">56276</font><font color="#000080">-</font><font color="#800000">016</font><font color="#000080">-</font><font color="#800000">5


  </font><font color="#008000"><i>{ Dunno if this came before or after this message :) }

</i></font>Hello Protectors<font color="#000080">,

</font><font color="#FF0000"><b>of </b></font>course<font color="#000080">, </font>a few hours after my <font color="#FF0000"><b>message </b></font>has been released <font color="#FF0000"><b>to </b></font>the net<font color="#000080">,
</font>bugfixes seem necessary <font color="#000080">)-:

</font>Some minor bugfixes<font color="#000080">:

* </font><font color="#FF0000"><b>In </b></font>the example about allocating memory below the <font color="#800000">1</font>MB<font color="#000080">, </font>memory <font color="#FF0000"><b>is
  </b></font>allocated but <font color="#FF0000"><b>not </b></font>released<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>we have only <font color="#800000">1</font>MB down their<font color="#000080">, </font>this can
  become a problem <font color="#000080">;-)
  </font>Fix<font color="#000080">:  </font>adding the statement
    GlobalDosFree<font color="#000080">(</font>RealModeSel<font color="#000080">);
  </font>will clean things up

 <font color="#000080">* </font>The solution <font color="#FF0000"><b>to </b></font>interrupts which <font color="#FF0000"><b>requires </b></font>parameters passed <font color="#FF0000"><b>on </b></font>the
  stack has a bug<font color="#000080">. </font>The
    les  di<font color="#000080">,</font>Regs
  statement does <font color="#FF0000"><b>not </b></font>work <font color="#FF0000"><b>of </b></font>course<font color="#000080">. </font>Replace by
    mov  di<font color="#000080">,</font>ofFSET Regs
    mov  dx<font color="#000080">,</font>SEG Regs
    mov  es<font color="#000080">,</font>dx
  This does <font color="#FF0000"><b>not </b></font>work when Regs <font color="#FF0000"><b>is </b></font>declared <font color="#FF0000"><b>in </b></font>the stack segment <font color="#000080">(</font>well
  done Borland<font color="#000080">....), </font>you encounter bug number <font color="#800000">16</font><font color="#000080">, </font>just <font color="#FF0000"><b>as </b></font>I did<font color="#000080">.... (</font>see
  next <font color="#FF0000"><b>message</b></font><font color="#000080">)


</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0004.PAS">Original</a><b>]</b></p></body>
</html>
