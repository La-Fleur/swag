<html>
<head><title> "OVERSIZE.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0012.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#FF0000"><b>Unit </b></font>Oversize<font color="#000080">;

</font><font color="#008000"><i>{  Author:  Trevor J Carlsen
            Algorithm Enterprises Pty Ltd
            PO Box 568
            Port Hedland  6721
            Western Australia
            Telephone:  (Voice)  +61 [0]91 73 2026
                        (Data )  +61 [0]91 73 2569
                        
  Released into the Public Domain 1991.

  An Unit that will enable logical Arrays to be created using up to the amount 
  of heap memory available.

  The line marked (**) MUST be altered to reflect the Type of data in big 
  Array and the Unit MUST be reCompiled after this change.

  No provision is made in this Unit For recovering the memory used by the big 
  Array as the intention was to keep it appearing to the Programmer as close 
  as possible to static Type global Variables.

  Bear in mind that you do not declare your Array anywhere using this Unit.  
  That is all handled automatically.  All you have to do is give the global 
  Variable MaxElements a value With the number of elements you want in the 
  Array and then call the Procedure initialise.  From then on your Array is 
  called data^. (Actually it is called nothing as it is dynamic and is 
  referenced via the Pointer &quot;data&quot; but if you think of it as being called 
  &quot;data^&quot; you don't even need to know how Pointers work!)

  The Array, using this Unit, can only be singly dimensioned although there is 
  no reason why the Unit could not be hacked to allow multi-dimensions.
  
 }

</i></font><font color="#FF0000"><b>Interface

Type
</b></font><font color="#008000"><i>(**)  </i></font>DataType <font color="#000080">= </font>LongInt<font color="#000080">;   </font><font color="#008000"><i>{ change to whatever Type you want For the Array }
  </i></font>bigArray <font color="#000080">= </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">0</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>DataType<font color="#000080">;
  </font>bigptr   <font color="#000080">= ^</font>bigArray<font color="#000080">;
</font><font color="#FF0000"><b>Var
  </b></font>data <font color="#000080">: </font>bigptr<font color="#000080">;
  </font>MaxElements <font color="#000080">: </font>LongInt<font color="#000080">;    </font><font color="#008000"><i>{ this Variable must have the number of elements }

{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Function </b></font>Element<font color="#000080">(</font>l<font color="#000080">:</font>LongInt<font color="#000080">):</font>Byte<font color="#000080">;
  
  </font><font color="#008000"><i>{ Call by passing the element number you wish to reference.                }
  { Always returns zero.  It works by changing the value of the Pointer      }
  { data.  This means that you cannot ever reference your big Array by       }
  {   data^[100000] := whatever;                                             }
  { It MUST always be referenced by calling this Function eg.                }
  {   data^[Element(100000)] := whatever;                                    }
 

{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Function </b></font>AllocateMem<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>b<font color="#000080">,</font>l<font color="#000080">): </font>Boolean<font color="#000080">;
  
  </font><font color="#008000"><i>{ Returns True if memory was allocated successfully For the big Array and  }
  { False if there was insufficient memory.                                  }

{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Procedure </b></font>Initialise<font color="#000080">;  </font><font color="#008000"><i>{ Must be called beFore using any other Procedure     }

{============================================================================}

</i></font><font color="#FF0000"><b>Implementation

</b></font><font color="#008000"><i>{============================================================================}
{ private declarations }

</i></font><font color="#FF0000"><b>Const
  </b></font>max          <font color="#000080">= </font><font color="#800000">65520 </font><font color="#FF0000"><b>div </b></font>sizeof<font color="#000080">(</font>dataType<font color="#000080">);</font><font color="#008000"><i>{ The number of elements/segment }
  </i></font>initialised  <font color="#000080">: </font>Boolean <font color="#000080">= </font>False<font color="#000080">;
  
</font><font color="#FF0000"><b>Type
  </b></font>address  <font color="#000080">=  </font><font color="#FF0000"><b>Record                     </b></font><font color="#008000"><i>{ allows arithmetic on the Pointers }
                </i></font>offset<font color="#000080">,
                </font>segment <font color="#000080">: </font>Word<font color="#000080">;
              </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font>baseArray <font color="#000080">= </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">9</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>address<font color="#000080">;    </font><font color="#008000"><i>{ For the addresses of the segments }

</i></font><font color="#FF0000"><b>Var
  </b></font>base <font color="#000080">: </font>baseArray<font color="#000080">;
  

</font><font color="#008000"><i>{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Function </b></font>Element<font color="#000080">(</font>l<font color="#000080">:</font>LongInt<font color="#000080">):</font>Byte<font color="#000080">;

  </font><font color="#FF0000"><b>Var
    </b></font>theaddress <font color="#000080">: </font>address <font color="#FF0000"><b>Absolute </b></font>data<font color="#000080">;
    </font>bigaddress <font color="#000080">: </font>baseArray <font color="#FF0000"><b>Absolute </b></font>base<font color="#000080">;

  </font><font color="#FF0000"><b>begin
    
    </b></font><font color="#008000"><i>{ First make sure that initialisation has been done correctly            }
    </i></font><font color="#FF0000"><b>if not </b></font>initialised <font color="#FF0000"><b>then begin 
      </b></font>Writeln<font color="#000080">(</font><font color="#800000">'Initialise Procedure has not been called'</font><font color="#000080">);
      </font>halt<font color="#000080">(</font><font color="#800000">254</font><font color="#000080">);
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ if not initialised }
    
    </i></font>Element <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">; </font><font color="#008000"><i>{ It is Really irrelevent but any other value here would   }
                  { produce a range check error at runtime if R+             }
    
    { Now let us fool TP into thinking that the address of element zero is   }
    { address of the element we are looking For.                             }
    </i></font><font color="#FF0000"><b>With </b></font>theaddress <font color="#FF0000"><b>do begin
      </b></font>segment <font color="#000080">:= </font>bigaddress<font color="#000080">[</font>l <font color="#FF0000"><b>div </b></font>max<font color="#000080">].</font>segment<font color="#000080">;            </font><font color="#008000"><i>{ Get the segment }
      </i></font>offset  <font color="#000080">:= (</font>l <font color="#FF0000"><b>mod </b></font>max<font color="#000080">) * </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">);            </font><font color="#008000"><i>{ Get the offset }
    </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ With theaddress }
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ ElementNumber }

{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Function </b></font>AllocateMem<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>b<font color="#000080">,</font>l<font color="#000080">): </font>Boolean<font color="#000080">;
  
  </font><font color="#FF0000"><b>Type
    </b></font>ptrArray <font color="#000080">= </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">9</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>Pointer<font color="#000080">;
  </font><font color="#FF0000"><b>Var
    </b></font>bArray<font color="#000080">: </font>ptrArray <font color="#FF0000"><b>Absolute </b></font>b<font color="#000080">;
    </font>x     <font color="#000080">: </font>Byte<font color="#000080">;
    </font>count <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#FF0000"><b>begin
    </b></font>count <font color="#000080">:= </font>MaxElements<font color="#000080">;
    </font>AllocateMem <font color="#000080">:= </font>True<font color="#000080">;
    </font><font color="#FF0000"><b>For </b></font>x <font color="#000080">:= </font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#000080">(</font>count <font color="#FF0000"><b>div </b></font>max<font color="#000080">) </font><font color="#FF0000"><b>do     </b></font><font color="#008000"><i>{ allocate in 64K contiguous chunks }
      </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>count <font color="#000080">* </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">)) &gt; </font><font color="#800000">65520 </font><font color="#FF0000"><b>then begin
        if </b></font>MaxAvail <font color="#000080">&lt; (</font>max <font color="#000080">* </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">)) </font><font color="#FF0000"><b>then begin </b></font><font color="#008000"><i>{ not enough memory} 
          </i></font>dec<font color="#000080">(</font>count<font color="#000080">,</font>max<font color="#000080">);
          </font>AllocateMem <font color="#000080">:= </font>False<font color="#000080">;
        </font><font color="#FF0000"><b>end 
        else
          </b></font>GetMem<font color="#000080">(</font>bArray<font color="#000080">[</font>x<font color="#000080">],</font>max <font color="#000080">* </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">));
      </font><font color="#FF0000"><b>end
      else
        if </b></font>MaxAvail <font color="#000080">&lt; (</font>count <font color="#000080">* </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">)) </font><font color="#FF0000"><b>then
           </b></font>AllocateMem <font color="#000080">:= </font>False
        <font color="#FF0000"><b>else
           </b></font>GetMem<font color="#000080">(</font>bArray<font color="#000080">[</font>x<font color="#000080">],</font>count <font color="#000080">* </font>sizeof<font color="#000080">(</font>dataType<font color="#000080">)); 
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ AllocateMem }
  
{----------------------------------------------------------------------------}
</i></font><font color="#FF0000"><b>Procedure </b></font>Initialise<font color="#000080">;
  </font><font color="#FF0000"><b>begin
    </b></font>FillChar<font color="#000080">(</font>base<font color="#000080">,</font>sizeof<font color="#000080">(</font>base<font color="#000080">),</font><font color="#800000">0</font><font color="#000080">);
    </font><font color="#FF0000"><b>if not </b></font>AllocateMem<font color="#000080">(</font>base<font color="#000080">,</font>MaxElements<font color="#000080">) </font><font color="#FF0000"><b>then begin
      </b></font>Writeln<font color="#000080">(</font><font color="#800000">'Insufficient memory'</font><font color="#000080">);
      </font>halt<font color="#000080">(</font><font color="#800000">255</font><font color="#000080">);
    </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font>initialised <font color="#000080">:= </font>True<font color="#000080">;              </font><font color="#008000"><i>{ All Ok and memory has been allocated }
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Initialise }
  
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">.  </font><font color="#008000"><i>{ Unit Oversize 
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0012.PAS">Original</a><b>]</b></p></body>
</html>
