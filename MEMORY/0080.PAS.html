<html>
<head><title> "Managing The Stack" by BOB SWART</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0080.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
From: bobs@dragons.nest.nl (Bob Swart)

&gt; I need some advice on managing the stack.
Read The Pascal Magazine issue #4 (Borland Pascal Efficiency on speed vs.
size) - a long excerpt will follow to make up for this plug:

&gt; I was taught that it is good form to use locally declared variables
&gt; in a procedure rather than manipulating global variables from
&gt; within a procedure. Well, this seems to be causing some problems for
&gt; me.

Yes, this eats up stack. Your string handling routine will probably eat up
stack also, as I'll point out a little further down...

&gt;   What are some good strategies to use to manage the stack? How can
&gt;   prevent these stack overflow errors without having to increase the
&gt;   size of the stack...

The stack is often a soft spot of many applications. Generally, it's best to
specify a large stack size (like 32Kbytes) unless you have specific reasons not
to do so. The most annoying thing about the stack it that it's often hard to
see how much is actually used by a specific &quot;run&quot; of your program (and hence,
how much was still free). The following unit can be used to check for the
minimum value of the Stack Pointer:
}

{$A+,B-,D-,E-,F-,G-,I-,L-,N-,O-,P-,Q-,R-,S-,T-,V-,X-}
</i></font><font color="#FF0000"><b>unit </b></font>stack<font color="#000080">;
</font><font color="#FF0000"><b>interface
Const
  </b></font>MinStack<font color="#000080">: </font>Word <font color="#000080">= </font><font color="#800000">$FFFF</font><font color="#000080">;
  </font>NumProbe<font color="#000080">: </font>Word <font color="#000080">= </font><font color="#800000">$0000</font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>StackProbe<font color="#000080">;

</font><font color="#FF0000"><b>implementation
uses </b></font>Dos<font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>StackProbe<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
  </font><font color="#FF0000"><b>ASM
        </b></font><font color="#FF00FF">inc   NumProbe </font><font color="#008000"><i>{ only count REAL probes }
        </i></font><font color="#FF00FF">cmp   SP,MinStack
        jnb   @Exit
        mov   MinStack,SP
 @Exit:
  </font><font color="#FF0000"><b>end </b></font><font color="#008000"><i>{StackProbe}</i></font><font color="#000080">;

</font><font color="#FF0000"><b>Const
  </b></font>OurOwnSS<font color="#000080">: </font>Word <font color="#000080">= </font><font color="#800000">0</font><font color="#000080">;
  </font>SaveExit<font color="#000080">: </font>pointer <font color="#000080">= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
  </font>OldInt08<font color="#000080">: </font>pointer <font color="#000080">= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>NewInt08<font color="#000080">; </font>interrupt<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
  </font><font color="#FF0000"><b>ASM
        </b></font><font color="#FF00FF">mov   AX,SS
        cmp   OurOwnSS,AX
        jne   @Exit
        inc   NumProbe </font><font color="#008000"><i>{ only count REAL probes }
        </i></font><font color="#FF00FF">cmp   SP,MinStack
        jnb   @Exit
        mov   MinStack,SP
 @Exit:
        pushF
        call  DWORD PTR [OldInt08] </font><font color="#008000"><i>{ goto original int $08 handler }
  </i></font><font color="#FF0000"><b>end </b></font><font color="#008000"><i>{NewInt8}</i></font><font color="#000080">;

  </font><font color="#FF0000"><b>procedure </b></font>NewExit<font color="#000080">; </font><font color="#FF0000"><b>far</b></font><font color="#000080">;
  </font><font color="#FF0000"><b>begin
    </b></font>ExitProc <font color="#000080">:= </font>SaveExit<font color="#000080">;
    </font>SetIntVec<font color="#000080">(</font><font color="#800000">$08</font><font color="#000080">, </font>OldInt08<font color="#000080">) </font><font color="#008000"><i>{get old int from code segment}
  </i></font><font color="#FF0000"><b>end </b></font><font color="#008000"><i>{NewExit}</i></font><font color="#000080">;

</font><font color="#FF0000"><b>begin
  ASM
        </b></font><font color="#FF00FF">mov   AX,SS
        mov   OurOwnSS,AX
  </font><font color="#FF0000"><b>end </b></font><font color="#008000"><i>{ TurboSS := SSeg }</i></font><font color="#000080">;
  </font>SaveExit <font color="#000080">:= </font>ExitProc<font color="#000080">;
  </font>GetIntVec<font color="#000080">(</font><font color="#800000">$08</font><font color="#000080">, </font>OldInt08<font color="#000080">);  </font><font color="#008000"><i>{store old int in code segment}
  </i></font>SetIntVec<font color="#000080">(</font><font color="#800000">$08</font><font color="#000080">, @</font>NewInt08<font color="#000080">); </font><font color="#008000"><i>{set int $08 to our ISR}
  </i></font>ExitProc <font color="#000080">:= @</font>NewExit
<font color="#FF0000"><b>end</b></font><font color="#000080">.

</font><font color="#008000"><i>{
&gt;   what can I do that would allow me to use locally declared variables
&gt;   from within a procedure without having to worry about stack overflow??
Stack space is used by calls to routines and their local variables. Stack space
is also used for the variables to procedures and functions. If you want to
preserve stack space, you should take care when using recursive calls.
Recursion may be a very elegant way to implement a solution, it is also
dangerous as it eats your stack. Make sure you always know the maximum depth of
a recursive call!

Furthermore, you should try to avoid passing large structures (like Strings) as
Value parameters to procedures and functions. This will use a lot of stack
space, and will slow down your program as the variable must be copied onto the
stack (and removed from the stack again). Since version 7.0, we can pass
arguments not only by value (which uses a lot of stack space) and by reference
(var parameter) but also by 'constant value', which actually is by reference
but means that you get an error if you try to modify the contents.

Functions returning strings are especially space wasters. For example, suppose
you have a

  Function UpCaseStr(Str: String): String;
  begin
    UpCaseStr := ...
  end;

If you're implementing it in plain Pascal, you'll need 1024 bytes of data at a
minimum:
- 256 bytes are allocated for &quot;Str&quot;, the formal parameter
- 256 bytes for a local copy of &quot;Str&quot; since it was passed as a value parameter
- 256 bytes for a local variable of the type String, working storage to build
the function result
- 256 bytes for assigning the result to the function result (as in: &quot;UpCaseStr
:= Result&quot;).

You can cut this figure by 50% by taking changing the parameter header into
&quot;Function UpCaseStr(Const Str: String): String&quot;. Provided you don't change
&quot;Str&quot;, no local copy of the string will be created. An alternative could be to
implement the routine as a procedure (no result) or in BASM, as BASM routines
always pass String arguments by reference only.

For more information I suggest my regular Pascal Efficiency column in The
Pascal Magazine...
}</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0080.PAS">Original</a><b>]</b></p></body>
</html>
