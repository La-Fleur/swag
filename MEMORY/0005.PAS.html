<html>
<head><title> "FASTMEM.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0005.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#FF0000"><b>Unit </b></font>MEM16<font color="#000080">;
</font><font color="#008000"><i>{
 Author:        Paul VanderSpek
 Date:          03-20-1993

    This source code is being released as Free-Ware.  You may use
  this code in your Programs and modify it to fit your needs. The
  only  restrictions are that you  may not distribute the  source
  code in modified Form or Charge For the source code itself.


}

</i></font><font color="#FF0000"><b>Interface

Procedure </b></font>Move16<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Source<font color="#000080">,</font>Dest<font color="#000080">;</font>Count<font color="#000080">:</font>Word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>FillChar16<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>X<font color="#000080">; </font>Count<font color="#000080">: </font>Word<font color="#000080">; </font>Value<font color="#000080">:</font>Byte<font color="#000080">);

</font><font color="#FF0000"><b>Implementation

Procedure </b></font>Move16<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Source<font color="#000080">,</font>Dest<font color="#000080">;</font>Count<font color="#000080">:</font>Word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
  </b></font><font color="#FF00FF">PUSH DS
  LDS SI,SOURCE
  LES DI,DEST
  MOV AX,COUNT
  MOV CX,AX
  SHR CX,1
  REP MOVSW
  TEST AX,1
  JZ @</font><font color="#FF0000"><b>end
  </b></font>MOVSB
<font color="#000080">@</font><font color="#FF0000"><b>end</b></font><font color="#000080">:</font>POP DS
<font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Procedure </b></font>FillChar16<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>X<font color="#000080">; </font>Count<font color="#000080">: </font>Word<font color="#000080">; </font>Value<font color="#000080">:</font>Byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
  </b></font><font color="#FF00FF">LES DI,X
  MOV CX,COUNT
  SHR CX,1
  MOV AL,ValUE
  MOV AH,AL
  REP StoSW
  TEST COUNT,1
  JZ @</font><font color="#FF0000"><b>end
  </b></font>StoSB
<font color="#000080">@</font><font color="#FF0000"><b>end</b></font><font color="#000080">:
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font><font color="#008000"><i>{
These routines are twice as fast as the normal Move and FillChar routines
sInce they use MOVSW and StoSW instead of MOVSB and StoSB. They work in
exactly the same way, so you can just replace Move and FillChar With them.
}

{
&gt;     This source code is being released as Free-Ware.  You may use
&gt;   this code in your Programs and modify it to fit your needs. The
&gt;   only  restrictions are that you  may not distribute the  source
&gt;   code in modified form or Charge For the source code itself.

I'm sorry to say that I'm not impressed, since hundreds of people already have
invented this wheel.  Besides, your move routine has at least one serious flaw:
it assumes that source and destinaton do not overlap.  Which is not always the
case; if you have a Variable of the Type String as the source, and you want to
copy a few Characters furtheron in this Variable, you'll mess up the result.

&gt;      SHR CX,1
&gt;      REP MOVSW
&gt;      TEST AX,1
&gt;      JZ @end
&gt;      MOVSB
&gt; @end:POP DS

The TEST AX, 1 instruction is superfluous.  If the number of Bytes in the CX
register is odd, the SHR CX, 1 instruction will set the carry bit.  It's more
convenient to test this bit.  Here's how:

         SHR   CX, 1
         JNC   @1
         MOVSB
         REP   MOVSW
    @1:

&gt; Have Fun,

No fun if source and destination overlap, as said earlier.  Here follows a
memory move routine With 16-bit moves and overlap check:
}
</i></font><font color="#FF0000"><b>Procedure </b></font>MoveMem<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>source<font color="#000080">, </font>target<font color="#000080">; </font>size <font color="#000080">: </font>Word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Asm
        </b></font><font color="#FF00FF">PUSH    DS
        LDS     SI, source
        LES     DI, target
        MOV     CX, size
        CLD

    </font><font color="#008000"><i>{ If an overlap of source and target could occur,
      copy data backwards }

        </i></font><font color="#FF00FF">CMP     SI, DI
        JAE     @2

        ADD     SI, CX
        ADD     DI, CX
        DEC     SI
        DEC     DI
        STD

        SHR     CX, 1
        JAE     @1
        MOVSB
@1:     DEC     SI
        DEC     DI
        JMP     @3

@2:     SHR     CX, 1
        JNC     @3
        MOVSB

@3:     REP     MOVSW
        POP     DS
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ MoveMem }


{
&gt; For I := 0 to 200 do
&gt;  Move(Buffer,Mem[$A000:0000],320);

Looks weird to me. Why moving all that stuff 200 times to the first line
of the screen ?

&gt; For I := 100 to 200 do
&gt;  Move(Buffer[320*I],Mem[$A000:(I*320)],320);

This could be done via

Move(Buffer[320*StartLine], Mem[$a000:320*StartLine], 320*NumberOfLines) ;

which should somehow be faster.

Also note that TP's Move Procedure Uses a LODSB instruction, which is
twice as slow as a LODSW instruction on 286+ computers, With big buffers.
So here is a replacement Move proc, which works fine EXCEPT if the two
buffers overlap and destination is at a greater address than source, which
anyway is not the Case here.
}
</i></font><font color="#FF0000"><b>Procedure </b></font>FastMove<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Src<font color="#000080">, </font>Dst <font color="#000080">; </font>Cnt <font color="#000080">: </font>Word<font color="#000080">) ;
</font><font color="#FF0000"><b>Assembler </b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">Mov       DX, DS         </font><font color="#008000"><i>{ Sauvegarde DS }
     </i></font><font color="#FF00FF">Mov       CX, Cnt
     LDS       SI, Src
     LES       DI, Dst
     ClD                      </font><font color="#008000"><i>{ A priori, on va du dbut vers la fin }
     </i></font><font color="#FF00FF">ShR       CX, 1          </font><font color="#008000"><i>{ On va travailler sur des mots }
     </i></font><font color="#FF00FF">Rep       MovSW          </font><font color="#008000"><i>{ Copie des mots }
     </i></font><font color="#FF00FF">JNC       @Done          </font><font color="#008000"><i>{ Pas d'octet restant (Cnt pair) ? }
     </i></font><font color="#FF00FF">MovSB                    </font><font color="#008000"><i>{ Copie dernier octet }
</i></font><font color="#FF00FF">@Done:
     Mov       DS, DX         </font><font color="#008000"><i>{ Restauration DS }
</i></font><font color="#FF0000"><b>end </b></font><font color="#000080">;
</font><font color="#008000"><i>{
Well, just a note : this proc works twice faster than TP's Move _only_ if
Src and Dst are Word aligned, which is the Case if :
- they are Variables allocated on the heap,
- they are declared in the stack,
- $a+ is specified,
- you use it as described in your examples of code :-)
}</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0005.PAS">Original</a><b>]</b></p></body>
</html>
