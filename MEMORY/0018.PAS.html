<html>
<head><title> "Stack Usage Report" by STEVE ROGERS</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0018.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>(*
===========================================================================
 BBS: Canada Remote Systems
Date: 05-30-93 (08:25)             Number: 8026
From: STEVE ROGERS                 Refer#: NONE
  To: PAUL HICKEY                   Recvd: NO  
Subj: HELP PLEASE                    Conf: (1617) L-PASCAL
---------------------------------------------------------------------------
PH&gt; EP&gt; {$M $A,B,C}

PH&gt; I always set A and B to high and C to 0.  I want to allow the most memory I
PH&gt;can to program usage within the 640K limit.

  To get the most ram for your prog to use in the 640k set &quot;B&quot; to 0
  and &quot;C&quot; to 655360. Setting &quot;C&quot; to 0 prevents you from accessing any
  heap at all.

  &quot;A&quot; should be set to the amount of stack your program needs. I have a
  unit that I use to help determine this. It was initially released for
  TP4 but I've used with BP7 OK.

{***********************************************************
  StackUse - A unit to report stack usage information

  by Richard S. Sadowsky
  version 1.0 7/18/88
  released to the public domain

  Inspired by a idea by Kim Kokkonen.

  This unit, when used in a Turbo Pascal 4.0 program, will
  automatically report information about stack usage.  This is very
  useful during program development.  The following information is
  reported about the stack:

  total stack space
  Unused stack space
  Stack spaced used by your program

  The unit's initialization code handles three things, it figures out
  the total stack space, it initializes the unused stack space to a
  known value, and it sets up an ExitProc to automatically report the
  stack usage at termination.  The total stack space is calculated by
  adding 4 to the current stack pointer on entry into the unit.  This
  works because on entry into a unit the only thing on the stack is the
  2 word (4 bytes) far return value.  This is obviously version and
  compiler specific.

  The ExitProc StackReport handles the math of calculating the used and
  unused amount of stack space, and displays this information.  Note
  that the original ExitProc (Sav_ExitProc) is restored immediately on
  entry to StackReport.  This is a good idea in ExitProc in case a
  runtime (or I/O) error occurs in your ExitProc!

  I hope you find this unit as useful as I have!

************************************************************)

{$R-,S-} { we don't need no stinkin range or stack checking! }
</i></font><font color="#FF0000"><b>unit </b></font>StackUse<font color="#000080">;

</font><font color="#FF0000"><b>interface

var
  </b></font>Sav_ExitProc     <font color="#000080">: </font>Pointer<font color="#000080">; </font><font color="#008000"><i>{ to save the previous ExitProc }
  </i></font>StartSPtr        <font color="#000080">: </font>Word<font color="#000080">;    </font><font color="#008000"><i>{ holds the total stack size    }

</i></font><font color="#FF0000"><b>implementation

</b></font><font color="#008000"><i>{$F+} { this is an ExitProc so it must be compiled as far }
</i></font><font color="#FF0000"><b>procedure </b></font>StackReport<font color="#000080">;

</font><font color="#008000"><i>{ This procedure may take a second or two to execute, especially }
{ if you have a large stack. The time is spent examining the     }
{ stack looking for our init value ($AA). }

</i></font><font color="#FF0000"><b>var
  </b></font>I                <font color="#000080">: </font>Word<font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font>ExitProc <font color="#000080">:= </font>Sav_ExitProc<font color="#000080">; </font><font color="#008000"><i>{ restore original exitProc first }

  </i></font>I <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font><font color="#008000"><i>{ step through stack from bottom looking for $AA, stop when found }
  </i></font><font color="#FF0000"><b>while </b></font>I <font color="#000080">&lt; </font>SPtr <font color="#FF0000"><b>do
    if </b></font>Mem<font color="#000080">[</font>SSeg<font color="#000080">:</font>I<font color="#000080">] &lt;&gt; </font><font color="#800000">$AA </font><font color="#FF0000"><b>then begin
      </b></font><font color="#008000"><i>{ found $AA so report the stack usage info }
      </i></font>WriteLn<font color="#000080">(</font><font color="#800000">'total stack space : '</font><font color="#000080">,</font>StartSPtr<font color="#000080">);
      </font>WriteLn<font color="#000080">(</font><font color="#800000">'unused stack space: '</font><font color="#000080">, </font>I<font color="#000080">);
      </font>WriteLn<font color="#000080">(</font><font color="#800000">'stack space used  : '</font><font color="#000080">,</font>StartSPtr <font color="#000080">- </font>I<font color="#000080">);
      </font>I <font color="#000080">:= </font>SPtr<font color="#000080">; </font><font color="#008000"><i>{ end the loop }
    </i></font><font color="#FF0000"><b>end
    else
      </b></font>inc<font color="#000080">(</font>I<font color="#000080">); </font><font color="#008000"><i>{ look in next byte }
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
</font><font color="#008000"><i>{$F-}


</i></font><font color="#FF0000"><b>begin
  </b></font>StartSPtr <font color="#000080">:= </font>SPtr <font color="#000080">+ </font><font color="#800000">4</font><font color="#000080">; </font><font color="#008000"><i>{ on entry into a unit, only the FAR return }
                         { address has been pushed on the stack.     }
                         { therefore adding 4 to SP gives us the     }
                         { total stack size. }
  </i></font>FillChar<font color="#000080">(</font>Mem<font color="#000080">[</font>SSeg<font color="#000080">:</font><font color="#800000">0</font><font color="#000080">], </font>SPtr <font color="#000080">- </font><font color="#800000">20</font><font color="#000080">, </font><font color="#800000">$AA</font><font color="#000080">); </font><font color="#008000"><i>{ init the stack   }
  </i></font>Sav_ExitProc <font color="#000080">:= </font>ExitProc<font color="#000080">;              </font><font color="#008000"><i>{ save exitproc    }
  </i></font>ExitProc     <font color="#000080">:= @</font>StackReport<font color="#000080">;          </font><font color="#008000"><i>{ set our exitproc }
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MEMORY SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0018.PAS">Original</a><b>]</b></p></body>
</html>
