<html>
<head><title> "Direct access to a Stream" by DAVID STIDOLPH</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to DELPHI SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0066.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>(*
If you have the VCL source look at TMemoryStream - it is pretty efficient
for 286 code.  If you are willing to only run on 386 machines you can use
386 32-bit addressing in assembly code to access the data.  Following the
includion I have placed some assembly code I have written to do this.  It
compiles under MASM and is linked with the {$L} directive.  The reason I
wrote this code was for a WinG module I am still working on.  Anyone is
welcome to use this code, but I would like to see work done using it.

&gt;The TMemoryStream has a property TMemoryStream.Memory, which returns a
&gt;pointer to the actual location of the data in memory. To access the 
&gt;first byte I could just use TMemoryStream.Memory^
&gt;
&gt;The problem is: If I want to for example get bytes 15 to 21 out of the
&gt;stream, is there a way to point to the location of this data?
&gt;I do not want to use the Seek/Read function, as this is a lot slower
&gt;than using direct memory access.
*)

{$L move.obj}

</i></font><font color="#FF0000"><b>procedure </b></font>Move32<font color="#000080">(</font>pSrc<font color="#000080">: </font>Pointer<font color="#000080">; </font>srcOffset<font color="#000080">: </font>Longint<font color="#000080">; </font>pDest<font color="#000080">: </font>Pointer<font color="#000080">;
</font>destOffset<font color="#000080">: </font>Longint<font color="#000080">; </font>len<font color="#000080">: </font>Longint<font color="#000080">); </font><font color="#FF0000"><b>external</b></font><font color="#000080">;

</font>Assembly code <font color="#000080">(</font>move<font color="#000080">.</font><font color="#FF0000"><b>asm</b></font><font color="#FF00FF">)
</font>	<font color="#FF00FF">.MODEL large, PASCAL
</font>	<font color="#FF00FF">.386
</font>	<font color="#FF00FF">OPTION SCOPED

LPBYTE TYPEDEF FAR PTR BYTE

Move32 PROTO FAR PASCAL,
</font>		 <font color="#FF00FF">pSrc:LPBYTE, srcOffset:DWORD,
</font>		 <font color="#FF00FF">pDest: LPBYTE, destOffset:DWORD,
</font>		 <font color="#FF00FF">len:DWORD

</font>	<font color="#FF00FF">.Code

Move32</font>	<font color="#FF00FF">PROC FAR PASCAL USES ds es esi edi,
</font>		<font color="#FF00FF">pSrc: LPBYTE, srcOffset:DWORD,
</font>		<font color="#FF00FF">pDest: LPBYTE, destOffset:DWORD,
</font>		<font color="#FF00FF">len:DWORD
</font>	<font color="#FF00FF">cld</font>			<font color="#FF00FF">;move forward through memory
</font>	<font color="#FF00FF">mov</font>	<font color="#FF00FF">esi,0</font>		<font color="#FF00FF">;clear index registers - noteably the top of
</font>	<font color="#FF00FF">mov</font>	<font color="#FF00FF">edi,0</font>		<font color="#FF00FF">;the 32 bit (upper 16 bits) registers.

</font>	<font color="#FF00FF">lds</font>	<font color="#FF00FF">si,pSrc</font>		<font color="#FF00FF">;load ds/si with pointer to base source
</font>	<font color="#FF00FF">les</font>	<font color="#FF00FF">di,pDest</font>	<font color="#FF00FF">;load es/di with pointer to base destination
</font>	<font color="#FF00FF">add</font>	<font color="#FF00FF">esi,srcOffset</font>	<font color="#FF00FF">;add in offset to desired point
</font>	<font color="#FF00FF">add</font>	<font color="#FF00FF">edi,destOffset</font>	<font color="#FF00FF">;add in offset to desired point
</font>	<font color="#FF00FF">mov</font>	<font color="#FF00FF">ecx,len</font>		<font color="#FF00FF">;get the length of the move
</font>	<font color="#FF00FF">shr</font>	<font color="#FF00FF">ecx,2</font>		<font color="#FF00FF">;divide by 4 for DWORD moves
</font>	<font color="#FF00FF">rep</font>	<font color="#FF00FF">movsd</font>		<font color="#FF00FF">;if ecx is zero no move is done
</font>	<font color="#FF00FF">mov</font>	<font color="#FF00FF">ecx,len</font>		<font color="#FF00FF">;pick up length to do remainder
</font>	<font color="#FF00FF">and</font>	<font color="#FF00FF">ecx,3</font>		<font color="#FF00FF">;only move 0-3 bytes
</font>	<font color="#FF00FF">rep</font>	<font color="#FF00FF">movsb</font>		<font color="#FF00FF">;if ecx is zero no move is done
</font>	<font color="#FF00FF">retf</font>			<font color="#FF00FF">;far return
Move32</font>	<font color="#FF00FF">ENDP

</font><font color="#FF0000"><b>END
</b></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to DELPHI SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0066.PAS">Original</a><b>]</b></p></body>
</html>
