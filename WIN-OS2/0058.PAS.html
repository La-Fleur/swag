<html>
<head><title> "Complete Icon Format Explanation" by ALFONS HOOGERVORST</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to WIN-OS2 SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0058.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
Some days ago someone asked me about the icon file format. I will publish
these messages just once. So put it in your archives please :-)
(I don't save my own messages, I never did :).



Header
}
</i></font>TIconHeader <font color="#000080">= </font><font color="#FF0000"><b>record
  </b></font>idReserved<font color="#000080">: </font>Word<font color="#000080">; </font><font color="#008000"><i>(* Always set to 0 *)
  </i></font>idType<font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>(* Always set to 1 *)
  </i></font>idCount<font color="#000080">: </font>Word<font color="#000080">;    </font><font color="#008000"><i>(* Number of icon images *)
  (* immediately followed by idCount TIconDirEntries *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
</font><font color="#008000"><i>{

A .ICO file can contain several icon images. Each image can differ in size,
resolution and color format.

}
</i></font>TIconDirEntry <font color="#000080">= </font><font color="#FF0000"><b>record
  </b></font>bWidth<font color="#000080">: </font>Byte<font color="#000080">;          </font><font color="#008000"><i>(* Width *)
  </i></font>bHeight<font color="#000080">: </font>Byte<font color="#000080">;         </font><font color="#008000"><i>(* Height *)
  </i></font>bColorCount<font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>(* Nr. of colors used, see below *)
  </i></font>bReserved<font color="#000080">: </font>Byte<font color="#000080">;       </font><font color="#008000"><i>(* not used, 0 *)
  </i></font>wPlanes<font color="#000080">: </font>Word<font color="#000080">;         </font><font color="#008000"><i>(* not used, 0 *)
  </i></font>wBitCount<font color="#000080">: </font>Word<font color="#000080">;       </font><font color="#008000"><i>(* not used, 0 *)
  </i></font>dwBytesInRes<font color="#000080">: </font>Longint<font color="#000080">; </font><font color="#008000"><i>(* total number of bytes in images *)
  </i></font>dwImageOffset<font color="#000080">: </font>Longint<font color="#000080">;</font><font color="#008000"><i>(* location of image from the beginning of file *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{
bColorCount refers to the number of palette entries in the image data. For the
most common icon type (32x32 pixels, 16 colors) the first three fields would be
32, 32 and 16 resp.

dwBytesInRes is the total number of bytes in the image data (including palette
data!). dwImageOffset is an offset (from the beginning of the file) to the
image data.


Image data

The icon file stores image data in the so-called device independent bitmap
(DIB) format. It's supposed to be fairly device independent :-). The actual
pixel data is preceded by two &quot;structures&quot;: the bitmap info header and the
palette data.

First the bitmap info header (pasted from the BP WinSDK help, comments are
mine):
}
</i></font>TBitmapInfoHeader <font color="#000080">= </font><font color="#FF0000"><b>record
  </b></font>biSize<font color="#000080">: </font>Longint<font color="#000080">;    </font><font color="#008000"><i>(* sizeof(TBitmapInfoHeader *)
  </i></font>biWidth<font color="#000080">: </font>Longint<font color="#000080">;   </font><font color="#008000"><i>(* width of bitmap *)
  </i></font>biHeight<font color="#000080">: </font>Longint<font color="#000080">;  </font><font color="#008000"><i>(* height of bitmap, see notes *)
  </i></font>biPlanes<font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>(* planes, always 1 *)
  </i></font>biBitCount<font color="#000080">: </font>Word<font color="#000080">;   </font><font color="#008000"><i>(* number of color bits *)
  </i></font>biCompression<font color="#000080">: </font>Longint<font color="#000080">; </font><font color="#008000"><i>(* compression used, 0 *)
  </i></font>biSizeImage<font color="#000080">: </font>Longint<font color="#000080">;   </font><font color="#008000"><i>(* size of the pixel data, see notes *)
  </i></font>biXPelsPerMeter<font color="#000080">: </font>Longint<font color="#000080">; </font><font color="#008000"><i>(* not used, 0 *)
  </i></font>biYPelsPerMeter<font color="#000080">: </font>Longint<font color="#000080">; </font><font color="#008000"><i>(* not used, 0 *)
  </i></font>biClrUsed<font color="#000080">: </font>Longint<font color="#000080">;       </font><font color="#008000"><i>(* nr of colors used, set to 0 *)
  </i></font>biClrImportant<font color="#000080">: </font>Longint<font color="#000080">;  </font><font color="#008000"><i>(* important colors, set to 0 *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{
biBitcount contains the number of color bits per pixel. If it's 4, it means a
pixel can have 16 colors (2 shl 4). biBitcount also refers to how a pixel is
&quot;coded&quot; in the pixel data. If biBitcount is 4 a pixel takes 4 bits of an image
byte. If it's 8 (256 possible colors), a pixel is a byte.

As you perhaps know, icons are created by combining two bitmap masks: the
XOR-mask and the monochrome AND-mask. To draw an icon you first copy the mask
to the screen with an AND operator, then you copy the XOR-mask with an XOR
operator. 

Therefore the biHeight field is set to 2 * TIconDirEntry.bHeight and
biSizeImage is set to the size of the AND plus the XOR mask (ofcourse in
bytes). For example, for a 32x32 16 color icon biHeight would be 64 and
biSizeImage 512 + 128.

OK. How do you determine the size of the masks? 

XOR mask: (TIconDirEntry.bWidth * TIconDirEntry.bHeight * biBitCount) / 8
AND mask: (TIconDirEntry.bWidth * TIconDirEntry.bHeight) / 8

The palette data

The bitmap info header is followed by a table with palette entries. The actual
pixel data refer to this table. So when a pixel has color 13, look at palette
entry number 13 to get the actual RGB color for the pixel. At this moment
Windows just supports 2 (monochrome), 16 and 256 colors, so there's always a
palette table.

An entry in the palette table has the following format:
}

</i></font>TRGBQuad <font color="#000080">= </font><font color="#FF0000"><b>record
  </b></font>rgbBlue<font color="#000080">: </font>Byte<font color="#000080">;      </font><font color="#008000"><i>(* blue component of color *)
  </i></font>rgbGreen<font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>(* green component of color *)
  </i></font>rgbRed<font color="#000080">: </font>Byte<font color="#000080">;       </font><font color="#008000"><i>(* red component of color *)
  </i></font>rgbReserved<font color="#000080">: </font>Byte<font color="#000080">;  </font><font color="#008000"><i>(* reserved, 0 *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{
For Windows programmers: this record is *not* equivalent to a TColorRef (or
COLORREF). If you forget this, you'll get some odd colored icons :-).

An icon has TIconDirEntry.bColorCount palette entries. So there are
sizeof(TRGBQuad) * TIconDirEntry.bColorCount bytes in the palette.

The monochrome AND mask does _not_ have a palette table. A 1 bit in the AND
mask's pixel data means a _white_ pixel on-screen. A 0 bit means a black pixel.

On the other hand, the pixel data of monochrome icons _are_ preceded by a
palette table.


Pixel data

Now to the real nitty-gritty. Immediately after the palette data, the pixel
data follow. Remember: the pixel data contain both the XOR and AND bits.

There's something odd with the storage of the mask bits: both mask data are
stored in bottom up format. For example: in a 32 x 32 16 color icon the first
32 nibbles belong actually to the last pixel row. The second 32 nibbles form
the last - 1 pixel row. And so on.
Retrieving pixels is a little bit hard. Just keep track of the biBitCount
value. Write different functions for monochrome, 16 and 256 color icons or keep
a running bit mask ready.
In Windows creating an icon from .ICO file is rather easy, call the
CreateDIBitmap function twice (for the AND mask/XOR mask). Then call
GetBitmapBits to retrieve the bitmap data.
Under DOS you have to do a little more: e.g. translation of RGB colors.
}</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to WIN-OS2 SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0058.PAS">Original</a><b>]</b></p></body>
</html>
