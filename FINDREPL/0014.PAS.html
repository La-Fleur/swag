<html>
<head><title> "SYMTAB1.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FINDREPL SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0014.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#000000">   SYMBOL TABLE

   All Compilers <font color="#FF0000"><b>and </b></font>interpreters must maintain a data structure
   called the SYMBOL TABLE<font color="#000080">. </font>This <font color="#FF0000"><b>is </b></font>where all the inFormation about
   the Programs symbols are kept<font color="#000080">. </font>Maintaining a well<font color="#000080">-</font>organized
   symbol table <font color="#FF0000"><b>is </b></font>a skill all Compiler Writers must master<font color="#000080">.

   </font><font color="#FF0000"><b>As </b></font>a Compiler parses a source <font color="#FF0000"><b>Program</b></font><font color="#000080">, </font>it relies <font color="#FF0000"><b>on </b></font>the symbol
   table <font color="#FF0000"><b>to </b></font>provide inFormation about each identifier <font color="#000080">(</font>such <font color="#FF0000"><b>as
   </b></font>Variables <font color="#FF0000"><b>and </b></font>Constants<font color="#000080">) - </font>it must be able <font color="#FF0000"><b>to </b></font>access <font color="#FF0000"><b>and </b></font>update
   inFormation about each identifier <font color="#FF0000"><b>and do </b></font>so quickly <font color="#000080">- </font>otherwise
   the process <font color="#FF0000"><b>is </b></font>slowed <font color="#FF0000"><b>or </b></font>produces incorrect results<font color="#000080">.

   </font>No matter what inFormation <font color="#FF0000"><b>is </b></font>kept<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>how the table <font color="#FF0000"><b>is </b></font>organized
   certain operations are fundamental <font color="#FF0000"><b>to </b></font>a symbol tables operation<font color="#000080">.

   </font>You ENTER inFormation about about an identifier into the table by
   <font color="#000080">*</font>creating<font color="#000080">* </font><font color="#FF0000"><b>and </b></font>entry<font color="#000080">.

   </font>You SEARCH the table <font color="#FF0000"><b>to </b></font>look up an identifier<font color="#800000">'s entry and make
   </font>available the inFormation <font color="#FF0000"><b>in </b></font>that entry<font color="#000080">.

   </font>You UPDATE the entry <font color="#FF0000"><b>to </b></font>modify stored inFormation<font color="#000080">.

   </font>There can be only one entry per identifier <font color="#FF0000"><b>in </b></font>the symbol table<font color="#000080">,
   </font>so you must first search the table beFore making a new entry<font color="#000080">.

   </font>TABLE ORGANIZATION

   There are many different ways <font color="#FF0000"><b>to </b></font>handle symbol tables<font color="#000080">: </font>Arrays<font color="#000080">,
   </font>linked lists<font color="#000080">, </font>hash tables<font color="#000080">...</font>but since the most common operations
   perFormed <font color="#FF0000"><b>on </b></font>a symbol table are searching it <font color="#FF0000"><b>For </b></font>existing entries
   it makes perfect sense <font color="#FF0000"><b>to </b></font>implement it <font color="#FF0000"><b>as </b></font>a BINARY TREE<font color="#000080">.

   </font>Each NODE <font color="#FF0000"><b>in </b></font>the TREE <font color="#FF0000"><b>contains and </b></font>entry<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>points <font color="#FF0000"><b>to </b></font>two other
   nodes<font color="#000080">. </font>The <font color="#000080">*</font>values<font color="#000080">* </font><font color="#FF0000"><b>of </b></font>the nodes <font color="#FF0000"><b>on </b></font>the subtree <font color="#FF0000"><b>to </b></font>the left are
   always LESS than the parent node<font color="#000080">, </font><font color="#FF0000"><b>While </b></font>the subtree <font color="#FF0000"><b>to </b></font>the right
   <font color="#FF0000"><b>is </b></font>always MORE than the parent<font color="#000080">. </font>This makes searching sorted
   binary trees very efficient<font color="#000080">.

   </font>Inserting new nodes <font color="#FF0000"><b>is as </b></font>easy <font color="#FF0000"><b>as </b></font>searching the tree<font color="#000080">: </font><font color="#FF0000"><b>if </b></font>the
   value you want <font color="#FF0000"><b>to </b></font>insert <font color="#FF0000"><b>is </b></font>LESS than the current node<font color="#000080">, </font>search
   the node <font color="#FF0000"><b>to </b></font>the left<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>it <font color="#FF0000"><b>is </b></font>MORE<font color="#000080">, </font>search the tree <font color="#FF0000"><b>to </b></font>the right<font color="#000080">.
   </font>Keep doing this recursively <font color="#FF0000"><b>Until </b></font>an empty node <font color="#FF0000"><b>is </b></font>found<font color="#000080">, </font><font color="#FF0000"><b>then
   </b></font>insert the value into that node<font color="#000080">.

   </font>NITTY<font color="#000080">-</font>GRITTY

   Now that we<font color="#800000">'ve covered some background on the table, here'</font>s a
   recap <font color="#FF0000"><b>on </b></font>the symbol table <font color="#FF0000"><b>Type </b></font>defs<font color="#000080">. </font><font color="#FF0000"><b>For </b></font>those that missed them
   <font color="#FF0000"><b>in </b></font>the first <font color="#FF0000"><b>message</b></font><font color="#000080">, </font><font color="#FF0000"><b>or </b></font>didn<font color="#800000">'t save them:

</font><font color="#FF0000"><b>Type
   </b></font>sptr <font color="#000080">= ^</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#008000"><i>{ useful For minimum-size allocation }

   </i></font>DEFN_KEY <font color="#000080">= (</font>UNDEFINED<font color="#000080">,
               </font>Const_DEFN<font color="#000080">, </font>Type_DEFN<font color="#000080">, </font>Var_DEFN<font color="#000080">, </font>FIELD_DEFN<font color="#000080">,
               </font>VALPARM_DEFN<font color="#000080">, </font>VarPARM_DEFN<font color="#000080">,
               </font>PROG_DEFN<font color="#000080">, </font>PROC_DEFN<font color="#000080">, </font>FUNC_DEFN
              <font color="#000080">);

   </font>ROUTINE_KEY <font color="#000080">= (</font>rkDECLARED<font color="#000080">, </font>rkForWARD<font color="#000080">,
                  </font>rkREAD<font color="#000080">, </font>rkREADLN<font color="#000080">, </font>rkWrite<font color="#000080">, </font>rkWriteLN<font color="#000080">,
                  </font>rkABS<font color="#000080">, </font>rkARCTAN<font color="#000080">, </font>rkCHR<font color="#000080">, </font>rkCOS<font color="#000080">, </font>rkEOF<font color="#000080">, </font>rkEOLN<font color="#000080">,
                  </font>rkEXP<font color="#000080">, </font>rkLN<font color="#000080">, </font>rkODD<font color="#000080">, </font>rkORD<font color="#000080">, </font>rkPRED<font color="#000080">, </font>rkROUND<font color="#000080">,
                  </font>rkSIN<font color="#000080">, </font>rkSQR<font color="#000080">, </font>rkSQRT<font color="#000080">, </font>rkSUCC<font color="#000080">, </font>rkTRUNC
                 <font color="#000080">);

   </font>RTN_BLOCK <font color="#000080">= </font><font color="#FF0000"><b>Record               </b></font><font color="#008000"><i>{info about routine declarations}
      </i></font>key              <font color="#000080">:</font>ROUTINE_KEY<font color="#000080">;
      </font>parm_count<font color="#000080">,
      </font>total_parm_size<font color="#000080">,
      </font>total_local_size <font color="#000080">:</font>Word<font color="#000080">;
      </font>parms<font color="#000080">, </font>locals<font color="#000080">,
      </font>local_symtab     <font color="#000080">:</font>SYMTAB_PTR<font color="#000080">; </font><font color="#008000"><i>{symbol tables of routine}
      </i></font>code_segment     <font color="#000080">:</font>sptr<font color="#000080">;       </font><font color="#008000"><i>{interpreter}
   </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>DTA_BLOCK <font color="#000080">= </font><font color="#FF0000"><b>Record
      </b></font>offset     <font color="#000080">:</font>Word<font color="#000080">;
      </font>Record_idp <font color="#000080">:</font>SYMTAB_PTR<font color="#000080">;
   </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>INFO_REC <font color="#000080">= </font><font color="#FF0000"><b>Record
      Case </b></font>Byte <font color="#FF0000"><b>of
        </b></font><font color="#800000">0</font><font color="#000080">:(</font>Constant <font color="#000080">:</font>VALUE<font color="#000080">);     </font><font color="#008000"><i>{ literal value }
        </i></font><font color="#800000">1</font><font color="#000080">:(</font>routine  <font color="#000080">:</font>RTN_BLOCK<font color="#000080">); </font><font color="#008000"><i>{ identifier is routine }
        </i></font><font color="#800000">2</font><font color="#000080">:(</font>data     <font color="#000080">:</font>DTA_BLOCK<font color="#000080">); </font><font color="#008000"><i>{ identifier is data }
   </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>DEFN_REC <font color="#000080">= </font><font color="#FF0000"><b>Record
      </b></font>key  <font color="#000080">:</font>DEFN_KEY<font color="#000080">; </font><font color="#008000"><i>{ what is identifier? }
      </i></font>info <font color="#000080">:</font>INFO_REC<font color="#000080">; </font><font color="#008000"><i>{ stuff about identifier }
   </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

   </font>SYMTAB_PTR  <font color="#000080">= ^</font>SYMTAB_NODE<font color="#000080">;
   </font>SYMTAB_NODE <font color="#000080">= </font><font color="#FF0000"><b>Record          </b></font><font color="#008000"><i>{actual tree node}
      </i></font>left<font color="#000080">, </font>right   <font color="#000080">:</font>SYMTAB_PTR<font color="#000080">; </font><font color="#008000"><i>{Pointers to left and right subtrees}
      </i></font>next          <font color="#000080">:</font>SYMTAB_PTR<font color="#000080">; </font><font color="#008000"><i>{For chaining a node}
      </i></font>name          <font color="#000080">:</font>sptr<font color="#000080">;       </font><font color="#008000"><i>{identifier name String}
      </i></font>level<font color="#000080">,                     </font><font color="#008000"><i>{nesting level}
      </i></font>co_index      <font color="#000080">:</font>Integer<font color="#000080">;    </font><font color="#008000"><i>{code Label index}
      </i></font>defn          <font color="#000080">:</font>DEFN_REC<font color="#000080">;   </font><font color="#008000"><i>{definition info}
   </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ Record }

   </i></font>EXCERCISE <font color="#800000">#1

   </font>Implement a symbol table SEARCH routine<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>a symbol table ENTER
   routine<font color="#000080">. </font>Both routines must accept a Pointer <font color="#FF0000"><b>to </b></font>the root <font color="#FF0000"><b>of </b></font>the
   tree<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>the name <font color="#FF0000"><b>of </b></font>the identifier you are working <font color="#FF0000"><b>With</b></font><font color="#000080">, </font><font color="#FF0000"><b>and
   </b></font>must return a Pointer <font color="#FF0000"><b>to </b></font>the node that was found <font color="#FF0000"><b>in </b></font>the search
   routine<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>enters <font color="#FF0000"><b>in </b></font>the enter routine<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>no node was found<font color="#000080">, </font><font color="#FF0000"><b>or
   </b></font>entered<font color="#000080">, </font>the routines must return <font color="#FF0000"><b>NIL</b></font><font color="#000080">.

   </font>The resulting symbol table should be a sorted tree<font color="#000080">.



&sup3;   </font>Implement a symbol table SEARCH routine<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>a symbol table ENTER
<font color="#000080">&sup3;   </font>routine<font color="#000080">. </font>Both routines must accept a Pointer <font color="#FF0000"><b>to </b></font>the root <font color="#FF0000"><b>of </b></font>the
<font color="#000080">&sup3;   </font>tree<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>the name <font color="#FF0000"><b>of </b></font>the identifier you are working <font color="#FF0000"><b>with</b></font><font color="#000080">, </font><font color="#FF0000"><b>and
</b></font><font color="#000080">&sup3;   </font>must return a Pointer <font color="#FF0000"><b>to </b></font>the node that was found <font color="#FF0000"><b>in </b></font>the search
<font color="#000080">&sup3;   </font>routine<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>enters <font color="#FF0000"><b>in </b></font>the enter routine<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>no node was found<font color="#000080">, </font><font color="#FF0000"><b>or
</b></font><font color="#000080">&sup3;   </font>entered<font color="#000080">, </font>the routines must return <font color="#FF0000"><b>NIL</b></font><font color="#000080">.
&sup3;   </font>The resulting symbol table should be a sorted tree<font color="#000080">.



</font><font color="#FF0000"><b>Function </b></font>Enter<font color="#000080">(</font>root<font color="#000080">: </font>SymTab_Ptr<font color="#000080">; </font>PidStr<font color="#000080">: </font>spstr<font color="#000080">): </font>SymTab_Ptr<font color="#000080">;
</font><font color="#008000"><i>{ - inserts a new indetifier String PidStr in the symol table. }
{ - nil is returned if duplicate identifier is found.          }
</i></font><font color="#FF0000"><b>Var
  </b></font>Ptemp<font color="#000080">: </font>SymTab_Ptr<font color="#000080">;
</font><font color="#FF0000"><b>begin
  if </b></font><font color="#000080">(</font>root <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil</b></font><font color="#000080">) </font><font color="#FF0000"><b>then    </b></font><font color="#008000"><i>{ not a terminal node }
    </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>PidStr <font color="#000080">= </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>then
      begin
        </b></font>Enter <font color="#000080">:= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
        </font>Exit
      <font color="#FF0000"><b>end
    else    </b></font><font color="#008000"><i>{ recursive insertion calls to either left or right sub-tree }
      </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>PidStr <font color="#000080">&gt; </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>then
        </b></font>Enter<font color="#000080">(</font>root<font color="#000080">^.</font>right<font color="#000080">, </font>PidStr<font color="#000080">)
      </font><font color="#FF0000"><b>else
        </b></font>Enter<font color="#000080">(</font>root<font color="#000080">^.</font>left<font color="#000080">, </font>PidStr<font color="#000080">)
  </font><font color="#FF0000"><b>else </b></font><font color="#008000"><i>{ a terminal node }
    </i></font><font color="#FF0000"><b>begin
      </b></font>new<font color="#000080">(</font>Ptemp<font color="#000080">);     </font><font color="#008000"><i>{ create a new tree leaf node }
      </i></font>Ptemp<font color="#000080">^.</font>name <font color="#000080">:= </font>PidStr<font color="#000080">;
      </font>Ptemp<font color="#000080">^.</font>left <font color="#000080">:= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
      </font>Ptemp<font color="#000080">^.</font>right <font color="#000080">:= </font><font color="#FF0000"><b>nil
    end
end</b></font><font color="#000080">; </font><font color="#008000"><i>{ Enter }


</i></font><font color="#FF0000"><b>Function </b></font>Search<font color="#000080">(</font>root<font color="#000080">: </font>SymTab_Ptr<font color="#000080">; </font>PidStr<font color="#000080">: </font>spstr<font color="#000080">): </font>SymTab_Ptr<font color="#000080">;
</font><font color="#008000"><i>{ - search For a certain identifier String PidStr in the symbol table. }
{ - returns nil if search faild.                                       }
</i></font><font color="#FF0000"><b>begin
  While </b></font><font color="#000080">(</font>root <font color="#000080">&lt;&gt; </font><font color="#FF0000"><b>nil</b></font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>PidStr <font color="#000080">&lt;&gt; </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>do
    if </b></font><font color="#000080">(</font>PidStr <font color="#000080">&gt; </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>then     </b></font><font color="#008000"><i>{ search the right sub-tree }
      </i></font>root <font color="#000080">:= </font>root<font color="#000080">^.</font>right
    <font color="#FF0000"><b>else
      if </b></font><font color="#000080">(</font>PidStr <font color="#000080">&lt; </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>then
        </b></font>root <font color="#000080">:= </font>root<font color="#000080">^.</font>left<font color="#000080">;           </font><font color="#008000"><i>{ search the left sub-tree  }
   </i></font>Search <font color="#000080">:= </font>root                     <font color="#008000"><i>{ return the node           }
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{===========================================================================}

</i></font>Comment<font color="#000080">:
     </font>What made you choose BINARY trees over AVL trees<font color="#000080">?  </font><font color="#FF0000"><b>With </b></font>binary trees<font color="#000080">,
     </font>the structure may become degenerate <font color="#000080">(</font>unbalanced<font color="#000080">) </font><font color="#FF0000"><b>and</b></font><font color="#000080">, </font>the routines <font color="#FF0000"><b>for
     </b></font>searching <font color="#FF0000"><b>and </b></font>insertion becomes inefficient<font color="#000080">.

&gt;</font>Comment<font color="#000080">:
&gt;     </font>What made you choose BINARY trees over AVL trees<font color="#000080">?  </font><font color="#FF0000"><b>With </b></font>binary trees<font color="#000080">,
&gt;     </font>the structure may become degenerate <font color="#000080">(</font>unbalanced<font color="#000080">) </font><font color="#FF0000"><b>and</b></font><font color="#000080">, </font>the routines <font color="#FF0000"><b>for
</b></font><font color="#000080">&gt;     </font>searching <font color="#FF0000"><b>and </b></font>insertion becomes inefficient<font color="#000080">.

   </font>Glad you could join us<font color="#000080">!

   </font>I chose a binary tree because it<font color="#800000">'s simple and easy to Write, also
   </font>a degenerate tree isn<font color="#800000">'t much of a concern, simply because it'</font>s
   intended <font color="#FF0000"><b>to </b></font>hold only identifiers <font color="#FF0000"><b>and </b></font>Constants<font color="#000080">, </font><font color="#FF0000"><b>not </b></font>every
   statement<font color="#000080">. :)

   </font><font color="#FF0000"><b>As </b></font>long <font color="#FF0000"><b>as </b></font>it sorts the data <font color="#FF0000"><b>as </b></font>it inserts<font color="#000080">, </font>it will work<font color="#000080">. </font>This
   isn<font color="#800000">'t, after all, a graduate &quot;course&quot;. The intention is to teach
   </font>people how compilers work <font color="#FF0000"><b>and </b></font>show interested parties how <font color="#FF0000"><b>to
   </b></font>understand <font color="#FF0000"><b>and </b></font>Write their own<font color="#000080">, </font><font color="#FF0000"><b>if </b></font>they<font color="#800000">'re interested. This is
   </font>YOUR compiler you<font color="#800000">'re writing, if you want to implement an AVL
   </font>tree<font color="#000080">, </font>go ahead<font color="#000080">!

&gt;</font><font color="#FF0000"><b>Function </b></font>Search<font color="#000080">(</font>root<font color="#000080">: </font>SymTab_Ptr<font color="#000080">; </font>PidStr<font color="#000080">: </font>spstr<font color="#000080">): </font>SymTab_Ptr<font color="#000080">;

   </font>This works<font color="#000080">. </font>It<font color="#800000">'s efficient and does the job.

</font><font color="#000080">&gt;</font><font color="#FF0000"><b>Function </b></font>Enter<font color="#000080">(</font>root<font color="#000080">: </font>SymTab_Ptr<font color="#000080">; </font>PidStr<font color="#000080">: </font>spstr<font color="#000080">): </font>SymTab_Ptr<font color="#000080">;

&gt;    </font><font color="#FF0000"><b>else    </b></font><font color="#008000"><i>{ recursive insertion calls to either left or right sub-tree }
</i></font><font color="#000080">&gt;      </font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>PidStr <font color="#000080">&gt; </font>root<font color="#000080">^.</font>name<font color="#000080">) </font><font color="#FF0000"><b>then
</b></font><font color="#000080">&gt;        </font>Enter<font color="#000080">(</font>root<font color="#000080">^.</font>right<font color="#000080">, </font>PidStr<font color="#000080">)
&gt;      </font><font color="#FF0000"><b>else
</b></font><font color="#000080">&gt;        </font>Enter<font color="#000080">(</font>root<font color="#000080">^.</font>left<font color="#000080">, </font>PidStr<font color="#000080">)

   </font>Note<font color="#000080">: </font>recursive calls shouldn<font color="#800000">'t be necessary in this Function.
   </font>You can search the table the same way you did <font color="#FF0000"><b>With </b></font>Search<font color="#000080">, </font><font color="#FF0000"><b>and
   </b></font>you don<font color="#800000">'t run the risk of running out of stack space. Procedure
   </font>calls can also be exensive<font color="#000080">, </font>slowing down the <font color="#FF0000"><b>Program </b></font>too much
   especially <font color="#FF0000"><b>if </b></font>a lot <font color="#FF0000"><b>of </b></font>symbols are searched<font color="#000080">.

&gt;  </font><font color="#FF0000"><b>else </b></font><font color="#008000"><i>{ a terminal node }
</i></font><font color="#000080">&gt;    </font><font color="#FF0000"><b>begin
</b></font><font color="#000080">&gt;      </font>new<font color="#000080">(</font>Ptemp<font color="#000080">);     </font><font color="#008000"><i>{ create a new tree leaf node }
</i></font><font color="#000080">&gt;      </font>Ptemp<font color="#000080">^.</font>name <font color="#000080">:= </font>PidStr<font color="#000080">;
&gt;      </font>Ptemp<font color="#000080">^.</font>left <font color="#000080">:= </font><font color="#FF0000"><b>nil</b></font><font color="#000080">;
&gt;      </font>Ptemp<font color="#000080">^.</font>right <font color="#000080">:= </font><font color="#FF0000"><b>nil
</b></font><font color="#000080">&gt;    </font><font color="#FF0000"><b>end
</b></font><font color="#000080">&gt;</font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ Enter }

   </i></font>Please note that there <font color="#FF0000"><b>is </b></font>a lot <font color="#FF0000"><b>of </b></font>data that will be have <font color="#FF0000"><b>to
   </b></font>added <font color="#FF0000"><b>to </b></font>this section over time<font color="#000080">, </font><font color="#FF0000"><b>as </b></font>an identifier could be
   ANYTHING from a ConstANT <font color="#FF0000"><b>to </b></font>a <font color="#FF0000"><b>Program </b></font>identifier<font color="#000080">.

   </font>That isn<font color="#800000">'t too important right now, as we'</font>re just getting started
   <font color="#FF0000"><b>on </b></font>the symbol table but suggest you add the following lines<font color="#000080">, </font><font color="#FF0000"><b>for
   </b></font>use later<font color="#000080">:

   </font>Ptemp<font color="#000080">^.</font>info     <font color="#000080">:= </font><font color="#FF0000"><b>NIL</b></font><font color="#000080">;
   </font>Ptemp<font color="#000080">^.</font>defn<font color="#000080">.</font>key <font color="#000080">:= </font>UNDEFINED<font color="#000080">;
   </font>Ptemp<font color="#000080">^.</font>level    <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;     </font><font color="#008000"><i>{recursion level}
   </i></font>Ptemp<font color="#000080">^.</font>Label_index <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;  </font><font color="#008000"><i>{Label # to be used in code output}
</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FINDREPL SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0014.PAS">Original</a><b>]</b></p></body>
</html>
