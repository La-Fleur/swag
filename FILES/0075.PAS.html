<html>
<head><title> "Combined Real and DPMI File Handle Exten" by CLAUS FISCHER</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FILES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0075.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
From: &quot;CLAUS FISCHER&quot; &lt;WI00227@wipool.wifo.uni-mannheim.de&gt;

I had found the Extend.Pas and PExted.pas on SWAG.
First provides 255 File in DOS, second in protcted mode.
Now I had mixed them together and I wish to give this to
SWAG. Where should I post this?

(*** 3 Files: ***)
 255DEMO.PAS  (Extend Version with StdErr)
 FILEPLUS.PAS (was EXTEND.PAS)
 DOSMEM.PAS   (was SHRINK.PAS)
{-------------------------------snipp--------------------------------}
  </i></font><font color="#FF0000"><b>program </b></font>Test255Files<font color="#000080">;

</font><font color="#FF0000"><b>uses </b></font>fileplus<font color="#000080">,       </font><font color="#008000"><i>{ &lt;--- This is the magic line that does
everything }
     </i></font>Dos<font color="#000080">;

</font><font color="#FF0000"><b>const </b></font>MaxCount <font color="#000080">= </font><font color="#800000">255</font><font color="#000080">;

</font><font color="#FF0000"><b>type </b></font>FileArray <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font>MaxCount<font color="#000080">] </font><font color="#FF0000"><b>of </b></font>text<font color="#000080">;

</font><font color="#FF0000"><b>var </b></font>Count<font color="#000080">: </font>integer<font color="#000080">;
    </font>StdErr<font color="#000080">: </font>Text<font color="#000080">;
    </font>F<font color="#000080">: ^</font>FileArray<font color="#000080">;
    </font>I<font color="#000080">: </font>integer<font color="#000080">;
    </font>Num<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">[</font><font color="#800000">6</font><font color="#000080">];

</font><font color="#FF0000"><b>procedure </b></font>stderror<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>f<font color="#000080">:</font>text<font color="#000080">);
</font><font color="#FF0000"><b>var
    </b></font>tmpfile<font color="#000080">:</font>text<font color="#000080">;
</font><font color="#FF0000"><b>begin
  </b></font>assign<font color="#000080">(</font>tmpfile<font color="#000080">,</font><font color="#800000">''</font><font color="#000080">); </font><font color="#008000"><i>(* stdoutput *)
  </i></font>rewrite<font color="#000080">(</font>tmpfile<font color="#000080">);
  </font>move<font color="#000080">(</font>tmpfile<font color="#000080">, </font>f<font color="#000080">, </font>sizeof<font color="#000080">(</font>f<font color="#000080">));
  </font>textrec<font color="#000080">(</font>f<font color="#000080">).</font>handle<font color="#000080">:= </font><font color="#800000">2</font><font color="#000080">;
  </font>close<font color="#000080">(</font>tmpfile<font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>begin
</b></font>write<font color="#000080">(</font><font color="#800000">'Hello!! I''m running under '</font><font color="#000080">);
</font><font color="#008000"><i>{$IFDEF MSDOS}</i></font>writeln<font color="#000080">(</font><font color="#800000">'MsDos REAL-Mode'</font><font color="#000080">);
</font><font color="#008000"><i>{$ELSE} </i></font>writeln<font color="#000080">(</font><font color="#800000">'DPMI Protected Mode'</font><font color="#000080">);
</font><font color="#008000"><i>{$ENDIF}
</i></font>new<font color="#000080">(</font>F<font color="#000080">);            </font><font color="#008000"><i>{ Use heap because of large size of this array }
</i></font>writeln<font color="#000080">(</font><font color="#800000">'Opening files...'</font><font color="#000080">);
</font>Stderror<font color="#000080">(</font>StdErr<font color="#000080">);
</font>writeln<font color="#000080">( </font>Stderr<font color="#000080">, </font><font color="#800000">'(Handle Stderr) '</font><font color="#000080">,</font>TextRec<font color="#000080">(</font>StdErr<font color="#000080">).</font>Handle <font color="#000080">);
</font>writeln<font color="#000080">( </font>Output<font color="#000080">, </font><font color="#800000">'(Handle Stdout) '</font><font color="#000080">,</font>TextRec<font color="#000080">(</font>Output<font color="#000080">).</font>Handle <font color="#000080">);
</font>write<font color="#000080">( </font>Output<font color="#000080">, </font><font color="#800000">'(Handle:FileNo) '</font><font color="#000080">);
</font>I <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
</font><font color="#FF0000"><b>repeat
  </b></font>inc<font color="#000080">(</font>I<font color="#000080">);
  </font>str<font color="#000080">(</font>I<font color="#000080">,</font>Num<font color="#000080">);
  </font>assign<font color="#000080">(</font>F<font color="#000080">^[</font>I<font color="#000080">],</font><font color="#800000">'junk' </font><font color="#000080">+ </font>num <font color="#000080">+ </font><font color="#800000">'.txt'</font><font color="#000080">);
  </font><font color="#008000"><i>{$I-}
  </i></font>rewrite<font color="#000080">(</font>F<font color="#000080">^[</font>I<font color="#000080">]);
  </font>write<font color="#000080">( </font>OutPut<font color="#000080">, </font>i<font color="#000080">:</font><font color="#800000">4</font><font color="#000080">,</font><font color="#800000">':'</font><font color="#000080">,</font>TextRec<font color="#000080">(</font>f<font color="#000080">^[</font>i<font color="#000080">]).</font>Handle <font color="#000080">);
  </font><font color="#008000"><i>{$I+}
</i></font><font color="#FF0000"><b>until </b></font>ioresult <font color="#000080">&lt;&gt; </font><font color="#800000">0</font><font color="#000080">;
</font>writeln<font color="#000080">(</font>output<font color="#000080">);
</font>Count <font color="#000080">:= </font>I <font color="#000080">- </font><font color="#800000">1</font><font color="#000080">;
</font>writeln<font color="#000080">(</font><font color="#800000">'Successfully opened '</font><font color="#000080">, </font>Count<font color="#000080">, </font><font color="#800000">' files at the same time.
</font>Writing <font color="#FF0000"><b>to </b></font>each <font color="#FF0000"><b>file</b></font><font color="#000080">...</font><font color="#800000">');
</font><font color="#FF0000"><b>for </b></font>I <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Count <font color="#FF0000"><b>do
  </b></font>writeln<font color="#000080">(</font>F<font color="#000080">^[</font>I<font color="#000080">], </font><font color="#800000">'This is a test.'</font><font color="#000080">);
</font>writeln<font color="#000080">(</font><font color="#800000">'Closing and erasing each file...'</font><font color="#000080">);
</font><font color="#FF0000"><b>for </b></font>I <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Count <font color="#FF0000"><b>do
  begin
  </b></font>close<font color="#000080">(</font>F<font color="#000080">^[</font>I<font color="#000080">]);
  </font>erase<font color="#000080">(</font>F<font color="#000080">^[</font>I<font color="#000080">])
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
</font>writeln<font color="#000080">(</font><font color="#800000">'Done.'</font><font color="#000080">)
</font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font><font color="#008000"><i>{----------------------snapp----------------------------------------}

{---------------------snipp---------------------------------------}
{$I-,O-,R-}

</i></font><font color="#FF0000"><b>unit </b></font>fileplus<font color="#000080">; </font><font color="#008000"><i>{origin name Extend}

{Patch V1.0 94-12 Claus Fischer for}
{REF: MsDos-Real-Mode: Scott Bussinger}
{     DPMI:          : Kim Kokkonen, TurboPower Software}
{     catched up on SIMTEL-Archieve and SWAG-List}

{FILEPLUS Patch Claus Fischer}
{ Changes:
  Main feater: Use Real-Mode and DPMI-Mode with the same Unit.
  I have disabled DOS 2.xx Management because its not necessary for
me.
  The SHRINK-Unit is now named as DosMem.Pas.
  The futur check of MSDOS-Version is removed, because further MSDOS
vers
  will shure support the prefix features. The market use this.
  The DPMIExtendHandles-Function was changed to Procedure, so its
equal
  to MSDOSExtendHandles (not neccesary, but looks pretty).
  Claus Fischer
  WI00227@WIPOOL.WIFO.UNI-MANNHEIM.DE
}

{EXTEND Version Scott Bussinger}
{ This unit allows a program to open more than the standard DOS
maximum of 20
  open files at one time.  You must also be sure to set a FILES=XX
statement
  in your CONFIG.SYS file.
  (DISABLED: This program installs a special interrupt handler
         under DOS 2.x, some semi-documented features under
         DOS 3.x prior to DOS 3.3 and the DOS extend files
         call under DOS 3.3 or later. C.F.)
  This unit USES the DOS unit and should be used BEFOR ANY OTHER UNTIS
  other than the DOS unit.  This code was based upon earlier work by
  Randy Forgaard, Bela Lubkin and Kim Kokkonen.  See EXTEND.DOC for
  more information.

  Scott Bussinger
  Professional Practice Systems
  110 South 131st Street
  Tacoma, WA  98444
  (206)531-8944
  Compuserve [72247,2671] }

{ ** Revision History **
  1 EXTEND.PAS 9-Mar-89,`SCOTT' First version using TLIB -- Based on
3.2
  2 EXTEND.PAS 15-Sep-89,`SCOTT'
       Added SwapVectorsExtend procedure
           Put handle table into DOS memory
       Use DOS 3.3 extended handles function when available
  3 EXTEND.PAS 2-Oct-89,`SCOTT'
       Fixed bug in determining the DOS version
  4 EXTEND.PAS 5-Oct-89,`SCOTT'
           Yet another bug in the DosVersion detection
  5 EXTEND.PAS 19-Nov-90,`SCOTT'
           New version of EXTEND that is compatible with Turbo Pascal
6.0
       Modified the documentation and version numbers to be less
confusing
  ** Revision History ** }

{PEXTEND    DPMI-Version Kim Kokkonen
 ------------------------------------------------------------------
 This unit provides a single function, DpmiExtendHandles, for
 extending the file handle table for DOS protected mode applications
 under Borland Pascal 7.0.

 The standard DOS call for this purpose (AH = $67) does odd things to
 DOS memory when run from a BP7 pmode program. If you Exec from a
 program that has extended the handle table, DOS memory will be
 fragmented, leaving a stranded block of almost 64K at the top of DOS
 memory. The function implemented here avoids this problem.

 If you haven't used an ExtendHandles function before, note that you
 cannot get more handles than the FILES= statement in CONFIG.SYS
 allows. (Other utilities such as FILES.COM provided with QEMM do the
 same thing.) However, even if you have FILES=255, any single program
 cannot open more than 20 files (and DOS uses up 5 of those) unless
 you use a routine like DpmiExtendHandles. This routine allows up to
 255 open files as long as the FILES= statement provides for them.

 This code works only for DOS 3.0 or later. Since (to my knowledge)
 DPMI cannot be used with earlier versions of DOS, the code doesn't
 check the DOS version.

 Don't call this function more than once in the same program.

 Version 1.0,
   Written 12/15/92, Kim Kokkonen, TurboPower Software
}

</i></font><font color="#FF0000"><b>interface

</b></font><font color="#008000"><i>(* delted(0) of Dos 2.11 Version-Managament *)
(* procedure SwapVectorsExtend;
  { Swap interrupt vectors taken over by Extend unit with system
vectors }
*)
(* END of delted(0) *)

</i></font><font color="#FF0000"><b>implementation

uses </b></font>Dos<font color="#000080">,
     </font><font color="#008000"><i>{$IFDEF MSDOS} </i></font>DosMem<font color="#000080">;
     </font><font color="#008000"><i>{$ELSE}        </i></font>WinApi<font color="#000080">;
     </font><font color="#008000"><i>{$ENDIF}

(* deleted(1) DOS 2.11 Ver ... *)
(* var ExitSave: pointer;                           { Previous exit
procedure }
    OldInt21: pointer;                           { Save old INT 21 }
*)
(* END of delted(1) *)

(* Deleted(2) ...   DOS 2.11 Ver *)
(*
{$L EXTEND }
procedure ExtendInit; external;                  { Initialize
interrupt handler }
procedure ExtendHandler; external;               { Replacement INT 21
handler }
*)
(* End of delted(2) *)

(* ... deleted(3) DOS 2.11 Ver.... *)
(*
procedure SwapVectorsExtend;
  { Swap interrupt vectors taken over by Extend unit with system
vectors }
  var TempVector: pointer;
  begin
  if lo(DosVersion) = 2 then
    begin
    GetIntVec($21,TempVector);                   { Swap the INT 21
vectors }
    SetIntVec($21,OldInt21);
    OldInt21 := TempVector
    end
  end;
*)
(* END of Deleted(3) *)


{$IFDEF MSDOS}
</i></font><font color="#FF0000"><b>procedure </b></font>MSDOSExtendHandles<font color="#000080">;
</font><font color="#008000"><i>(* My Patch of MSDOS Scott Bussinger Version *)
  { Install the extended handles interrupt.  No files (other than
    standard handles) should be open when unit starts up. }

</i></font><font color="#FF0000"><b>type   </b></font>HandleArray <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">254</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;        </font><font color="#008000"><i>{ Room for 255
handles }
       </i></font>HandleArrayPtr <font color="#000080">= ^</font>HandleArray<font color="#000080">;

  </font><font color="#FF0000"><b>var </b></font>Regs<font color="#000080">: </font>Registers<font color="#000080">;
      </font>DosMemory<font color="#000080">: </font>pointer<font color="#000080">;                          </font><font color="#008000"><i>{ Pointer to
memory gained from DOS }
      </i></font>OldHandleTable<font color="#000080">: </font>HandleArrayPtr<font color="#000080">;              </font><font color="#008000"><i>{ Pointer to
original table }
      </i></font>OldNumHandles<font color="#000080">: </font>byte<font color="#000080">;                         </font><font color="#008000"><i>{ Original number
of handles }
  </i></font><font color="#FF0000"><b>begin

  if </b></font>lo<font color="#000080">(</font>DosVersion<font color="#000080">) &lt;= </font><font color="#800000">2
   </font><font color="#FF0000"><b>then </b></font><font color="#008000"><i>{Patch KISS!} </i></font>exit<font color="#000080">;

  </font><font color="#008000"><i>(* deleted(4) DOS 2.11 ..... *)
  (*
    begin
    GetIntVec($21,OldInt21);                     { Install interrupt
handler under DOS 2.x }
    ExtendInit;                                  { Initialize the
interrupt handler }
    SetIntVec($21,@ExtendHandler)
    end
   else
   *)
   (* END of deleted(4) *)

   (* deleted(5) schnick-schnack: MickySoft will support further *)
   (*
      if (lo(DosVersion)&gt;=4) or (hi(DosVersion)&gt;=30) { Does this DOS
version support the handles call? }
       then
        begin
    DosDispose(DosMemory);                   { Free up the DOS memory
block so that the next function will succeed }
    with Regs do
          begin
          AH := $67;                             { Tell DOS to allow
us 255 handles }
          BX := 255;                             { KEEP THIS NUMBER
ODD TO AVOID BUG IN SOME VERSIONS OF DOS 3.3!! }
          MsDos(Regs)
      end
    end
       else  begin
   *)
   (* END of delted(5) *)


   </i></font>DosNewShrink<font color="#000080">(</font>DosMemory<font color="#000080">,</font>sizeof<font color="#000080">(</font>HandleArray<font color="#000080">));
   </font><font color="#FF0000"><b>if </b></font>DosMemory <font color="#000080">= </font><font color="#FF0000"><b>nil then </b></font>exit<font color="#000080">;
       </font><font color="#008000"><i>{ There wasn't enough memory for a handle table, so just quit }
   </i></font><font color="#FF0000"><b>begin </b></font><font color="#008000"><i>{else}

    { Initialize new handles as unused          *1* }
    { Get old table length                  *2* }
    { Save address of old table                 *3* }
    { Set new table length                  *4* }
    { Point to new handle table                 *5* }
    { Copy the current handle table to the new handle table *6* }

    </i></font>fillchar<font color="#000080">(</font>DosMemory<font color="#000080">^,</font>sizeof<font color="#000080">(</font>HandleArray<font color="#000080">),</font><font color="#800000">$FF</font><font color="#000080">);          </font><font color="#008000"><i>(*1*)
    </i></font>OldNumHandles <font color="#000080">:= </font>mem<font color="#000080">[</font>prefixseg<font color="#000080">:</font><font color="#800000">$0032</font><font color="#000080">];                 </font><font color="#008000"><i>(*2*)
    </i></font>OldHandleTable <font color="#000080">:= </font>pointer<font color="#000080">(</font>ptr<font color="#000080">(</font>prefixseg<font color="#000080">,</font><font color="#800000">$0034</font><font color="#000080">)^);      </font><font color="#008000"><i>(*3*)
    </i></font>mem<font color="#000080">[</font>prefixseg<font color="#000080">:</font><font color="#800000">$0032</font><font color="#000080">] := </font>sizeof<font color="#000080">(</font>HandleArray<font color="#000080">);           </font><font color="#008000"><i>(*4*)
    </i></font>pointer<font color="#000080">(</font>meml<font color="#000080">[</font>prefixseg<font color="#000080">:</font><font color="#800000">$0034</font><font color="#000080">]) := </font>DosMemory<font color="#000080">;           </font><font color="#008000"><i>(*5*)
    </i></font>move<font color="#000080">(</font>OldHandleTable<font color="#000080">^,</font>DosMemory<font color="#000080">^,</font>OldNumHandles<font color="#000080">)         </font><font color="#008000"><i>(*6*)
   </i></font><font color="#FF0000"><b>end
  end</b></font><font color="#000080">; </font><font color="#008000"><i>(* of MSDOSExtenHandles *)
{$ENDIF} {of IFDEF MSDOS}

{$IFNDEF MSDOS} {.= WINAPI}
</i></font><font color="#FF0000"><b>procedure </b></font>DPMIExtendHandles<font color="#000080">;
   </font><font color="#FF0000"><b>const </b></font>Handles <font color="#000080">= </font><font color="#800000">255</font><font color="#000080">; </font><font color="#008000"><i>(* added *)
(* My Patch of MSDOS Kim Kokkonen Version *)
(* Orginal was: function DpmiExtendHandles(Handles : Byte) : Word; *)
  </i></font><font color="#FF0000"><b>type </b></font>DosMemRec <font color="#000080">= </font><font color="#FF0000"><b>record
            </b></font>Sele<font color="#000080">, </font>Segm <font color="#000080">: </font>Word<font color="#000080">;
           </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
   </font><font color="#FF0000"><b>var
    </b></font>OldTable <font color="#000080">: </font>Pointer<font color="#000080">;
    </font>OldSize <font color="#000080">: </font>Word<font color="#000080">;
    </font>NewTable <font color="#000080">: </font>Pointer<font color="#000080">;
    </font>DosMem <font color="#000080">: </font>DosMemRec<font color="#000080">;
  </font><font color="#FF0000"><b>begin
     </b></font><font color="#008000"><i>(* DEL: DpmiExtendHandles := 0; PROCEDURE replaced *)
     (* DEL: if Handles &lt;= 20 then Exit; CONST replaced *)

     {Allocate new table area in DOS memory}
     </i></font>LongInt<font color="#000080">(</font>DosMem<font color="#000080">) := </font>GlobalDosAlloc<font color="#000080">(</font>Handles<font color="#000080">);
     </font><font color="#FF0000"><b>if </b></font>LongInt<font color="#000080">(</font>DosMem<font color="#000080">) = </font><font color="#800000">0 </font><font color="#FF0000"><b>then
    </b></font>exit<font color="#000080">; </font><font color="#008000"><i>(* add *)

      (* DEL: begin DpmiExtendHandles := 8;Exit; end; PROCEDURE
replaced *)

      {Initialize new table with closed handles}
    </i></font>NewTable <font color="#000080">:= </font>Ptr<font color="#000080">(</font>DosMem<font color="#000080">.</font>Sele<font color="#000080">, </font><font color="#800000">0</font><font color="#000080">);</font><font color="#008000"><i>(*1*)
    </i></font>FillChar<font color="#000080">(</font>NewTable<font color="#000080">^, </font>Handles<font color="#000080">, </font><font color="#800000">$FF</font><font color="#000080">);</font><font color="#008000"><i>(*1*)

      {Copy old table to new. Assume old table in PrefixSeg}
    </i></font>OldTable <font color="#000080">:= </font>Ptr<font color="#000080">(</font>PrefixSeg<font color="#000080">, </font>MemW<font color="#000080">[</font>PrefixSeg<font color="#000080">:</font><font color="#800000">$34</font><font color="#000080">]);
    </font>OldSize <font color="#000080">:= </font>Mem<font color="#000080">[</font>PrefixSeg<font color="#000080">:</font><font color="#800000">$32</font><font color="#000080">];
    </font>move<font color="#000080">(</font>OldTable<font color="#000080">^, </font>NewTable<font color="#000080">^, </font>OldSize<font color="#000080">);

      </font><font color="#008000"><i>{Set new handle table size and pointer}
    </i></font>Mem<font color="#000080">[</font>PrefixSeg<font color="#000080">:</font><font color="#800000">$32</font><font color="#000080">] := </font>Handles<font color="#000080">;
    </font>MemW<font color="#000080">[</font>PrefixSeg<font color="#000080">:</font><font color="#800000">$34</font><font color="#000080">] := </font><font color="#800000">0</font><font color="#000080">;
    </font>MemW<font color="#000080">[</font>PrefixSeg<font color="#000080">:</font><font color="#800000">$36</font><font color="#000080">] := </font>DosMem<font color="#000080">.</font>Segm<font color="#000080">;
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>(* of DPMIExtendHandles *)
{$ENDIF} {of IFNDEF MSDOS}


(* deleted(6) DOS 2.11 Ver ... *)
(*
{$F+}
procedure ExitHandler;
{$F-}
  { Uninstall the extended handles interrupt.  All files (other
    than standard handles) should be closed before unit exits. }
  begin
  ExitProc := ExitSave;                          { Chain to next exit
routine }
  SwapVectorsExtend                              { Restore original
interrupt vectors }
  end;
*)
(* END of delted(6) *)

</i></font><font color="#FF0000"><b>begin </b></font><font color="#008000"><i>(* of Install *)
(* deleted(7) DosVer 2.11 ... *)
(* ExitSave := ExitProc;                            { Remember the
previous exit routine }
   ExitProc := @ExitHandler;  { Install our exit routine }
*)
(* END of delted(7) *)


{$IFDEF MSDOS}
  </i></font>MSDOSExtendHandles<font color="#000080">; </font><font color="#008000"><i>{ Enable the extra handles }
{$ELSE}
  </i></font>DPMIExtendHandles<font color="#000080">;
</font><font color="#008000"><i>{$ENDIF}
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font><font color="#008000"><i>{-------------------------------snapp--------------------------------}

{-------------------------------snipp-------------------------------}
</i></font><font color="#FF0000"><b>unit </b></font>DosMem<font color="#000080">;

</font><font color="#008000"><i>{$IFDEF DPMI}  </i></font><font color="#000080">*** </font>Only Real<font color="#000080">-</font>Mode<font color="#000080">! *** </font><font color="#008000"><i>{$ENDIF}
{$IFDEF WINDOWS} </i></font><font color="#000080">*** </font>Only Dos<font color="#000080">-</font>Real<font color="#000080">-</font>Mode <font color="#000080">*** </font><font color="#008000"><i>{$ENDIF}
{$IFDEF OS2} </i></font><font color="#000080">*** </font>Only Dos<font color="#000080">-</font>Real<font color="#000080">-</font>Mode <font color="#000080">*** </font><font color="#008000"><i>{$ENDIF}

{ This unit allows you to allocate memory from the DOS memory pool
rather than
  from the Turbo Pascal heap.  It also provides a procedure for
shrinking the
  current program to free up DOS memory.

  Scott Bussinger
  Professional Practice Systems
  110 South 131st Street
  Tacoma, WA  98444
  (206)531-8944
  Compuserve [72247,2671] }

{ ** Revision History **
  1 SHRINK.PAS 15-Sep-89,`SCOTT' Initial version of SHRINK unit
  2 SHRINK.PAS 19-Oct-90,`SCOTT'
       Added support for Turbo Pascal 6's new heap manager
  ** Revision History ** }

</i></font><font color="#FF0000"><b>interface

procedure </b></font>DosNew<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">;
                     </font>Bytes<font color="#000080">: </font>word<font color="#000080">);
  </font><font color="#008000"><i>{ Get a pointer to a chunk of memory from DOS.  Returns NIL if
    sufficient DOS memory is not available. }

</i></font><font color="#FF0000"><b>procedure </b></font>DosDispose<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">);
  </font><font color="#008000"><i>{ Return an allocated chunk of memory to DOS.  Only call this
function
    with pointers allocated with DosNew or DosNewShrink. }

</i></font><font color="#FF0000"><b>procedure </b></font>DosNewShrink<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">;
                           </font>Bytes<font color="#000080">: </font>word<font color="#000080">);
  </font><font color="#008000"><i>{ Get a pointer to a chunk of memory from DOS, shrinking current
program
    to gain DOS memory if necessary.  Returns NIL if sufficient DOS
memory
    is not available and there is insufficient free space in the heap
to
    allow program to be shrunk to accomodate the request. }

</i></font><font color="#FF0000"><b>function </b></font>Linear<font color="#000080">(</font>P<font color="#000080">: </font>pointer<font color="#000080">): </font>longint<font color="#000080">;
  </font><font color="#008000"><i>{ Return the pointer as a linear longint value }

</i></font><font color="#FF0000"><b>implementation

uses </b></font>Dos<font color="#000080">;

</font><font color="#FF0000"><b>const </b></font>DosOverhead <font color="#000080">= </font><font color="#800000">1</font><font color="#000080">;                           </font><font color="#008000"><i>{ Extra number of
paragraphs that DOS requires in overhead for MCB chain }

</i></font><font color="#FF0000"><b>function </b></font>Linear<font color="#000080">(</font>P<font color="#000080">: </font>pointer<font color="#000080">): </font>longint<font color="#000080">;
  </font><font color="#008000"><i>{ Return the pointer as a linear longint value }
  </i></font><font color="#FF0000"><b>begin
  </b></font>Linear <font color="#000080">:= (</font>longint<font color="#000080">(</font>seg<font color="#000080">(</font>P<font color="#000080">^)) </font><font color="#FF0000"><b>shl </b></font><font color="#800000">4</font><font color="#000080">) + </font>ofs<font color="#000080">(</font>P<font color="#000080">^)
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>procedure </b></font>DosNew<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">;
                     </font>Bytes<font color="#000080">: </font>word<font color="#000080">);
  </font><font color="#008000"><i>{ Get a pointer to a chunk of memory from DOS.  Returns NIL if
    sufficient DOS memory is not available. }
  </i></font><font color="#FF0000"><b>var </b></font>SegsToAllocate<font color="#000080">: </font>word<font color="#000080">;
      </font>Regs<font color="#000080">: </font>Registers<font color="#000080">;
  </font><font color="#FF0000"><b>begin
  </b></font>SegsToAllocate <font color="#000080">:= (</font>Bytes<font color="#000080">+</font><font color="#800000">15</font><font color="#000080">) </font><font color="#FF0000"><b>shr </b></font><font color="#800000">4</font><font color="#000080">;            </font><font color="#008000"><i>{ DOS allocates
memory in paragraph sized pieces only }
  </i></font><font color="#FF0000"><b>with </b></font>Regs <font color="#FF0000"><b>do
    begin
    </b></font>AH <font color="#000080">:= </font><font color="#800000">$48</font><font color="#000080">;
    </font>BX <font color="#000080">:= </font>SegsToAllocate<font color="#000080">;
    </font>MsDos<font color="#000080">(</font>Regs<font color="#000080">);
    </font><font color="#FF0000"><b>if </b></font>odd<font color="#000080">(</font>Flags<font color="#000080">)
     </font><font color="#FF0000"><b>then
      </b></font>P <font color="#000080">:= </font><font color="#FF0000"><b>nil                                   </b></font><font color="#008000"><i>{ No memory
available }
     </i></font><font color="#FF0000"><b>else
      </b></font>P <font color="#000080">:= </font>ptr<font color="#000080">(</font>AX<font color="#000080">,</font><font color="#800000">$0000</font><font color="#000080">)                         </font><font color="#008000"><i>{ Return pointer to
memory block }
    </i></font><font color="#FF0000"><b>end
  end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>procedure </b></font>DosDispose<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">);
  </font><font color="#008000"><i>{ Return an allocated chunk of memory to DOS.  Only call this
function
    with pointers allocated with DosNew or DosNewShrink. }
  </i></font><font color="#FF0000"><b>var </b></font>Regs<font color="#000080">: </font>Registers<font color="#000080">;
  </font><font color="#FF0000"><b>begin
  with </b></font>Regs <font color="#FF0000"><b>do
    begin
    </b></font>AH <font color="#000080">:= </font><font color="#800000">$49</font><font color="#000080">;
    </font>ES <font color="#000080">:= </font>seg<font color="#000080">(</font>P<font color="#000080">^);
    </font>MsDos<font color="#000080">(</font>Regs<font color="#000080">)
    </font><font color="#FF0000"><b>end
  end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>procedure </b></font>DosNewShrink<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>P<font color="#000080">: </font>pointer<font color="#000080">;
                           </font>Bytes<font color="#000080">: </font>word<font color="#000080">);
  </font><font color="#008000"><i>{ Get a pointer to a chunk of memory from DOS, shrinking current
program
    to gain DOS memory if necessary.  Returns NIL if sufficient DOS
memory
    is not available and there is insufficient free space in the heap
to
    allow program to be shrunk to accomodate the request. }
  </i></font><font color="#FF0000"><b>var </b></font>BytesToAllocate<font color="#000080">: </font>word<font color="#000080">;
      </font>Regs<font color="#000080">: </font>Registers<font color="#000080">;
  </font><font color="#FF0000"><b>begin
  </b></font>BytesToAllocate <font color="#000080">:= (((</font>Bytes<font color="#000080">+</font><font color="#800000">15</font><font color="#000080">) </font><font color="#FF0000"><b>shr </b></font><font color="#800000">4</font><font color="#000080">) + </font>DosOverhead<font color="#000080">) </font><font color="#FF0000"><b>shl </b></font><font color="#800000">4</font><font color="#000080">;
  </font>DosNew<font color="#000080">(</font>P<font color="#000080">,</font>Bytes<font color="#000080">);
  </font><font color="#008000"><i>{ Try to get memory the easy way first }

  {$IFDEF VER60} {$DEFINE NEWHEAP} {$ENDIF}
  {$IFDEF VER70} {$DEFINE NEWHEAP} {$ENDIF}

  {$IFDEF NEWHEAP}
  { Check for Turbo 6's new heap manager }
  </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>P<font color="#000080">=</font><font color="#FF0000"><b>nil</b></font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>Linear<font color="#000080">(</font>HeapEnd<font color="#000080">)-</font>Linear<font color="#000080">(</font>HeapPtr<font color="#000080">)&gt;=</font>BytesToAllocate<font color="#000080">)
</font><font color="#FF0000"><b>then
    begin
    </b></font><font color="#008000"><i>{ The easy method didn't work but there is sufficient space in
the heap }
    </i></font>dec<font color="#000080">(</font>longint<font color="#000080">(</font>HeapEnd<font color="#000080">),</font>longint<font color="#000080">(</font>BytesToAllocate<font color="#000080">) </font><font color="#FF0000"><b>shl </b></font><font color="#800000">12</font><font color="#000080">);
    </font><font color="#008000"><i>{ Move the top of the heap down }

    </i></font><font color="#FF0000"><b>with </b></font>Regs <font color="#FF0000"><b>do
      begin
      </b></font>AH <font color="#000080">:= </font><font color="#800000">$4A</font><font color="#000080">;
      </font>BX <font color="#000080">:= </font>seg<font color="#000080">(</font>HeapEnd<font color="#000080">^) - </font>prefixseg <font color="#000080">- (</font>BytesToAllocate <font color="#FF0000"><b>shr </b></font><font color="#800000">4</font><font color="#000080">);
      </font>ES <font color="#000080">:= </font>prefixseg<font color="#000080">;
      </font>MsDos<font color="#000080">(</font>Regs<font color="#000080">)
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font>DosNew<font color="#000080">(</font>P<font color="#000080">,</font>Bytes<font color="#000080">)
    </font><font color="#008000"><i>{ Try the DOS allocation one more time }
    </i></font><font color="#FF0000"><b>end
  </b></font><font color="#008000"><i>{$ELSE}
  </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>P<font color="#000080">=</font><font color="#FF0000"><b>nil</b></font><font color="#000080">) </font><font color="#FF0000"><b>and
  </b></font><font color="#008000"><i>{ Handle the old free list style heap }
     </i></font><font color="#000080">(  ( (</font>ofs<font color="#000080">(</font>FreePtr<font color="#000080">^)=</font><font color="#800000">0</font><font color="#000080">)
      </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>Linear<font color="#000080">(</font>FreePtr<font color="#000080">)+</font><font color="#800000">$10000</font><font color="#000080">-</font>Linear<font color="#000080">(</font>HeapPtr<font color="#000080">)&gt;=</font>BytesToAllocate<font color="#000080">)
    ) </font><font color="#FF0000"><b>or
    </b></font><font color="#000080">(
     (</font>ofs<font color="#000080">(</font>FreePtr<font color="#000080">^)&lt;&gt;</font><font color="#800000">0</font><font color="#000080">)
      </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>Linear<font color="#000080">(</font>FreePtr<font color="#000080">)-</font>Linear<font color="#000080">(</font>HeapPtr<font color="#000080">)&gt;=</font>BytesToAllocate<font color="#000080">)
     )  )
     </font><font color="#FF0000"><b>then
    begin
    </b></font><font color="#008000"><i>{ The easy method didn't work but there is sufficient space in
the heap }
    </i></font>OldFreePtr <font color="#000080">:= </font>FreePtr<font color="#000080">;
    </font>dec<font color="#000080">(</font>longint<font color="#000080">(</font>FreePtr<font color="#000080">),</font>longint<font color="#000080">(</font>BytesToAllocate<font color="#000080">) </font><font color="#FF0000"><b>shl </b></font><font color="#800000">12</font><font color="#000080">);
    </font><font color="#008000"><i>{ Decrement the segment of the pointer to the free list }

    </i></font><font color="#FF0000"><b>if </b></font>ofs<font color="#000080">(</font>OldFreePtr<font color="#000080">^) &lt;&gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>then
    </b></font><font color="#008000"><i>{ If free list is empty, then there's nothing to move }
      </i></font>move<font color="#000080">(</font>OldFreePtr<font color="#000080">^,</font>FreePtr<font color="#000080">^,</font><font color="#800000">$10000</font><font color="#000080">-</font>ofs<font color="#000080">(</font>OldFreePtr<font color="#000080">^));
      </font><font color="#008000"><i>{ Otherwise, move the free list down in memory }

    </i></font><font color="#FF0000"><b>with </b></font>Regs <font color="#FF0000"><b>do
      begin
      </b></font>AH <font color="#000080">:= </font><font color="#800000">$4A</font><font color="#000080">;
      </font>BX <font color="#000080">:= </font>seg<font color="#000080">(</font>OldFreePtr<font color="#000080">^) + </font><font color="#800000">$1000 </font><font color="#000080">- </font>prefixseg <font color="#000080">- (</font>BytesToAllocate
<font color="#FF0000"><b>shr </b></font><font color="#800000">4</font><font color="#000080">);
      </font>ES <font color="#000080">:= </font>prefixseg<font color="#000080">;
      </font>MsDos<font color="#000080">(</font>Regs<font color="#000080">)
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font>DosNew<font color="#000080">(</font>P<font color="#000080">,</font>Bytes<font color="#000080">)                              </font><font color="#008000"><i>{ Try the DOS
allocation one more time }
    </i></font><font color="#FF0000"><b>end
  </b></font><font color="#008000"><i>{$ENDIF}
  {$IFDEF NEWHEAP}{$UNDEF NEWHEAP}{$ENDIF}
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FILES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0075.PAS">Original</a><b>]</b></p></body>
</html>
