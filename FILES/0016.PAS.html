<html>
<head><title> "Binary Key Search - File" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FILES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0016.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{===========================================================================
 BBS: Canada Remote Systems
Date: 05-31-93 (20:29)             Number: 24331
From: HERB BROWN                   Refer#: NONE
  To: ERIC GIVLER                   Recvd: NO
Subj: USERS FILE                     Conf: (1221) F-PASCAL
---------------------------------------------------------------------------
On this day, &lt;May 28 17:32&gt;, Eric Givler (1:270/101.15@fidonet) noted:
 EG&gt; How would this help?  You'd still have to search the entire
 EG&gt; INDEX file LINEARLY, correct?  Or would you have the INDEX sorted?
 EG&gt; If so, how would you keep it sorted?  More input would REALLY be
 EG&gt; appreciated!

This is code for a binary &quot;split and search&quot; method.   Anyways, thats just
something I call it.  Actually, it's a rudimentary binary search.

Suppose you had a key record of                                           }

 </i></font>key <font color="#000080">= </font><font color="#FF0000"><b>record
 </b></font>reference <font color="#000080">: </font>Longint<font color="#000080">;  </font><font color="#008000"><i>{ room for a lot of records }
 </i></font>KeySearchField <font color="#000080">: </font>String30<font color="#000080">; </font><font color="#008000"><i>{ The key string to be stored}
 </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;     </font><font color="#008000"><i>{ Note, several smaller strings could be put together to make the
            search critical, i.e., keysearchField:=First+second+ThirdName;
            As long as the field length stays less than or equal to what you
         defined }

{Then using a function that would return a boolean value, i.e., true if data
matches, false if not found, then it would look like so.. }

</i></font><font color="#FF0000"><b>Function </b></font>FindKey<font color="#000080">( </font><font color="#FF0000"><b>VAR  </b></font>AKey <font color="#000080">: </font>AKeyFile<font color="#000080">;
                  </font><font color="#FF0000"><b>VAR  </b></font>AKeyRef <font color="#000080">: </font>Longint<font color="#000080">;
                       </font>FindMe <font color="#000080">: </font>String80<font color="#000080">): </font>Boolean<font color="#000080">;

</font><font color="#FF0000"><b>VAR </b></font>High<font color="#000080">,</font>Low<font color="#000080">,</font>Mid <font color="#000080">: </font>Longint<font color="#000080">;  </font><font color="#008000"><i>{ For collision processing }
     </i></font>Target <font color="#000080">: </font>Key<font color="#000080">;
     </font>Gotit  <font color="#000080">: </font>Boolean<font color="#000080">;
     </font>Collison <font color="#000080">: </font>Boolean<font color="#000080">;
     </font>NumRecs  <font color="#000080">: </font>Longint<font color="#000080">;


</font><font color="#FF0000"><b>begin
 </b></font>AKeyRef <font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
 </font>NumRecs <font color="#000080">:= </font>FileSize<font color="#000080">(</font>AKey<font color="#000080">);  </font><font color="#008000"><i>{Get the number of records stored in file}

 </i></font>High <font color="#000080">:= </font>NumRecs<font color="#000080">;
 </font>Low <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
 </font>Mid <font color="#000080">:= (</font>Low <font color="#000080">+ </font>High<font color="#000080">) </font><font color="#FF0000"><b>DIV </b></font><font color="#800000">2 </font><font color="#008000"><i>{ Split point }
 </i></font>FindKey <font color="#000080">:= </font>False<font color="#000080">;
 </font>Gotit <font color="#000080">:= </font>False<font color="#000080">;
 </font>Collision <font color="#000080">:= </font>False<font color="#000080">;
 </font><font color="#FF0000"><b>If </b></font>NumRecs <font color="#000080">&gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>Then </b></font><font color="#008000"><i>{the file is not empty }
  </i></font><font color="#FF0000"><b>Repeat
   </b></font>Seek<font color="#000080">(</font>AKey<font color="#000080">,</font>Mid<font color="#000080">);
   </font>Read<font color="#000080">(</font>Akey<font color="#000080">,</font>Target<font color="#000080">);
   </font><font color="#008000"><i>{Was there a position collision ??}
   </i></font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>Low <font color="#000080">= </font>Mid<font color="#000080">) </font><font color="#FF0000"><b>OR </b></font><font color="#000080">(</font>High <font color="#000080">= </font>Mid<font color="#000080">) </font>the Collision <font color="#000080">:= </font>True<font color="#000080">;
     </font><font color="#FF0000"><b>IF </b></font>Findme <font color="#000080">:= </font>Target<font color="#000080">.</font>KeySearchField <font color="#FF0000"><b>Then </b></font><font color="#008000"><i>{ Yay ! }
         </i></font><font color="#FF0000"><b>begin
          </b></font>Gotit <font color="#000080">:= </font>True<font color="#000080">;
          </font>FindKey <font color="#000080">:= </font>True<font color="#000080">;
          </font>AKeyRef <font color="#000080">:= </font>Target<font color="#000080">.</font>Reference<font color="#000080">;
        </font><font color="#FF0000"><b>End
    Else  </b></font><font color="#008000"><i>{ Divide in half and try it again..}
     </i></font><font color="#FF0000"><b>Begin
      If </b></font>FindMe <font color="#000080">&gt; </font>Target<font color="#000080">.</font>KeySearchField <font color="#FF0000"><b>then </b></font>Low <font color="#000080">:= </font>Mid
       <font color="#FF0000"><b>Else </b></font>High <font color="#000080">:= </font>Mid<font color="#000080">;
      </font>Mid <font color="#000080">:= (</font>Low <font color="#000080">+ </font>High <font color="#000080">+ </font><font color="#800000">1</font><font color="#000080">) </font><font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">;
      </font>AKeyRef <font color="#000080">:= </font>Mid
    <font color="#FF0000"><b>End
 Until </b></font>Collision <font color="#FF0000"><b>or </b></font>Gotit<font color="#000080">;
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;

</font><font color="#008000"><i>(*
This is a working example.  There are some minor precautions that need to be
noted, though.   This will only work on sorted data, for one.  The data can be
sorted with a Quick Sort and the key file re-written in sorted order.   The
advantage here is the actual data file need not be sorted at all.

Any time you work with a data base, get into the habit of ALWAYS including a
deleted tag field.  The above example lacks this, though.

This is just one of many ways of searching a database.  Professional &lt;grin&gt;
applications would probably be better suited for AVL trees or Btrees.

Building an array &quot;cache&quot; helps speed up processing as well.  That is whole
'nuder ball game, though.. *)
</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FILES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0016.PAS">Original</a><b>]</b></p></body>
</html>
