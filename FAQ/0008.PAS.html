<html>
<head><title> "BORLAND - OOP QA" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0008.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code>
<font color="#000000">TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>OBJECT </b></font>EXE <font color="#FF0000"><b>FILE </b></font>SIZE OVERHEAD
Q<font color="#000080">. </font>How much overhead will result <font color="#FF0000"><b>in </b></font>the <font color="#000080">*.</font>EXE <font color="#FF0000"><b>file </b></font>from using the
   <font color="#FF0000"><b>object </b></font>oriented style<font color="#000080">?
</font>A<font color="#000080">. </font>The overhead will result from the pointer from the <font color="#FF0000"><b>object to
   </b></font>its method<font color="#000080">.  </font>This <font color="#FF0000"><b>is </b></font>a <font color="#800000">4 </font>byte pointer<font color="#000080">, </font>so there isn<font color="#800000">'t that
   </font>much extra code generated<font color="#000080">.


</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>PROTECTED AND PRIVATE </b></font>FIELDS
Q<font color="#000080">. </font>Does Turbo <font color="#FF0000"><b>Pascal </b></font><font color="#800000">5.5 </font>support <font color="#FF0000"><b>Protected or Private </b></font>fields<font color="#000080">?
</font>A<font color="#000080">. </font>No it does <font color="#FF0000"><b>not</b></font><font color="#000080">.


</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>RECORDS VS<font color="#000080">. </font>OBJECTS
Q<font color="#000080">. </font>What things can be done <font color="#FF0000"><b>with </b></font>Records that can <font color="#FF0000"><b>not </b></font>be done <font color="#FF0000"><b>with
   </b></font>Objects<font color="#000080">?
</font>A<font color="#000080">. </font>You cannot have<font color="#000080">:

     </font><font color="#800000">1. </font>Variant Objects<font color="#000080">.
     </font><font color="#800000">2. </font>Objects <font color="#FF0000"><b>with </b></font>absolutes<font color="#000080">.
     </font><font color="#800000">3. </font>Directly nested Objects<font color="#000080">.

   </font>You can have<font color="#000080">:

       </font><font color="#800000">1. </font>Pointers <font color="#FF0000"><b>to </b></font>objects<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>EXTERNAL </b></font>METHODS
Q<font color="#000080">. </font>Can methods within an <font color="#FF0000"><b>object </b></font>be <font color="#FF0000"><b>external</b></font><font color="#000080">?
</font>A<font color="#000080">. </font>Yes<font color="#000080">. </font><font color="#FF0000"><b>Virtual and </b></font>Static methods can be written <font color="#FF0000"><b>as external
   </b></font>code<font color="#000080">. </font>There <font color="#FF0000"><b>is </b></font>no difference between an <font color="#FF0000"><b>external Virtual or
   </b></font>Static method<font color="#000080">. </font><font color="#FF0000"><b>External </b></font>Constructors <font color="#FF0000"><b>and </b></font>Destructors are
   difficult <font color="#FF0000"><b>to </b></font>write due <font color="#FF0000"><b>to </b></font>the Prolog <font color="#FF0000"><b>and </b></font>Epilog code within
   them<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>CONSTRUCTOR </b></font>USE
Q<font color="#000080">. </font>What are the three purposes <font color="#FF0000"><b>of </b></font>a <font color="#FF0000"><b>Constructor</b></font><font color="#000080">?
</font>A<font color="#000080">. </font><font color="#800000">1. </font>Insert the address <font color="#FF0000"><b>of </b></font>the VMT into the <font color="#FF0000"><b>Object </b></font>variable<font color="#000080">.
        (</font>Implicit<font color="#000080">)
   </font><font color="#800000">2. </font><font color="#FF0000"><b>To </b></font>allocate memory <font color="#FF0000"><b>for </b></font>the <font color="#FF0000"><b>Object </b></font>variable<font color="#000080">. 
        (</font>Implicit<font color="#000080">)
   </font><font color="#800000">3. </font><font color="#FF0000"><b>To </b></font>initialize the <font color="#FF0000"><b>Object </b></font>variable<font color="#000080">. 
        (</font>Explicit<font color="#000080">)

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>DESTRUCTOR </b></font>HEAP CORRUPTION
Q<font color="#000080">. </font>Why <font color="#FF0000"><b>is </b></font>my <font color="#FF0000"><b>destructor </b></font>fragging my heap<font color="#000080">?
</font>A<font color="#000080">. </font>Use<font color="#000080">: 
     
     </font>Dispose<font color="#000080">(</font>ptr<font color="#000080">,</font>done<font color="#000080">);

   </font>instead <font color="#FF0000"><b>of</b></font><font color="#000080">:
   
     </font>ptr<font color="#000080">^.</font>done<font color="#000080">;
     </font>Dispose<font color="#000080">(</font>done<font color="#000080">);

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>SAVING OBJECTS <font color="#FF0000"><b>TO </b></font>DISK
Q<font color="#000080">. </font>Can I save my objects <font color="#FF0000"><b>to </b></font>a disk <font color="#FF0000"><b>file </b></font>like I can a <font color="#FF0000"><b>record
   </b></font>structure<font color="#000080">?
</font>A<font color="#000080">. </font>We have provided an example <font color="#FF0000"><b>program on </b></font>the distribution
   diskette<font color="#000080">, </font>STREAMS<font color="#000080">, </font>which documents how <font color="#FF0000"><b>to </b></font>save an <font color="#FF0000"><b>object to
   </b></font>disk<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>FILES <font color="#FF0000"><b>OF OBJECT TYPE
</b></font>Q<font color="#000080">. </font>Why can<font color="#800000">'t I make a file of ObjectType?
</font>A<font color="#000080">. </font>Because by the rules <font color="#FF0000"><b>of </b></font>polymorphism<font color="#000080">, </font>any descendant <font color="#FF0000"><b>of
   </b></font>ObjectType would be <font color="#FF0000"><b>type </b></font>compatible <font color="#FF0000"><b>and </b></font>be able <font color="#FF0000"><b>to </b></font>be written 
   <font color="#FF0000"><b>to </b></font>disk <font color="#FF0000"><b>as </b></font>well<font color="#000080">. </font>The problem <font color="#FF0000"><b>with </b></font>this <font color="#FF0000"><b>is </b></font>that the descendants
   may be <font color="#000080">(</font><font color="#FF0000"><b>and </b></font>usually are<font color="#000080">) </font><font color="#FF0000"><b>of </b></font>a larger size than the ObjectType 
   itself<font color="#000080">.  </font><font color="#FF0000"><b>Pascal</b></font><font color="#800000">'s file structure require all records to be 
   </font>the same size<font color="#000080">, </font>otherwise<font color="#000080">, </font>how <font color="#FF0000"><b>do </b></font>you know which size <font color="#FF0000"><b>object 
   do </b></font>you read <font color="#FF0000"><b>in</b></font><font color="#000080">? </font><font color="#FF0000"><b>For </b></font>an example <font color="#FF0000"><b>on </b></font>how <font color="#FF0000"><b>to do Object </b></font>disk I<font color="#000080">/</font>O<font color="#000080">, 
   </font>please see the STREAMS example <font color="#FF0000"><b>on </b></font>the distribution diskettes<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>SIZEOF OBJECTS <font color="#FF0000"><b>CONSTRUCTOR
</b></font>Q<font color="#000080">. </font>Why does Sizeof<font color="#000080">(</font>MyObject<font color="#000080">) </font>return a size <font color="#800000">2 </font>bytes larger than I
   expect when no <font color="#FF0000"><b>virtual </b></font>methods are used<font color="#000080">?
</font>A<font color="#000080">. </font>By placing a <font color="#FF0000"><b>constructor in </b></font>your <font color="#FF0000"><b>object</b></font><font color="#000080">, </font>you<font color="#800000">'re making the 
   </font><font color="#FF0000"><b>object virtual</b></font><font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>LINKER STRIPS UNUSED STATIC METHODS
Q<font color="#000080">. </font>It appears that my static methods are getting stripped from 
   my <font color="#FF0000"><b>program </b></font>by the smart linker when they are unused<font color="#000080">. </font>Yet<font color="#000080">, 
   </font>my <font color="#FF0000"><b>virtual </b></font>methods are <font color="#FF0000"><b>not</b></font><font color="#000080">. </font>How come<font color="#000080">?
</font>A<font color="#000080">. </font>Static methods can be stripped because it can be determined at
   link time what methods will be called<font color="#000080">. </font><font color="#FF0000"><b>Virtual </b></font>methods can 
   <font color="#FF0000"><b>not </b></font>be stripped because the <font color="#FF0000"><b>program </b></font>will <font color="#FF0000"><b>not </b></font>know what methods
   will be used<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>what will <font color="#FF0000"><b>not</b></font><font color="#000080">, </font><font color="#FF0000"><b>until </b></font>run time<font color="#000080">. </font>This <font color="#FF0000"><b>is 
   </b></font>because <font color="#FF0000"><b>of </b></font>late binding<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>CONSTRUCTOR </b></font>CALL <font color="#FF0000"><b>TO </b></font>ANCESTOR <font color="#FF0000"><b>WITH </b></font>VIRTUALS
Q<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>a descendant <font color="#FF0000"><b>of </b></font>a <font color="#FF0000"><b>virtual object </b></font>defines no <font color="#FF0000"><b>virtual
   </b></font>methods <font color="#FF0000"><b>of </b></font>its own<font color="#000080">, </font>does it need <font color="#FF0000"><b>to </b></font>call the ancestor<font color="#800000">'s
   </font><font color="#FF0000"><b>constructor</b></font><font color="#000080">?
</font>A<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>an <font color="#FF0000"><b>object is </b></font>a descendant <font color="#FF0000"><b>of </b></font>a <font color="#FF0000"><b>virtual object</b></font><font color="#000080">, </font>it must call
   that ancestor<font color="#800000">'s constructor or it'</font>s own <font color="#FF0000"><b>constructor</b></font><font color="#000080">. </font>Even <font color="#FF0000"><b>if
   </b></font>the new <font color="#FF0000"><b>object </b></font>does <font color="#FF0000"><b>not </b></font>define any virtuals <font color="#FF0000"><b>of </b></font>its own<font color="#000080">. </font><font color="#FF0000"><b>For
   </b></font>example<font color="#000080">:

     </font><font color="#FF0000"><b>Type
       </b></font>A <font color="#000080">= </font><font color="#FF0000"><b>Object 
             Constructor </b></font>Init<font color="#000080">; 
             </font><font color="#FF0000"><b>Procedure </b></font>AA<font color="#000080">; </font><font color="#FF0000"><b>Virtual</b></font><font color="#000080">; 
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">; 
       </font>B <font color="#000080">= </font><font color="#FF0000"><b>Object </b></font><font color="#000080">( </font>A <font color="#000080">) 
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">; 

   </font><font color="#FF0000"><b>For </b></font>each instance <font color="#FF0000"><b>of </b></font>A <font color="#FF0000"><b>and of </b></font>B<font color="#000080">, </font>Init must be called <font color="#FF0000"><b>or </b></font>the
   <font color="#FF0000"><b>Virtual </b></font>Method Table pointer will <font color="#FF0000"><b>not </b></font>be loaded correctly<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>OVERRIDE VIRTUAL </b></font>METHOD CALLING ANCESTOR
Q<font color="#000080">. </font>Can I <font color="#FF0000"><b>override </b></font>a <font color="#FF0000"><b>virtual </b></font>method <font color="#FF0000"><b>and </b></font>force a call <font color="#FF0000"><b>to </b></font>the
   ancestor objects method<font color="#000080">?
</font>A<font color="#000080">. </font>No<font color="#000080">. </font>Late binding will always call the current method <font color="#FF0000"><b>and </b></font>it
   defeats the purpose <font color="#FF0000"><b>of object </b></font>oriented <font color="#FF0000"><b>program to </b></font>go around 
   this feature<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>CONSTRUCTOR </b></font>CALL WITHIN METHOD
Q<font color="#000080">. </font>I am calling my <font color="#FF0000"><b>constructor </b></font>from within a method<font color="#000080">, </font>why am I
   having problems<font color="#000080">?
</font>A<font color="#000080">. </font>The problem will arise when the <font color="#FF0000"><b>constructor </b></font>loads the new VMT
   pointer<font color="#000080">. </font>It loads the pointer <font color="#FF0000"><b>to </b></font>the VMT <font color="#FF0000"><b>for </b></font>the <font color="#FF0000"><b>constructor</b></font><font color="#800000">'s
   </font>table<font color="#000080">, </font><font color="#FF0000"><b>not </b></font>the instances<font color="#000080">. </font>Therefore <font color="#FF0000"><b>if </b></font>a descendant calls an
   ancestor<font color="#800000">'s constructor, the descendant'</font>s VMT will now point <font color="#FF0000"><b>to
   </b></font>the ancestors VMT<font color="#000080">. </font>The problem now occurs when the descendant
   tries <font color="#FF0000"><b>to </b></font>call a method that was defined after the ancestor<font color="#000080">.
   </font>The VMT entry <font color="#FF0000"><b>for </b></font>this method <font color="#FF0000"><b>is </b></font>unknown<font color="#000080">. </font>Look at the
   following example<font color="#000080">: 

     </font><font color="#FF0000"><b>Type 
       </b></font>L1 <font color="#000080">= </font><font color="#FF0000"><b>Object 
              Constructor </b></font>Init<font color="#000080">;
              </font><font color="#FF0000"><b>Procedure </b></font>First<font color="#000080">; </font><font color="#FF0000"><b>Virtual</b></font><font color="#000080">; 
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">; 
       </font>L2 <font color="#000080">= </font><font color="#FF0000"><b>Object </b></font><font color="#000080">( </font>L1 <font color="#000080">); 
              </font><font color="#FF0000"><b>Constructor </b></font>Init<font color="#000080">; 
              </font><font color="#FF0000"><b>Procedure </b></font>Second<font color="#000080">; </font><font color="#FF0000"><b>Virtual</b></font><font color="#000080">; 
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Constructor </b></font>L1<font color="#000080">.</font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
     End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Constructor </b></font>L2<font color="#000080">.</font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
     End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Procedure </b></font>L1<font color="#000080">.</font>First<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
       </b></font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Procedure </b></font>L2<font color="#000080">.</font>Second<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
       </b></font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Var
       </b></font>L <font color="#000080">: </font>L2<font color="#000080">;

     </font><font color="#FF0000"><b>Begin
       </b></font>L<font color="#000080">.</font>Init<font color="#000080">;   </font><font color="#008000"><i>{ This calls L2.Init and loads a pointer to }
                 { the L2 VMT into L.                        }
       </i></font>L<font color="#000080">.</font>First<font color="#000080">;  </font><font color="#008000"><i>{ This will call L1.First, which in turn calls }
                 { L1.Init because as far as the procedure is   }
                 { concerned, the Self pointer is a pointer     }
                 { to an object of type L1.                     }
       </i></font>L<font color="#000080">.</font>Second<font color="#000080">; </font><font color="#008000"><i>{ This is undefined. Since the VMT now       }
                 { pointed to by L is L1's, the pointer to    } 
                 { method Second is undefined. Therefore, the }
                 { call to this method is undefined.          }
       </i></font><font color="#000080">...

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>CONSTRUCTOR </b></font>CALL WITHIN POLYMORPHIC METHOD
Q<font color="#000080">. </font>Does the previous question apply <font color="#FF0000"><b>to </b></font>polymorphic procedures<font color="#000080">?
</font>A<font color="#000080">. </font>Yes<font color="#000080">. </font>The previous question <font color="#FF0000"><b>and </b></font>answer apply <font color="#FF0000"><b>to </b></font>every <font color="#FF0000"><b>case
   </b></font>where the compiler may think <font color="#FF0000"><b>of </b></font>an <font color="#FF0000"><b>object as </b></font>its ancestor<font color="#000080">. </font>A
   polymorphic example that <font color="#FF0000"><b>is </b></font>incorrect follows<font color="#000080">:

     </font><font color="#FF0000"><b>Procedure </b></font>Init <font color="#000080">( </font><font color="#FF0000"><b>var </b></font>x <font color="#000080">: </font>L1 <font color="#000080">);
     </font><font color="#FF0000"><b>Begin
       </b></font>x<font color="#000080">.</font>Init<font color="#000080">;  </font><font color="#008000"><i>{ This will ALWAYS call L1.Init }
     </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font><font color="#FF0000"><b>CONSTRUCTOR </b></font>CALLING ANCESTOR<font color="#800000">'S CONSTRUCTOR
</font>Q<font color="#000080">. </font>Should my current <font color="#FF0000"><b>object</b></font><font color="#800000">'s constructor call it'</font>s ancestor<font color="#800000">'s
   </font>constructors<font color="#000080">?
</font>A<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>a rule <font color="#FF0000"><b>of </b></font>thumb<font color="#000080">, </font>this <font color="#FF0000"><b>is </b></font>the correct thing <font color="#FF0000"><b>to do</b></font><font color="#000080">. </font>It <font color="#FF0000"><b>is
   </b></font>okay <font color="#FF0000"><b>to not do </b></font>it<font color="#000080">, </font>but it does allow <font color="#FF0000"><b>initialization of
   </b></font>whatever the previous constructors did<font color="#000080">.

</font>TP <font color="#800000">5.5 </font>OOP <font color="#000080">- </font>CALLING ANCESTORS <font color="#FF0000"><b>CONSTRUCTOR
</b></font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>you call a <font color="#FF0000"><b>constructor </b></font>from an ancestor<font color="#800000">'s object?
</font>A<font color="#000080">. </font>You can call an ancestor<font color="#800000">'s constructor directly from within
   </font>the <font color="#FF0000"><b>constructor of </b></font>the current <font color="#FF0000"><b>object</b></font><font color="#000080">.  </font><font color="#FF0000"><b>For </b></font>example<font color="#000080">:

     </font><font color="#FF0000"><b>Type
       </b></font>Type1 <font color="#000080">= </font><font color="#FF0000"><b>Object
                 Constructor </b></font>Init<font color="#000080">;
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
       </font>Type2 <font color="#000080">= </font><font color="#FF0000"><b>Object </b></font><font color="#000080">( </font>Type1 <font color="#000080">)
                 </font><font color="#FF0000"><b>Constructor </b></font>Init<font color="#000080">;
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Constructor </b></font>Type1<font color="#000080">.</font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
     End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>Constructor </b></font>Type2<font color="#000080">.</font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>Begin
       </b></font>Type1<font color="#000080">.</font>Init<font color="#000080">;
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
     ...

</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0008.PAS">Original</a><b>]</b></p></body>
</html>
