<html>
<head><title> "General PASCAL FAQ" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0001.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#000000">        ANSWERS <font color="#FF0000"><b>TO </b></font>FREQUENTLY ASKED <font color="#FF0000"><b>PASCAL </b></font>QUESTIONS
        <font color="#000080">============================================

</font><font color="#800000">1</font><font color="#000080">...
                                                                              
  </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I pass an error level code when my <font color="#FF0000"><b>program </b></font>finishes<font color="#000080">?              
                                                                              
  </font>A<font color="#000080">. </font>The halt <font color="#FF0000"><b>procedure </b></font>takes an optional parameter <font color="#FF0000"><b>of type </b></font>word<font color="#000080">. </font>Thus <font color="#000080">-      
                                                                              
         </font>halt<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">);                                                             
                                                                              
     </font>terminates the <font color="#FF0000"><b>program with </b></font>an errorlevel <font color="#FF0000"><b>of </b></font><font color="#800000">1.  </font><font color="#FF0000"><b>If </b></font>halt <font color="#FF0000"><b>is </b></font>used without 
     a parameter it <font color="#FF0000"><b>is </b></font>the same <font color="#FF0000"><b>as </b></font><font color="#000080">-                                          
                                                                              
         </font>halt<font color="#000080">(</font><font color="#800000">0</font><font color="#000080">);                                                             
                                                                              
     </font>Note<font color="#000080">:  </font>When a <font color="#FF0000"><b>program is </b></font>terminated using the halt <font color="#FF0000"><b>procedure </b></font>any exit    
            <font color="#FF0000"><b>procedure </b></font>that has previously been <font color="#FF0000"><b>set </b></font>up <font color="#FF0000"><b>is </b></font>executed<font color="#000080">.            


</font><font color="#800000">2</font><font color="#000080">...
                                                                          
  </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I empty the keyboard buffer<font color="#000080">?                                      
                                                                              
  </font>A<font color="#000080">. </font>There are several ways that this can be achieved<font color="#000080">.  </font>However the safest    
     <font color="#FF0000"><b>is </b></font><font color="#000080">-                                                                     
                                                                              
        </font><font color="#FF0000"><b>while </b></font>Keypressed <font color="#FF0000"><b>do </b></font>ch <font color="#000080">:= </font>ReadKey<font color="#000080">;                                    
                                                                              
     </font>This <font color="#FF0000"><b>requires </b></font>that a variable ch <font color="#FF0000"><b>of type </b></font>char <font color="#FF0000"><b>is </b></font>declared <font color="#FF0000"><b>and </b></font>the crt    
     <font color="#FF0000"><b>unit </b></font>be used<font color="#000080">.  </font><font color="#FF0000"><b>To do </b></font>it without using a variable <font color="#000080">-                       
                                                                              
       </font><font color="#FF0000"><b>while </b></font>Keypressed <font color="#FF0000"><b>do while </b></font>ReadKey <font color="#000080">= </font><font color="#800000">#0 </font><font color="#FF0000"><b>do</b></font><font color="#000080">;                             
                                                                              
     </font><font color="#FF0000"><b>or if </b></font>using TP6 <font color="#FF0000"><b>with </b></font>extended syntax enabled <font color="#000080">-                           
                                                                              
        </font><font color="#FF0000"><b>while </b></font>KeyPressed <font color="#FF0000"><b>do </b></font>ReadKey<font color="#000080">;                                          
                                                                              
     </font><font color="#FF0000"><b>If </b></font>you <font color="#FF0000"><b>do not </b></font>wish <font color="#FF0000"><b>to </b></font>incur the substantial overhead involved <font color="#FF0000"><b>with </b></font>the   
     use <font color="#FF0000"><b>of </b></font>the CRT <font color="#FF0000"><b>unit and </b></font>there <font color="#FF0000"><b>is </b></font>no requirement <font color="#FF0000"><b>for </b></font>the <font color="#FF0000"><b>program to </b></font>run   
     under a multi<font color="#000080">-</font>tasker <font color="#000080">-                                                   
                                                                              
        </font><font color="#FF0000"><b>var                                                                   
          </b></font>head <font color="#000080">: </font>byte <font color="#FF0000"><b>absolute </b></font><font color="#800000">$40</font><font color="#000080">:</font><font color="#800000">$1c</font><font color="#000080">;                                       
          </font>tail <font color="#000080">: </font>byte <font color="#FF0000"><b>absolute </b></font><font color="#800000">$40</font><font color="#000080">:</font><font color="#800000">$1e</font><font color="#000080">;                                       
                                                                              
        </font>tail <font color="#000080">:= </font>head<font color="#000080">;                                                         

</font><font color="#800000">3</font><font color="#000080">...

  </font>Q<font color="#000080">. </font>When I redirect the screen output <font color="#FF0000"><b>of </b></font>my programs <font color="#FF0000"><b>to </b></font>a <font color="#FF0000"><b>file </b></font>the <font color="#FF0000"><b>file is   
     </b></font>empty <font color="#FF0000"><b>and </b></font>the output still appears <font color="#FF0000"><b>on </b></font>the screen<font color="#000080">. </font>What am I doing        
     wrong<font color="#000080">?                                                                   
                                                                              
  </font>A<font color="#000080">. </font>You are probably using the CRT <font color="#FF0000"><b>unit and </b></font>its <font color="#FF0000"><b>default </b></font>method <font color="#FF0000"><b>of </b></font>writing    
     <font color="#FF0000"><b>to </b></font>stdout <font color="#FF0000"><b>is </b></font>by direct screen writes<font color="#000080">.  </font><font color="#FF0000"><b>In </b></font>order <font color="#FF0000"><b>to </b></font>enable output <font color="#FF0000"><b>to </b></font>be   
     redirected all writes must be done by DOS<font color="#000080">.  </font>Setting the variable         
     DirectVideo <font color="#FF0000"><b>to </b></font>false has no effect <font color="#FF0000"><b>on </b></font>redirection <font color="#FF0000"><b>as </b></font>all it does <font color="#FF0000"><b>is </b></font>use  
     the BIOS <font color="#FF0000"><b>for </b></font>screen writes <font color="#000080">- </font><font color="#FF0000"><b>not </b></font>DOS<font color="#000080">.                                    
                                                                              
     </font><font color="#FF0000"><b>To </b></font>enable redirection you must <font color="#FF0000"><b>not </b></font>use the CRT <font color="#FF0000"><b>unit                      
                                                                              
     OR                                                                       
                                                                              
     </b></font>assign<font color="#000080">(</font>output<font color="#000080">,</font><font color="#800000">''</font><font color="#000080">);                                                       
     </font>rewrite<font color="#000080">(</font>output<font color="#000080">);                                                         
                                                                              
     </font>This will make all output go through DOS <font color="#FF0000"><b>and </b></font>thus can be redirected <font color="#FF0000"><b>if   
     </b></font>desired<font color="#000080">.  </font><font color="#FF0000"><b>To </b></font>restore the <font color="#FF0000"><b>default </b></font>situation <font color="#000080">-                             
                                                                              
     </font>AssignCRT<font color="#000080">(</font>output<font color="#000080">); </font>rewrite<font color="#000080">(</font>output<font color="#000080">);                                      


</font><font color="#800000">4</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I make a <font color="#FF0000"><b>string </b></font>that <font color="#FF0000"><b>is </b></font>lower <font color="#FF0000"><b>or </b></font>mixed <font color="#FF0000"><b>case </b></font>all uppercase<font color="#000080">?
                                                                              
   </font>A<font color="#000080">. </font>There are several ways <font color="#FF0000"><b>to </b></font>convert lower <font color="#FF0000"><b>case </b></font>characters <font color="#FF0000"><b>to </b></font>upper <font color="#FF0000"><b>case</b></font><font color="#000080">.  
      </font>Here are some <font color="#FF0000"><b>of </b></font>them<font color="#000080">.                                                  
                                                                              
      </font><font color="#FF0000"><b>As </b></font>a <font color="#FF0000"><b>procedure </b></font><font color="#000080">(</font>excluding <font color="#FF0000"><b>asm </b></font><font color="#FF00FF">code this is the fastest way)             
                                                                              
        procedure StrUpper(var st: string);                                   
          var x : byte;                                                       
          begin                                                               
            for x := 1 to length(st) do                                       
              st[x] := UpCase(st[x]);                                         
          </font><font color="#FF0000"><b>end</b></font><font color="#000080">;                                                                
                                                                              
      </font><font color="#FF0000"><b>As </b></font>a <font color="#FF0000"><b>function </b></font><font color="#000080">(</font>slower but sometimes more convenient<font color="#000080">) -                  
                                                                              
        </font><font color="#FF0000"><b>function </b></font>StrUpper<font color="#000080">(</font>st<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">): </font><font color="#FF0000"><b>string</b></font><font color="#000080">;                                
          </font><font color="#FF0000"><b>var </b></font>x <font color="#000080">: </font>byte<font color="#000080">;                                                       
          </font><font color="#FF0000"><b>begin                                                               
            </b></font>StrUpper<font color="#000080">[</font><font color="#800000">0</font><font color="#000080">] := </font>st<font color="#000080">[</font><font color="#800000">0</font><font color="#000080">];                                             
            </font><font color="#FF0000"><b>for </b></font>x <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>length<font color="#000080">(</font>st<font color="#000080">) </font><font color="#FF0000"><b>do                                       
              </b></font>StrUpper<font color="#000080">[</font>x<font color="#000080">] := </font>UpCase<font color="#000080">(</font>st<font color="#000080">[</font>x<font color="#000080">]);                                   
          </font><font color="#FF0000"><b>end</b></font><font color="#000080">;                                                                
                                                                              
      </font>Both the above are suitable <font color="#FF0000"><b>for </b></font>the English language <font color="#000080">.  </font>However from    
      version <font color="#800000">4.0 </font>onwards<font color="#000080">, </font>DOS has had the facility <font color="#FF0000"><b>to do </b></font>this <font color="#FF0000"><b>in </b></font>a way that  
      <font color="#FF0000"><b>is </b></font>country <font color="#000080">(</font>language<font color="#000080">) </font>specific<font color="#000080">.  </font>I am indebted <font color="#FF0000"><b>to </b></font>Norbert Igl <font color="#FF0000"><b>for </b></font>the   
      basic routine<font color="#000080">.  </font>I have modified his code slightly<font color="#000080">.  </font><font color="#FF0000"><b>For </b></font>the anti<font color="#000080">-</font><font color="#FF0000"><b>goto   
      </b></font>purists this <font color="#FF0000"><b>is </b></font>a good example <font color="#FF0000"><b>of </b></font>a <font color="#FF0000"><b>goto </b></font>that <font color="#FF0000"><b>is </b></font>convenient<font color="#000080">, </font>efficient<font color="#000080">, 
      </font>self<font color="#000080">-</font>documenting <font color="#FF0000"><b>and </b></font>structured<font color="#000080">.  </font>The dos calls would make this method  
      the slowest <font color="#FF0000"><b>of </b></font>all<font color="#000080">.                                                     
                                                                              
     </font><font color="#FF0000"><b>function </b></font>StrUpper<font color="#000080">(</font>s<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">): </font><font color="#FF0000"><b>string</b></font><font color="#000080">;                                    
       </font><font color="#008000"><i>{ Country specific string-to-uppercase conversion. Requires DOS unit } 
       </i></font><font color="#FF0000"><b>label                                                                  
         </b></font>fail<font color="#000080">;                                                                
       </font><font color="#FF0000"><b>var                                                                    
         </b></font>regs <font color="#000080">: </font>registers<font color="#000080">;                                                    
         </font>x    <font color="#000080">: </font>byte<font color="#000080">;                                                         
       </font><font color="#FF0000"><b>begin                                                                  
         if </b></font>lo<font color="#000080">(</font>DosVersion<font color="#000080">) &gt;= </font><font color="#800000">4 </font><font color="#FF0000"><b>then begin                                    
           with </b></font>regs <font color="#FF0000"><b>do begin                                                 
             </b></font>ax <font color="#000080">:= </font><font color="#800000">$6521</font><font color="#000080">;                                                     
             </font>ds <font color="#000080">:= </font>seg<font color="#000080">(</font>s<font color="#000080">);                                                    
             </font>dx <font color="#000080">:= </font>ofs<font color="#000080">(</font>s<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">]);                                                 
             </font>cx <font color="#000080">:= </font>length<font color="#000080">(</font>s<font color="#000080">);                                                 
             </font>msdos<font color="#000080">(</font>regs<font color="#000080">);                                                     
             </font><font color="#FF0000"><b>if </b></font>odd<font color="#000080">(</font>flags<font color="#000080">) </font><font color="#FF0000"><b>then </b></font><font color="#008000"><i>{ the attempted conversion failed so }        
               </i></font><font color="#FF0000"><b>goto </b></font>fail<font color="#000080">;                                                     
           </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ with }                                                      
         </i></font><font color="#FF0000"><b>end </b></font><font color="#008000"><i>{ if DOS &gt;= 4.0 } </i></font><font color="#FF0000"><b>else                                           
       </b></font>fail<font color="#000080">:                                                                  
           </font><font color="#FF0000"><b>for </b></font>x <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>length<font color="#000080">(</font>s<font color="#000080">) </font><font color="#FF0000"><b>do                                         
             </b></font>s<font color="#000080">[</font>x<font color="#000080">] := </font>UpCase<font color="#000080">(</font>s<font color="#000080">[</font>x<font color="#000080">]);                                            
         </font>StrUpper <font color="#000080">:= </font>s<font color="#000080">;                                                       
       </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ StrUpper }                                                      



</i></font><font color="#800000">5</font><font color="#000080">...
                                                                              
   </font>Q<font color="#000080">. </font>When I include ANSI codes <font color="#FF0000"><b>in </b></font>a <font color="#FF0000"><b>string and </b></font>write that <font color="#FF0000"><b>string to </b></font>the      
      screen the actual codes appear <font color="#FF0000"><b>on </b></font>the screen<font color="#000080">, </font>rather than the results   
      they are supposed <font color="#FF0000"><b>to </b></font>achieve<font color="#000080">.                                           
                                                                              
   </font>A<font color="#000080">. </font><font color="#FF0000"><b>In </b></font>order <font color="#FF0000"><b>for </b></font>ANSI codes <font color="#FF0000"><b>to </b></font>be interpreted<font color="#000080">, </font>screen writes must be        
      directed through DOS <font color="#FF0000"><b>and </b></font>there must have been a suitable driver loaded  
      via the config<font color="#000080">.</font>sys <font color="#FF0000"><b>file </b></font>at boot time<font color="#000080">.  </font>All output can be directed       
      through DOS <font color="#FF0000"><b>and </b></font>the driver by <font color="#000080">-                                         
                                                                              
      </font><font color="#FF0000"><b>Not </b></font>using the crt <font color="#FF0000"><b>unit                                                  
                                                                              
      OR </b></font><font color="#000080">-                                                                    
                                                                              
      </font>assign<font color="#000080">(</font>output<font color="#000080">,</font><font color="#800000">''</font><font color="#000080">);                                                      
      </font>rewrite<font color="#000080">(</font>output<font color="#000080">);                                                        
                                                                              
      </font><font color="#FF0000"><b>in </b></font>which <font color="#FF0000"><b>case </b></font>ALL screen writes are <font color="#000080">&quot;</font>ANSI code sensitive<font color="#000080">&quot;               
                                                                              
      </font><font color="#FF0000"><b>OR </b></font><font color="#000080">-                                                                    
                                                                              
      </font>You can <font color="#FF0000"><b>set </b></font>up write procedures that will be <font color="#000080">&quot;</font>ANSI code sensitive<font color="#000080">&quot;.     
      (</font>You will need an initialisation <font color="#FF0000"><b>procedure to set </b></font>this up<font color="#000080">.)             
                                                                              
      </font><font color="#FF0000"><b>var                                                                     
        </b></font>ansi <font color="#000080">: </font>text<font color="#000080">;                                                          
                                                                              
      </font><font color="#FF0000"><b>procedure </b></font>AssignANSI<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>ansifile <font color="#000080">: </font>text<font color="#000080">);                              
        </font><font color="#FF0000"><b>begin                                                                 
          </b></font>assign<font color="#000080">(</font>ansifile<font color="#000080">,</font><font color="#800000">'CON'</font><font color="#000080">);                                             
          </font>rewrite<font color="#000080">(</font>ansifile<font color="#000080">);                                                  
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ AssignANSI }                                                   
                                                                              
      </i></font><font color="#FF0000"><b>procedure </b></font>WriteANSI<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>st<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">);                                    
        </font><font color="#FF0000"><b>begin                                                                 
          </b></font>write<font color="#000080">(</font>ansi<font color="#000080">,</font>st<font color="#000080">)                                                      
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ WriteANSI }                                                    
                                                                              
      </i></font><font color="#FF0000"><b>procedure </b></font>WriteLnANSI<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>st<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">);                                  
        </font><font color="#FF0000"><b>begin                                                                 
          </b></font>writeANSI<font color="#000080">(</font>st<font color="#000080">);                                                      
          </font>writeln<font color="#000080">(</font>ansi<font color="#000080">);                                                      
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ WriteANSI }                                                    
                                                                              
      </i></font>ObviousLy<font color="#000080">, </font><font color="#FF0000"><b>if </b></font>the ANSI<font color="#000080">.</font>SYS driver <font color="#000080">(</font><font color="#FF0000"><b>or </b></font>an equivalent<font color="#000080">) </font><font color="#FF0000"><b>is not </b></font>installed   
      none <font color="#FF0000"><b>of </b></font>the above can work<font color="#000080">.                                             
                                                                              
      </font>Setting the variable DirectVideo <font color="#FF0000"><b>in </b></font>the CRT <font color="#FF0000"><b>unit to </b></font>false will <font color="#FF0000"><b>not      
      </b></font>achieve the desired result <font color="#FF0000"><b>as </b></font>this merely turns off direct screen       
      writes <font color="#FF0000"><b>and uses </b></font>the BIOS <font color="#FF0000"><b>for </b></font>all screen output<font color="#000080">.                         


</font><font color="#800000">6</font><font color="#000080">...
                                                                              
   </font>Q<font color="#000080">. </font>When I <font color="#FF0000"><b>try to </b></font>shell <font color="#FF0000"><b>to </b></font>DOS nothing happens<font color="#000080">. </font>What am I doing wrong<font color="#000080">?      
                                                                              
   </font>A<font color="#000080">. </font><font color="#FF0000"><b>In </b></font>order <font color="#FF0000"><b>to </b></font>be able <font color="#FF0000"><b>to </b></font>execute any child process there must be          
      sufficient memory available <font color="#FF0000"><b>for </b></font>it <font color="#FF0000"><b>to </b></font>load <font color="#FF0000"><b>and </b></font>execute<font color="#000080">.  </font>Unless you     
      advise differently at compile time<font color="#000080">, </font>a Turbo <font color="#FF0000"><b>Pascal program </b></font>grabs all    
      available memory <font color="#FF0000"><b>for </b></font>itself when it <font color="#FF0000"><b>is </b></font>loaded<font color="#000080">.  </font><font color="#FF0000"><b>To </b></font>reserve memory <font color="#FF0000"><b>for </b></font>a 
      child process use the compiler memory directive <font color="#000080">-                       
                                                                              
        </font><font color="#008000"><i>{$M 16384,0,0)                                                        
      the default is -                                                        
        {$M 16384,0,655360}                                                   
                                                                              
      </i></font>The first figure <font color="#000080">- </font>StackMin <font color="#000080">- </font><font color="#FF0000"><b>is </b></font>the amount <font color="#FF0000"><b>of </b></font>memory <font color="#FF0000"><b>to </b></font>be allocated   
      <font color="#FF0000"><b>for </b></font>the stack<font color="#000080">:                                                          
                                                                              
      </font>Minimum <font color="#FF0000"><b>is</b></font><font color="#000080">:    </font><font color="#800000">1024                                                     
      </font><font color="#FF0000"><b>Default is</b></font><font color="#000080">:   </font><font color="#800000">16384                                                     
      </font>Maximum <font color="#FF0000"><b>is</b></font><font color="#000080">:   </font><font color="#800000">65520                                                     
                                                                              
      </font>The next figure <font color="#000080">- </font>HeapMin <font color="#000080">-</font><font color="#FF0000"><b>is </b></font>the minumum amount <font color="#FF0000"><b>of </b></font>memory <font color="#FF0000"><b>to </b></font>be        
      allocated <font color="#FF0000"><b>for </b></font>the heap<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>there <font color="#FF0000"><b>is </b></font>less memory available than this     
      figure the <font color="#FF0000"><b>program </b></font>will <font color="#FF0000"><b>not </b></font>load<font color="#000080">.                                       
                                                                              
      </font>Minimum <font color="#FF0000"><b>is</b></font><font color="#000080">:          </font><font color="#800000">0                                                  
      </font><font color="#FF0000"><b>Default is</b></font><font color="#000080">:          </font><font color="#800000">0                                                  
      </font>Maximum <font color="#FF0000"><b>is</b></font><font color="#000080">:     </font><font color="#800000">655360  </font><font color="#FF0000"><b>In </b></font>practice it will be the amount <font color="#FF0000"><b>of </b></font>free       
                              memory less the space required <font color="#FF0000"><b>for </b></font>the stack<font color="#000080">,   
                              </font>less the code space <font color="#FF0000"><b>of </b></font>the <font color="#FF0000"><b>program</b></font><font color="#000080">.  </font>You should 
                              <font color="#FF0000"><b>set </b></font>this <font color="#FF0000"><b>to </b></font><font color="#800000">0 </font>unless your <font color="#FF0000"><b>program uses </b></font>the      
                              heap<font color="#000080">.  </font><font color="#FF0000"><b>In </b></font>that <font color="#FF0000"><b>case</b></font><font color="#000080">, </font><font color="#FF0000"><b>set </b></font>it <font color="#FF0000"><b>to </b></font>the lowest       
                              possible figure <font color="#FF0000"><b>to </b></font>prevent heap allocation      
                              errors<font color="#000080">.  </font><font color="#FF0000"><b>In </b></font>most cases it <font color="#FF0000"><b>is </b></font>best <font color="#FF0000"><b>to </b></font>leave it   
                              at zero <font color="#FF0000"><b>and do </b></font>error checking within the        
                              <font color="#FF0000"><b>program for </b></font>sufficient memory at allocation     
                              time<font color="#000080">.                                           
                                                                              
      </font>The last figure <font color="#FF0000"><b>is </b></font>the crucial <font color="#FF0000"><b>on as </b></font>regards child processes<font color="#000080">.  </font>It       
      should always be low enough <font color="#FF0000"><b>to </b></font>leave memory left over <font color="#FF0000"><b>for </b></font>a child       
      process <font color="#FF0000"><b>and </b></font>high enough <font color="#FF0000"><b>not to </b></font>cause problems <font color="#FF0000"><b>for </b></font>the <font color="#FF0000"><b>program </b></font>when      
      allocating heap memory<font color="#000080">.                                                 
                                                                              
      </font>Minimum <font color="#FF0000"><b>is</b></font><font color="#000080">:  </font>HeapMin                                                    
      <font color="#FF0000"><b>Default is</b></font><font color="#000080">:  </font><font color="#800000">655360                                                     
      </font>Maximum <font color="#FF0000"><b>is</b></font><font color="#000080">:  </font><font color="#800000">655360     </font><font color="#FF0000"><b>If </b></font>less than the requested amount <font color="#FF0000"><b>is </b></font>available  
                              no error <font color="#FF0000"><b>is </b></font>reorted<font color="#000080">.  </font>Instead all available     
                              memory <font color="#FF0000"><b>is </b></font>allocated <font color="#FF0000"><b>for </b></font>heap use<font color="#000080">.               



</font><font color="#800000">7</font><font color="#000080">...
                                                                              
   </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I shell <font color="#FF0000"><b>to </b></font>DOS<font color="#000080">?                                                  
                                                                              
   </font>A<font color="#000080">. </font>SwapVectors<font color="#000080">;                                                            
      </font>exec<font color="#000080">(</font>GetEnv<font color="#000080">(</font><font color="#800000">'COMSPEC'</font><font color="#000080">,</font><font color="#800000">''</font><font color="#000080">);                                              
      </font>SwapVectors<font color="#000080">;                                                            
                                                                              
      </font>Read previous section <font color="#FF0000"><b>on </b></font>memory allocation<font color="#000080">.                             
                                                                              
      </font>I find that it <font color="#FF0000"><b>is </b></font>a good idea <font color="#FF0000"><b>to </b></font>write my own Exec <font color="#FF0000"><b>function </b></font>which will  
      <font color="#FF0000"><b>do </b></font>everything that <font color="#FF0000"><b>is </b></font>needed <font color="#FF0000"><b>for </b></font>me<font color="#000080">.  </font>I have it return an integer value 
      that <font color="#FF0000"><b>is </b></font>the DosError code<font color="#000080">.                                              
                                                                              
      </font><font color="#FF0000"><b>function </b></font>Exec<font color="#000080">(</font>p1<font color="#000080">,</font>p2<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">);                                           
        </font><font color="#FF0000"><b>begin                                                                 
          </b></font>SwapVectors<font color="#000080">;                                                        
          </font>Dos<font color="#000080">.</font>Exec<font color="#000080">(</font>p1<font color="#000080">,</font>p2<font color="#000080">);                                                    
          </font>SwapVectors<font color="#000080">;                                                        
          </font>Exec <font color="#000080">:= </font>DosError<font color="#000080">;                                                   
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;                                                                  
                                                                              
      </font>This enables me <font color="#FF0000"><b>to </b></font>have a statement such <font color="#FF0000"><b>as </b></font><font color="#000080">-                           
                                                                              
      </font>ReportError<font color="#000080">(</font>Exec<font color="#000080">(</font>GetEnv<font color="#000080">(</font><font color="#800000">'COMPSEC'</font><font color="#000080">),</font><font color="#800000">''</font><font color="#000080">));                                
                                                                              
      </font>Now you can have an empty ReportError <font color="#FF0000"><b>procedure or </b></font>you can make it      
      report the error <font color="#000080">- </font>whatever <font color="#FF0000"><b>is </b></font>suitable <font color="#FF0000"><b>for </b></font>you application<font color="#000080">.            


</font><font color="#800000">8</font><font color="#000080">...
                                                                              
   </font>Q<font color="#000080">. </font>When I execute a child process redirection does <font color="#FF0000"><b>not </b></font>work<font color="#000080">. </font>Why<font color="#000080">?          
                                                                              
   </font>A<font color="#000080">. </font>Redirection <font color="#FF0000"><b>of </b></font>a child process<font color="#800000">'s output only works if it is run under   
      </font>another copy <font color="#FF0000"><b>of </b></font>the command processor<font color="#000080">.  </font>So <font color="#000080">-                            
                                                                              
      </font>exec<font color="#000080">(</font><font color="#800000">'YourProg.exe'</font><font color="#000080">,</font><font color="#800000">' &gt; nul'</font><font color="#000080">);    </font>will <font color="#FF0000"><b>not </b></font>work but                     
      exec<font color="#000080">(</font>GetEnv<font color="#000080">(</font><font color="#800000">'COMSPEC'</font><font color="#000080">),</font><font color="#800000">'/c YourProg &gt; nul'</font><font color="#000080">); </font>will work<font color="#000080">.                 


</font><font color="#800000">9</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I read an errorlevel from a child process<font color="#000080">?

   </font>A<font color="#000080">. </font>After executing a child process the errorlevel returned can be read
      by calling the DosExitCode <font color="#FF0000"><b>function </b></font>which returns a word<font color="#000080">.  </font>The low
      byte <font color="#FF0000"><b>is </b></font>the errorlevel<font color="#000080">.  </font>A full description <font color="#FF0000"><b>is in </b></font>the manual<font color="#000080">.

      </font><font color="#FF0000"><b>If </b></font>the command interpreter <font color="#FF0000"><b>is </b></font>the child process <font color="#FF0000"><b>and </b></font>it <font color="#FF0000"><b>in </b></font>turn
      executes a child process <font color="#FF0000"><b>then </b></font>the errorlevel <font color="#FF0000"><b>of </b></font>the second child
      process cannot be read without resorting <font color="#FF0000"><b>to </b></font>some trickery<font color="#000080">.


</font><font color="#800000">10</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>When I read a text <font color="#FF0000"><b>file </b></font>that has lines exceeding <font color="#800000">255 </font>characters I
      lose all those characters from the <font color="#800000">256</font>th one <font color="#FF0000"><b>on </b></font>each time there <font color="#FF0000"><b>is </b></font>a
      line that exceeds that length<font color="#000080">.  </font>How can I prevent this<font color="#000080">?

   </font>A<font color="#000080">. </font>Turbo <font color="#FF0000"><b>Pascal</b></font><font color="#800000">'s readln procedure reads a line up to the 255th
      </font>character <font color="#FF0000"><b>then </b></font>skips <font color="#FF0000"><b>to </b></font>the next line<font color="#000080">.  </font><font color="#FF0000"><b>To </b></font>get around this you
      should declare a buffer at least <font color="#FF0000"><b>as </b></font>large <font color="#FF0000"><b>as </b></font>the longest possible
      line <font color="#FF0000"><b>and then </b></font>use the read <font color="#FF0000"><b>procedure</b></font><font color="#000080">.  </font>The best size <font color="#FF0000"><b>for </b></font>the buffer
      <font color="#FF0000"><b>is </b></font>a multiple <font color="#FF0000"><b>of </b></font><font color="#800000">2048 </font>bytes<font color="#000080">.

      </font><font color="#FF0000"><b>const
        </b></font>BufferSize <font color="#000080">= </font><font color="#800000">2048</font><font color="#000080">;
        </font>LineLength <font color="#000080">= </font><font color="#800000">78</font><font color="#000080">;
      </font><font color="#FF0000"><b>type
        </b></font>textbuffer <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font>BufferSize<font color="#000080">] </font><font color="#FF0000"><b>of </b></font>char<font color="#000080">;
      </font><font color="#FF0000"><b>var
        </b></font>st          <font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">;
        </font>f           <font color="#000080">: </font>text<font color="#000080">;
        </font>buffer      <font color="#000080">: </font>textbuffer<font color="#000080">;

      </font><font color="#FF0000"><b>function </b></font>ReadTxtLn<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>tf<font color="#000080">: </font>text<font color="#000080">; </font><font color="#FF0000"><b>var </b></font>s<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font>max<font color="#000080">: </font>byte<font color="#000080">): </font>integer<font color="#000080">;
        </font><font color="#008000"><i>{ Reads a string of a maximum length from a text file }
        </i></font><font color="#FF0000"><b>var
          </b></font>len         <font color="#000080">: </font>byte <font color="#FF0000"><b>absolute </b></font>s<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>len <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
          </font><font color="#008000"><i>{$I-}
          </i></font><font color="#FF0000"><b>while </b></font><font color="#000080">(</font>len <font color="#000080">&lt; </font>max<font color="#000080">) </font><font color="#FF0000"><b>and not </b></font>eoln<font color="#000080">(</font>tf<font color="#000080">) </font><font color="#FF0000"><b>do begin
            </b></font>inc<font color="#000080">(</font>len<font color="#000080">);
            </font>read<font color="#000080">(</font>tf<font color="#000080">);
          </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
          </font><font color="#FF0000"><b>if </b></font>eoln<font color="#000080">(</font>tf<font color="#000080">) </font><font color="#FF0000"><b>then
            </b></font>readln<font color="#000080">(</font>tf<font color="#000080">);
          </font>ReadTxtLn <font color="#000080">:= </font>IOResult<font color="#000080">;
          </font><font color="#008000"><i>{$I+}
        </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ ReadTxtLn }

      </i></font><font color="#FF0000"><b>begin
        </b></font>assign<font color="#000080">(</font>f<font color="#000080">,</font>filename<font color="#000080">);
        </font>reset<font color="#000080">(</font>f<font color="#000080">);
        </font>SetTextBuf<font color="#000080">(</font>f<font color="#000080">,</font>buffer<font color="#000080">);
        </font><font color="#FF0000"><b>while not </b></font>eof<font color="#000080">(</font>f<font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>ReadTxtLn<font color="#000080">(</font>f<font color="#000080">,</font>st<font color="#000080">,</font>LineLength<font color="#000080">) = </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>do
          </b></font>writeln<font color="#000080">(</font>st<font color="#000080">);
        </font>close<font color="#000080">(</font>f<font color="#000080">);
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">.


</font><font color="#800000">11</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I convert nul terminated asciiz strings <font color="#FF0000"><b>to </b></font>Turbo <font color="#FF0000"><b>Pascal
      </b></font>strings<font color="#000080">?

   </font>A<font color="#000080">. </font>Here <font color="#FF0000"><b>is </b></font>a <font color="#FF0000"><b>function </b></font>that will <font color="#FF0000"><b>do </b></font>that <font color="#000080">-

      </font><font color="#FF0000"><b>function </b></font>Asc2Str<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>s<font color="#000080">; </font>max<font color="#000080">: </font>byte<font color="#000080">): </font><font color="#FF0000"><b>string</b></font><font color="#000080">;
        </font><font color="#008000"><i>{ Converts an ASCIIZ string to a Turbo Pascal string }
        { with a maximum length of max.                      }
        </i></font><font color="#FF0000"><b>var </b></font>starray  <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">255</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>char <font color="#FF0000"><b>absolute </b></font>s<font color="#000080">;
            </font>len      <font color="#000080">: </font>integer<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>len        <font color="#000080">:= </font>pos<font color="#000080">(</font><font color="#800000">#0</font><font color="#000080">,</font>starray<font color="#000080">)-</font><font color="#800000">1</font><font color="#000080">;              </font><font color="#008000"><i>{ Get the length }
          </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>len <font color="#000080">&gt; </font>max<font color="#000080">) </font><font color="#FF0000"><b>or </b></font><font color="#000080">(</font>len <font color="#000080">&lt; </font><font color="#800000">0</font><font color="#000080">) </font><font color="#FF0000"><b>then      </b></font><font color="#008000"><i>{ length exceeds maximum }
            </i></font>len      <font color="#000080">:= </font>max<font color="#000080">;                         </font><font color="#008000"><i>{ so set to maximum }
          </i></font>Asc2Str    <font color="#000080">:= </font>starray<font color="#000080">;
          </font>Asc2Str<font color="#000080">[</font><font color="#800000">0</font><font color="#000080">] := </font>chr<font color="#000080">(</font>len<font color="#000080">);                           </font><font color="#008000"><i>{ Set length }
        </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ Asc2Str }


</i></font><font color="#800000">12</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How can I tell <font color="#FF0000"><b>if </b></font>a particular bit <font color="#FF0000"><b>of </b></font>a variable <font color="#FF0000"><b>is set or not</b></font><font color="#000080">? </font>How can
      I <font color="#FF0000"><b>set </b></font>it<font color="#000080">?  </font>How can I turn it off<font color="#000080">? </font>How can I make a large bit map <font color="#FF0000"><b>and
      then </b></font>determine <font color="#FF0000"><b>if </b></font>a particular bit <font color="#000080">- </font>say bit <font color="#800000">10000 </font><font color="#FF0000"><b>is on</b></font><font color="#000080">/</font><font color="#FF0000"><b>of</b></font><font color="#000080">?

   </font>A<font color="#000080">. </font>This question<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>a variation <font color="#FF0000"><b>of </b></font>it<font color="#000080">, </font><font color="#FF0000"><b>is </b></font>one <font color="#FF0000"><b>of </b></font>the most commonly asked
      questions <font color="#FF0000"><b>in </b></font>the echo <font color="#FF0000"><b>and </b></font>there are several ways <font color="#FF0000"><b>of </b></font>doing what <font color="#FF0000"><b>is
      </b></font>wanted<font color="#000080">.  </font>None are necessarily right <font color="#FF0000"><b>or </b></font>wrong<font color="#000080">.  </font>The way I will describe
      <font color="#FF0000"><b>is </b></font>designed <font color="#FF0000"><b>to </b></font>take up <font color="#FF0000"><b>as </b></font>little code<font color="#000080">/</font>data space <font color="#FF0000"><b>as </b></font>possible<font color="#000080">.  </font>I <font color="#FF0000"><b>do not
      </b></font>attempt <font color="#FF0000"><b>to </b></font>explain the theory behind these functions <font color="#FF0000"><b>as </b></font>this can be
      obtained from any good book<font color="#000080">. </font>Question <font color="#800000">16 </font>also <font color="#FF0000"><b>contains </b></font>valuable extra
      help <font color="#FF0000"><b>on </b></font>the subject <font color="#FF0000"><b>of </b></font>truth tables<font color="#000080">.

      </font>The use <font color="#FF0000"><b>of </b></font>sets can be the best bit manipulation method <font color="#FF0000"><b>if </b></font>you have
      control over the data being used<font color="#000080">. </font>Here <font color="#FF0000"><b>is </b></font>an example <font color="#FF0000"><b>of </b></font>a byte variable
      <font color="#FF0000"><b>for </b></font>a BBS <font color="#FF0000"><b>program </b></font>which sets various user access level flags<font color="#000080">.

         </font>Bit <font color="#800000">0 </font><font color="#000080">= </font>Registered User
             <font color="#800000">1 </font><font color="#000080">= </font>Twit
             <font color="#800000">2 </font><font color="#000080">= </font>Normal
             <font color="#800000">3 </font><font color="#000080">= </font>Extra
             <font color="#800000">4 </font><font color="#000080">= </font>Privileged
             <font color="#800000">5 </font><font color="#000080">= </font>Visiting Sysop
             <font color="#800000">6 </font><font color="#000080">= </font>Assistant Sysop
             <font color="#800000">7 </font><font color="#000080">= </font>Sysop

       <font color="#FF0000"><b>type
         </b></font>status_type  <font color="#000080">= (</font>Registered<font color="#000080">,
                         </font>Twit<font color="#000080">,
                         </font>Normal<font color="#000080">,
                         </font>Extra<font color="#000080">,
                         </font>Privileged<font color="#000080">,
                         </font>VisitingSysop<font color="#000080">,
                         </font>AssistantSysop<font color="#000080">,
                         </font>Sysop<font color="#000080">);
          </font>status_level <font color="#000080">= </font><font color="#FF0000"><b>set of </b></font>status_type<font color="#000080">;

       </font><font color="#FF0000"><b>var
         </b></font>access_flags  <font color="#000080">: </font>status_level<font color="#000080">;

      </font>Let us assume you have someone who logs <font color="#FF0000"><b>on and </b></font>you wish <font color="#FF0000"><b>to </b></font>determine
      his user access level<font color="#000080">.  </font>After reading access_flags from the user data
      <font color="#FF0000"><b>file </b></font><font color="#000080">-

           </font><font color="#FF0000"><b>if </b></font>Sysop <font color="#FF0000"><b>in </b></font>access_flags <font color="#FF0000"><b>then </b></font><font color="#000080">....

      </font><font color="#FF0000"><b>To set </b></font>the sysop flag <font color="#000080">-

           </font>access_flags <font color="#000080">:= </font>access_flags <font color="#000080">+ [</font>Sysop<font color="#000080">];

      </font><font color="#FF0000"><b>To </b></font>reset the sysop flag <font color="#000080">-

           </font>access_flags <font color="#000080">:= </font>access_flags <font color="#000080">- [</font>Sysop<font color="#000080">];

      </font>However <font color="#FF0000"><b>on </b></font>many occasions using a <font color="#FF0000"><b>set </b></font>may <font color="#FF0000"><b>not </b></font>be a suitable method<font color="#000080">.
      </font>You may simply need <font color="#FF0000"><b>to </b></font>know <font color="#FF0000"><b>if </b></font>bit <font color="#800000">5 </font><font color="#FF0000"><b>is set or not</b></font><font color="#000080">.  </font>Here <font color="#FF0000"><b>is </b></font>the method
      that I consider the best <font color="#000080">-

        </font><font color="#FF0000"><b>function </b></font>BitIsSet<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>V<font color="#000080">,  </font>bit<font color="#000080">: </font>byte<font color="#000080">): </font>boolean<font color="#000080">;
          </font><font color="#FF0000"><b>begin
            </b></font>BitIsSet <font color="#000080">:= </font>odd<font color="#000080">(</font>V <font color="#FF0000"><b>shr </b></font>bit<font color="#000080">);
          </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>To set </b></font>a bit <font color="#000080">-

         </font><font color="#FF0000"><b>procedure </b></font>SetBit<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>V<font color="#000080">: </font>byte<font color="#000080">; </font>bit<font color="#000080">: </font>byte<font color="#000080">);
           </font><font color="#FF0000"><b>begin
             </b></font>V <font color="#000080">:= </font>V <font color="#FF0000"><b>or </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>bit<font color="#000080">);
           </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>To </b></font>reset a bit <font color="#000080">-

         </font><font color="#FF0000"><b>procedure </b></font>ResetBit<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>V<font color="#000080">: </font>byte<font color="#000080">; </font>bit<font color="#000080">: </font>byte<font color="#000080">);
           </font><font color="#FF0000"><b>begin
             </b></font>V <font color="#000080">:= </font>V <font color="#FF0000"><b>and not</b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>bit<font color="#000080">);
           </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>To </b></font>toggle <font color="#000080">(</font>flip<font color="#000080">) </font>a bit <font color="#000080">-

         </font><font color="#FF0000"><b>procedure </b></font>ToggleBit<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>V<font color="#000080">: </font>byte<font color="#000080">; </font>bit<font color="#000080">: </font>byte<font color="#000080">);
           </font><font color="#FF0000"><b>begin
             </b></font>V <font color="#000080">:= </font>V <font color="#FF0000"><b>xor </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font>bit<font color="#000080">);
           </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font>Now a bit map can be made up from an <font color="#FF0000"><b>array of </b></font>bytes<font color="#000080">.  </font><font color="#FF0000"><b>If </b></font>stored <font color="#FF0000"><b>on </b></font>the
      heap you can test any bit up <font color="#FF0000"><b>to </b></font>number <font color="#800000">524159 </font><font color="#000080">(</font>zero based<font color="#000080">).  </font>Here<font color="#800000">'s
      </font>how<font color="#000080">.

      </font><font color="#FF0000"><b>type
        </b></font>map <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>maxsize<font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
        </font><font color="#008000"><i>{ set maxsize to number of bits div 8 -1 needed in the bit map }

      </i></font><font color="#FF0000"><b>function </b></font>BitSetInBitMap<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>x<font color="#000080">; </font>numb <font color="#000080">: </font>longint<font color="#000080">): </font>boolean<font color="#000080">;
        </font><font color="#008000"><i>{ Tests the numb bit in the bitmap array }
        </i></font><font color="#FF0000"><b>var </b></font>m<font color="#000080">: </font>map <font color="#FF0000"><b>absolute </b></font>x<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>BitSetInBitMap <font color="#000080">:= </font>odd<font color="#000080">(</font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] </font><font color="#FF0000"><b>shr </b></font><font color="#000080">(</font>numb <font color="#FF0000"><b>and </b></font><font color="#800000">7</font><font color="#000080">));
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>procedure </b></font>SetBitInBitMap<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>x<font color="#000080">; </font>numb<font color="#000080">: </font>word<font color="#000080">);
        </font><font color="#008000"><i>{ Sets the numb bit in the bitmap array }
        </i></font><font color="#FF0000"><b>var </b></font>m<font color="#000080">: </font>map <font color="#FF0000"><b>absolute </b></font>x<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] := </font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] </font><font color="#FF0000"><b>or </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font><font color="#000080">(</font>numb <font color="#FF0000"><b>and </b></font><font color="#800000">7</font><font color="#000080">))
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>procedure </b></font>ResetBitInBitMap<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>x<font color="#000080">; </font>numb <font color="#000080">: </font>longint<font color="#000080">);
        </font><font color="#008000"><i>{ Resets the numb bit in the bitmap array }
        </i></font><font color="#FF0000"><b>var </b></font>m<font color="#000080">: </font>map <font color="#FF0000"><b>absolute </b></font>x<font color="#000080">;
        </font><font color="#FF0000"><b>begin
         </b></font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] := </font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] </font><font color="#FF0000"><b>and not</b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font><font color="#000080">(</font>numb <font color="#FF0000"><b>and </b></font><font color="#800000">7</font><font color="#000080">));
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>procedure </b></font>ToggleBitInBitMap<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>x<font color="#000080">; </font>numb <font color="#000080">: </font>longint<font color="#000080">);
        </font><font color="#008000"><i>{ Toggles (flips) the numb bit in the bitmap array }
        </i></font><font color="#FF0000"><b>var </b></font>m<font color="#000080">: </font>map <font color="#FF0000"><b>absolute </b></font>x<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] := </font>m<font color="#000080">[</font>numb <font color="#FF0000"><b>shr </b></font><font color="#800000">3</font><font color="#000080">] </font><font color="#FF0000"><b>xor </b></font><font color="#000080">(</font><font color="#800000">1 </font><font color="#FF0000"><b>shl </b></font><font color="#000080">(</font>numb <font color="#FF0000"><b>and </b></font><font color="#800000">7</font><font color="#000080">));
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;


</font><font color="#800000">13</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How can I find a particular <font color="#FF0000"><b>string in </b></font>any <font color="#FF0000"><b>file </b></font><font color="#000080">- </font>text <font color="#FF0000"><b>or </b></font>binary<font color="#000080">?

   </font>A<font color="#000080">. </font>The Boyer<font color="#000080">-</font>Moore <font color="#FF0000"><b>string </b></font>search algorithm <font color="#FF0000"><b>is </b></font>considered <font color="#FF0000"><b>to </b></font>be the fastest
      method available<font color="#000080">.  </font>However <font color="#FF0000"><b>in </b></font>a rare worst<font color="#000080">-</font><font color="#FF0000"><b>case </b></font>scenario it can be
      slightly slower than a linear brute<font color="#000080">-</font>force method<font color="#000080">.  </font>The following
      demonstration <font color="#FF0000"><b>program </b></font>will show how it works <font color="#FF0000"><b>and </b></font>could easily be
      modified <font color="#FF0000"><b>to </b></font>allow <font color="#FF0000"><b>for </b></font>command line paramters etc<font color="#000080">.


      </font><font color="#FF0000"><b>program </b></font>BMSearchDemo<font color="#000080">;

      </font><font color="#FF0000"><b>type
        </b></font>bigarray <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">32767</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
        </font>baptr    <font color="#000080">= ^</font>bigarray<font color="#000080">;
        </font>BMTable  <font color="#000080">= </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">255</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;

      </font><font color="#FF0000"><b>const
        </b></font>KeyStr <font color="#000080">: </font><font color="#FF0000"><b>string </b></font><font color="#000080">= </font><font color="#800000">'Put whatever you want found here'</font><font color="#000080">;
        </font>fname  <font color="#000080">: </font><font color="#FF0000"><b>string </b></font><font color="#000080">= </font><font color="#800000">'f:\Filename.txt'</font><font color="#000080">;

      </font><font color="#FF0000"><b>var
        </b></font>Btable <font color="#000080">: </font>BMtable<font color="#000080">;
        </font>buffer <font color="#000080">: </font>baptr<font color="#000080">;
        </font>f      <font color="#000080">: </font><font color="#FF0000"><b>file</b></font><font color="#000080">;
        </font>result<font color="#000080">,
        </font>position <font color="#000080">: </font>word<font color="#000080">;
        </font>offset <font color="#000080">: </font>longint<font color="#000080">;
        </font>finished<font color="#000080">,
        </font>Strfound  <font color="#000080">: </font>boolean<font color="#000080">;

      </font><font color="#FF0000"><b>procedure </b></font>MakeBMTable<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>t <font color="#000080">: </font>BMtable<font color="#000080">; </font><font color="#FF0000"><b>var </b></font>s<font color="#000080">);
        </font><font color="#008000"><i>{ Makes a Boyer-Moore search table. s = the search string t = the table }
        </i></font><font color="#FF0000"><b>var
          </b></font>st  <font color="#000080">: </font>BMtable <font color="#FF0000"><b>absolute </b></font>s<font color="#000080">;
          </font>slen<font color="#000080">: </font>byte <font color="#FF0000"><b>absolute </b></font>s<font color="#000080">;
          </font>x   <font color="#000080">: </font>byte<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>FillChar<font color="#000080">(</font>t<font color="#000080">,</font>sizeof<font color="#000080">(</font>t<font color="#000080">),</font>slen<font color="#000080">);
          </font><font color="#FF0000"><b>for </b></font>x <font color="#000080">:= </font>slen <font color="#FF0000"><b>downto </b></font><font color="#800000">1 </font><font color="#FF0000"><b>do
            if </b></font><font color="#000080">(</font>t<font color="#000080">[</font>st<font color="#000080">[</font>x<font color="#000080">]] = </font>slen<font color="#000080">) </font><font color="#FF0000"><b>then
              </b></font>t<font color="#000080">[</font>st<font color="#000080">[</font>x<font color="#000080">]] := </font>slen <font color="#000080">- </font>x
        <font color="#FF0000"><b>end</b></font><font color="#000080">;

      </font><font color="#FF0000"><b>function </b></font>BMSearch<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>buff<font color="#000080">,</font>st<font color="#000080">; </font>size <font color="#000080">: </font>word<font color="#000080">): </font>word<font color="#000080">;
        </font><font color="#008000"><i>{ Not quite a standard Boyer-Moore algorithm search routine }
        { To use:  pass buff as a dereferenced pointer to the buffer}
        {          st is the string being searched for              }
        {          size is the size of the buffer                   }
        { If st is not found, returns $ffff                         }
        </i></font><font color="#FF0000"><b>var
          </b></font>buffer <font color="#000080">: </font>bigarray <font color="#FF0000"><b>absolute </b></font>buff<font color="#000080">;
          </font>s      <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">255</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte <font color="#FF0000"><b>absolute </b></font>st<font color="#000080">;
          </font>len    <font color="#000080">: </font>byte <font color="#FF0000"><b>absolute </b></font>st<font color="#000080">;
          </font>s1     <font color="#000080">: </font><font color="#FF0000"><b>string absolute </b></font>st<font color="#000080">;
          </font>s2     <font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">;
          </font>count<font color="#000080">,
          </font>x      <font color="#000080">: </font>word<font color="#000080">;
          </font>found  <font color="#000080">: </font>boolean<font color="#000080">;
        </font><font color="#FF0000"><b>begin
          </b></font>s2<font color="#000080">[</font><font color="#800000">0</font><font color="#000080">] := </font>chr<font color="#000080">(</font>len<font color="#000080">);       </font><font color="#008000"><i>{ sets the length to that of the search string }
          </i></font>found <font color="#000080">:= </font>false<font color="#000080">;
          </font>count <font color="#000080">:= </font>pred<font color="#000080">(</font>len<font color="#000080">);
          </font><font color="#FF0000"><b>while </b></font><font color="#000080">(</font><font color="#FF0000"><b>not </b></font>found<font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>count <font color="#000080">&lt; (</font>size <font color="#000080">- </font>len<font color="#000080">)) </font><font color="#FF0000"><b>do begin
            if </b></font><font color="#000080">(</font>buffer<font color="#000080">[</font>count<font color="#000080">] = </font>s<font color="#000080">[</font>len<font color="#000080">]) </font><font color="#FF0000"><b>then </b></font><font color="#008000"><i>{ there is a partial match } </i></font><font color="#FF0000"><b>begin
              if </b></font>buffer<font color="#000080">[</font>count<font color="#000080">-</font>pred<font color="#000080">(</font>len<font color="#000080">)] = </font>s<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">] </font><font color="#FF0000"><b>then </b></font><font color="#008000"><i>{ less partial! } </i></font><font color="#FF0000"><b>begin
                </b></font>move<font color="#000080">(</font>buffer<font color="#000080">[</font>count<font color="#000080">-</font>pred<font color="#000080">(</font>len<font color="#000080">)],</font>s2<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">],</font>len<font color="#000080">);
                </font>found <font color="#000080">:= </font>s1 <font color="#000080">= </font>s2<font color="#000080">;                   </font><font color="#008000"><i>{ if = it is a complete match }
                </i></font>BMSearch <font color="#000080">:= </font>count <font color="#000080">- </font>pred<font color="#000080">(</font>len<font color="#000080">);      </font><font color="#008000"><i>{ will stick unless not found }
              </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
              </font>inc<font color="#000080">(</font>count<font color="#000080">);                </font><font color="#008000"><i>{ bump by one char - match is irrelevant }
            </i></font><font color="#FF0000"><b>end
            else
              </b></font>inc<font color="#000080">(</font>count<font color="#000080">,</font>Btable<font color="#000080">[</font>buffer<font color="#000080">[</font>count<font color="#000080">]]);   </font><font color="#008000"><i>{ no match so increment maximum }
          </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
          </font><font color="#FF0000"><b>if not </b></font>found <font color="#FF0000"><b>then
            </b></font>BMSearch <font color="#000080">:= </font><font color="#800000">$ffff</font><font color="#000080">;
        </font><font color="#FF0000"><b>end</b></font><font color="#000080">;  </font><font color="#008000"><i>{ BMSearch }


      </i></font><font color="#FF0000"><b>begin
        </b></font>new<font color="#000080">(</font>buffer<font color="#000080">);
        </font>assign<font color="#000080">(</font>f<font color="#000080">,</font>fname<font color="#000080">);
        </font>reset<font color="#000080">(</font>f<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
        </font>offset <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
        </font>MakeBMTable<font color="#000080">(</font>Btable<font color="#000080">,</font>KeyStr<font color="#000080">);
        </font><font color="#FF0000"><b>repeat
          </b></font>BlockRead<font color="#000080">(</font>f<font color="#000080">,</font>buffer<font color="#000080">^,</font>sizeof<font color="#000080">(</font>buffer<font color="#000080">^),</font>result<font color="#000080">);
          </font>position <font color="#000080">:= </font>BMSearch<font color="#000080">(</font>buffer<font color="#000080">^,</font>KeyStr<font color="#000080">,</font>result<font color="#000080">);
          </font>finished <font color="#000080">:= (</font>result <font color="#000080">&lt; </font>sizeof<font color="#000080">(</font>buffer<font color="#000080">^)) </font><font color="#FF0000"><b>or </b></font><font color="#000080">(</font>position <font color="#000080">&lt;&gt; </font><font color="#800000">$ffff</font><font color="#000080">);
          </font><font color="#FF0000"><b>if </b></font>position <font color="#000080">= </font><font color="#800000">$ffff </font><font color="#FF0000"><b>then
            </b></font>inc<font color="#000080">(</font>offset<font color="#000080">,</font>result<font color="#000080">);
          </font>Strfound <font color="#000080">:= </font>position <font color="#000080">&lt;&gt; </font><font color="#800000">$ffff</font><font color="#000080">;
        </font><font color="#FF0000"><b>until </b></font>finished<font color="#000080">;
        </font>close<font color="#000080">(</font>f<font color="#000080">);
        </font><font color="#FF0000"><b>if </b></font>Strfound <font color="#FF0000"><b>then
          </b></font>writeln<font color="#000080">(</font><font color="#800000">'Found at offset '</font><font color="#000080">,</font>offset<font color="#000080">)
        </font><font color="#FF0000"><b>else
          </b></font>writeln<font color="#000080">(</font><font color="#800000">'Not found'</font><font color="#000080">);
      </font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font><font color="#800000">14</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>How can I put a apostrophe <font color="#FF0000"><b>in </b></font>a <font color="#FF0000"><b>string</b></font><font color="#000080">?

   </font>A<font color="#000080">. </font>Just put <font color="#FF0000"><b>in </b></font>extra apostrophes<font color="#000080">.  </font><font color="#FF0000"><b>If </b></font>you want st <font color="#FF0000"><b>to </b></font>be equal <font color="#FF0000"><b>to </b></font>the
      <font color="#FF0000"><b>string </b></font><font color="#000080">-
        </font>The word <font color="#800000">'quoted' </font><font color="#FF0000"><b>is in </b></font>quotes
      <font color="#FF0000"><b>do </b></font>this <font color="#000080">-
        </font>st <font color="#000080">:= </font><font color="#800000">'The word ''quoted'' is in quotes'</font><font color="#000080">;

      </font><font color="#FF0000"><b>if </b></font>you want the following <font color="#FF0000"><b>to </b></font>be written <font color="#FF0000"><b>to </b></font>screen <font color="#000080">-
        </font><font color="#800000">'This is a quoted string'
      </font><font color="#FF0000"><b>do </b></font>this <font color="#000080">-
        </font>writeln<font color="#000080">(</font><font color="#800000">'''This is a quoted string'''</font><font color="#000080">);


</font><font color="#800000">15</font><font color="#000080">...

   </font>Q<font color="#000080">. </font>What are the best books <font color="#FF0000"><b>to </b></font>purchase <font color="#FF0000"><b>to </b></font>help me learn Turbo <font color="#FF0000"><b>Pascal</b></font><font color="#000080">?

   </font>A<font color="#000080">. </font>There are many good books <font color="#FF0000"><b>for </b></font>learners<font color="#000080">.  </font>Here are a few <font color="#000080">-

      </font>Complete Turbo <font color="#FF0000"><b>Pascal </b></font><font color="#000080">- </font>Third Edition <font color="#000080">- </font>Jeff Duntemann
      Mastering Turbo <font color="#FF0000"><b>Pascal </b></font><font color="#800000">6 </font><font color="#000080">- </font>Tom Swann
      Turbo <font color="#FF0000"><b>Pascal </b></font><font color="#000080">- </font>The Complete Reference <font color="#000080">- </font>O<font color="#800000">'Brien.

      </font><font color="#FF0000"><b>For </b></font>advanced users there are also many good books<font color="#000080">.  </font>Here are a few
      that I have found useful <font color="#000080">- (</font>Those marked <font color="#FF0000"><b>with </b></font>an asterisk are <font color="#FF0000"><b>not
      </b></font>purely <font color="#FF0000"><b>for </b></font>Turbo <font color="#FF0000"><b>Pascal</b></font><font color="#000080">)

      </font>Turbo <font color="#FF0000"><b>Pascal </b></font><font color="#800000">6 </font><font color="#000080">- </font>Techniques <font color="#FF0000"><b>and </b></font>Utilities <font color="#000080">- </font>Rubenking
      Turbo <font color="#FF0000"><b>Pascal </b></font>Internals <font color="#000080">- </font>Tischer
      <font color="#000080">* </font>PC System Programming <font color="#FF0000"><b>for </b></font>Developers <font color="#000080">- </font>Tischer
      <font color="#000080">* </font>Undocumented DOS <font color="#000080">- </font>Schulman

      Any learner would be well advised <font color="#FF0000"><b>to </b></font>obtain a well known <font color="#FF0000"><b>library
      </b></font>such <font color="#FF0000"><b>as </b></font>Technojock<font color="#800000">'s Turbo Toolkit (TTT) which is shareware and
      </font>study the source code<font color="#000080">.

 </font><font color="#800000">16.

   </font>Q<font color="#000080">. </font>hat are <font color="#000080">&quot;</font>truth tables<font color="#000080">&quot; </font><font color="#FF0000"><b>and </b></font>how <font color="#FF0000"><b>do </b></font>they work<font color="#000080">?

   </font>A<font color="#000080">. </font>Truth tables are a <font color="#FF0000"><b>set of </b></font>rules that are used <font color="#FF0000"><b>to </b></font>determine the result <font color="#FF0000"><b>of
      </b></font>logical operations<font color="#000080">.  </font>The logical operators are <font color="#000080">-

        </font><font color="#FF0000"><b>NOT
        AND
        OR
        XOR</b></font><font color="#000080">.

      </font>Here <font color="#FF0000"><b>is </b></font>a brief explanation <font color="#FF0000"><b>of </b></font>truth tables<font color="#000080">.  </font>When two values are
      logically compared by using a logical operator each bit <font color="#FF0000"><b>of </b></font>one value <font color="#FF0000"><b>is
      </b></font>directly compared <font color="#FF0000"><b>to </b></font>the corresponding bit <font color="#FF0000"><b>in </b></font>the other value <font color="#FF0000"><b>and </b></font>the
      same bit <font color="#FF0000"><b>in </b></font>the returned value <font color="#FF0000"><b>is set or </b></font>reset according <font color="#FF0000"><b>to </b></font>the
      following truth table<font color="#000080">.

             </font><font color="#FF0000"><b>NOT         AND             OR            XOR
         not </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">0    0 </font><font color="#FF0000"><b>and </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">0    0 </font><font color="#FF0000"><b>or </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">0    0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">0
         </font><font color="#FF0000"><b>not </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">1    0 </font><font color="#FF0000"><b>and </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">0    0 </font><font color="#FF0000"><b>or </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">1    0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">1
                      1 </font><font color="#FF0000"><b>and </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">0    1 </font><font color="#FF0000"><b>or </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">1    1 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">1
                      1 </font><font color="#FF0000"><b>and </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">1    1 </font><font color="#FF0000"><b>or </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">1    1 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">0

      </font><font color="#FF0000"><b>NOT </b></font>reverses the bit<font color="#000080">.
      </font><font color="#FF0000"><b>AND </b></font>sets the returned bit <font color="#FF0000"><b>if </b></font>both compared bits are <font color="#FF0000"><b>set</b></font><font color="#000080">.
      </font><font color="#FF0000"><b>OR  </b></font>sets the returned bit <font color="#FF0000"><b>if </b></font>either <font color="#FF0000"><b>of </b></font>the compared bits are <font color="#FF0000"><b>set</b></font><font color="#000080">.
      </font><font color="#FF0000"><b>XOR </b></font>sets the returned bit <font color="#FF0000"><b>if </b></font>the compared bits are <font color="#FF0000"><b>not </b></font>the same<font color="#000080">.


 </font><font color="#800000">17.

   </font>Q<font color="#000080">. </font>What are pointers <font color="#FF0000"><b>and </b></font>how can I use them<font color="#000080">?  </font>I have heard that they are
      variables that can be created <font color="#FF0000"><b>and </b></font>discarded <font color="#FF0000"><b>as </b></font>required thus saving
      memory<font color="#000080">.  </font><font color="#FF0000"><b>Is </b></font>this true<font color="#000080">?

   </font>A<font color="#000080">. </font>A pointer <font color="#FF0000"><b>is </b></font>a variable that <font color="#FF0000"><b>contains </b></font>a memory address<font color="#000080">.

      </font>The heap <font color="#FF0000"><b>is </b></font>all <font color="#FF0000"><b>of </b></font>that memory allocated by DOS <font color="#FF0000"><b>to </b></font>a <font color="#FF0000"><b>program for </b></font>its
      use that has <font color="#FF0000"><b>not </b></font>been used by the <font color="#FF0000"><b>program for </b></font>its code<font color="#000080">, </font>global data <font color="#FF0000"><b>or
      </b></font>stack<font color="#000080">.

      </font><font color="#FF0000"><b>Dynamic </b></font>variables are variables that have had space allocated <font color="#FF0000"><b>for </b></font>them
      <font color="#FF0000"><b>on </b></font>the heap<font color="#000080">.

      </font><font color="#FF0000"><b>Dynamic </b></font>variables have no identifier <font color="#000080">(</font>are unnamed<font color="#000080">).  </font>Because <font color="#FF0000"><b>of </b></font>this
      they need an associated variable that can be used <font color="#FF0000"><b>to </b></font>find where they
      reside <font color="#FF0000"><b>in </b></font>memory<font color="#000080">. </font>Pointers are ideal <font color="#FF0000"><b>for </b></font>this but need some method <font color="#FF0000"><b>to
      </b></font>define what <font color="#FF0000"><b>type of </b></font>data it <font color="#FF0000"><b>is </b></font>that they are pointing at<font color="#000080">.  </font><font color="#FF0000"><b>Pascal
      </b></font>provides this method<font color="#000080">.

        </font><font color="#FF0000"><b>type
          </b></font>Str10Ptr <font color="#000080">= ^</font><font color="#FF0000"><b>string</b></font><font color="#000080">[</font><font color="#800000">10</font><font color="#000080">];
          </font><font color="#008000"><i>{ This means Str10Ptr is a pointer that points to data of type }
          { string[10].                                                  }
        </i></font><font color="#FF0000"><b>var
          </b></font>S <font color="#000080">: </font>Str10Ptr<font color="#000080">;

      </font><font color="#FF0000"><b>In </b></font>the above example S <font color="#FF0000"><b>is </b></font>a pointer that has been defined <font color="#FF0000"><b>as </b></font>pointing
      <font color="#FF0000"><b>to </b></font>an address <font color="#FF0000"><b>in </b></font>memory that will contain <font color="#000080">(</font><font color="#FF0000"><b>or </b></font>should contain<font color="#000080">) </font>data <font color="#FF0000"><b>of
      type string</b></font><font color="#000080">[</font><font color="#800000">10</font><font color="#000080">].

      </font>However how does S get this value<font color="#000080">?  </font>How does it know where that data<font color="#800000">'s
      </font>address <font color="#FF0000"><b>is </b></font>supposed <font color="#FF0000"><b>to </b></font>be<font color="#000080">?  </font>Well <font color="#FF0000"><b>until </b></font>the programmer allocates memory
      <font color="#FF0000"><b>for </b></font>that data S<font color="#800000">'s value is undefined, so it could be literally
      </font>pointing anywhere<font color="#000080">. </font>So it <font color="#FF0000"><b>is </b></font><font color="#000080">*</font>vital<font color="#000080">* </font>that before we <font color="#FF0000"><b>try to </b></font>use it <font color="#FF0000"><b>to
      </b></font>use<font color="#000080">/</font>assign data from<font color="#000080">/</font><font color="#FF0000"><b>to </b></font>that memory location we give S a memory
      address that <font color="#FF0000"><b>is not </b></font>being used <font color="#FF0000"><b>for </b></font>any other purpose at the moment <font color="#FF0000"><b>and
      </b></font>that <font color="#FF0000"><b>is </b></font>big enough <font color="#FF0000"><b>to </b></font>hold the data that we want <font color="#FF0000"><b>to </b></font>place into it <font color="#000080">- </font><font color="#FF0000"><b>in
      </b></font>this <font color="#FF0000"><b>case </b></font>at least <font color="#800000">11 </font>bytes<font color="#000080">.  </font>We <font color="#FF0000"><b>do </b></font>this by <font color="#000080">-

        </font>new<font color="#000080">(</font>S<font color="#000080">);

      </font><font color="#FF0000"><b>Pascal </b></font>has now allocated at least <font color="#800000">11 </font>bytes <font color="#FF0000"><b>of </b></font>heap <font color="#FF0000"><b>and </b></font>has allocated S
      <font color="#FF0000"><b>with </b></font>the address <font color="#FF0000"><b>of </b></font>the FIRST byte <font color="#FF0000"><b>of </b></font>that allocation<font color="#000080">.

      </font>Ok<font color="#000080">... </font>so <font color="#FF0000"><b>far </b></font>so good<font color="#000080">! </font>How <font color="#FF0000"><b>do </b></font>we access that data <font color="#000080">(</font>remembering that it
      has no name<font color="#000080">).  </font>Well we <font color="#000080">&quot;</font>dereference<font color="#000080">&quot; </font>the pointer<font color="#000080">. </font>This <font color="#FF0000"><b>is </b></font>done by
      placing a carat sign immediately following the pointer<font color="#800000">'s identifier.

        </font>S<font color="#000080">^ := </font><font color="#800000">'Joe Bloggs'</font><font color="#000080">;

      </font>This statement actually means <font color="#000080">&quot;</font>Place the <font color="#FF0000"><b>string </b></font><font color="#800000">'Joe Bloggs' </font>into the
      memory address that S <font color="#FF0000"><b>contains</b></font><font color="#000080">&quot;. </font>This <font color="#FF0000"><b>is </b></font>referred <font color="#FF0000"><b>to as </b></font><font color="#000080">&quot;</font>derferencing<font color="#000080">&quot;
      </font>the pointer S<font color="#000080">.

      </font><font color="#FF0000"><b>To </b></font><font color="#000080">&quot;</font>reference<font color="#000080">&quot; </font>a <font color="#FF0000"><b>dynamic </b></font>variable we <font color="#000080">&quot;</font>dereference<font color="#000080">&quot; </font>its associated
      pointer variable<font color="#000080">.  </font>We cannot say <font color="#000080">-

        </font>S <font color="#000080">:= </font><font color="#800000">'Joe Bloggs'</font><font color="#000080">;

      </font>because S <font color="#FF0000"><b>is </b></font>a pointer <font color="#FF0000"><b>and </b></font>that would be trying <font color="#FF0000"><b>to </b></font>give a pointer a
      <font color="#FF0000"><b>string type </b></font>value <font color="#000080">- </font>a compiler <font color="#000080">&quot;</font><font color="#FF0000"><b>type </b></font>mismatch<font color="#000080">&quot; </font>would occur<font color="#000080">. </font>So every
      time we wish <font color="#FF0000"><b>to </b></font>access that <font color="#FF0000"><b>dynamic </b></font>variable we dereference it<font color="#000080">.

      </font><font color="#FF0000"><b>To </b></font>delete the <font color="#FF0000"><b>dynamic </b></font>variable once it <font color="#FF0000"><b>is of </b></font>no further use <font color="#FF0000"><b>is </b></font>just a
      matter <font color="#FF0000"><b>of </b></font><font color="#000080">-

        </font>dispose<font color="#000080">(</font>S<font color="#000080">);

      </font>What this statement does <font color="#FF0000"><b>is </b></font>release the memory previously used by S<font color="#000080">^
      </font><font color="#FF0000"><b>and </b></font>make it available <font color="#FF0000"><b>to </b></font>be used <font color="#FF0000"><b>for </b></font>other purposes by the <font color="#FF0000"><b>program</b></font><font color="#000080">.
      </font>Depending <font color="#FF0000"><b>on </b></font>the version <font color="#FF0000"><b>of Pascal </b></font>you are using it may <font color="#FF0000"><b>not </b></font>erase <font color="#FF0000"><b>or
      </b></font>alter the contents <font color="#FF0000"><b>of </b></font>that memory <font color="#FF0000"><b>and </b></font>it may <font color="#FF0000"><b>not </b></font>give S a new value<font color="#000080">.
      </font>However any attempt <font color="#FF0000"><b>to </b></font>dereference S <font color="#FF0000"><b>is </b></font>an error <font color="#FF0000"><b>as </b></font>the integrity <font color="#FF0000"><b>of
      </b></font>that memory location has been lost <font color="#000080">- </font>it may have been allocated <font color="#FF0000"><b>to
      </b></font>other data<font color="#000080">.

      </font>Pointers <font color="#FF0000"><b>do not </b></font><font color="#000080">*</font>have<font color="#000080">* </font><font color="#FF0000"><b>to </b></font>point <font color="#FF0000"><b>to </b></font>a memory location <font color="#FF0000"><b>in </b></font>the heap <font color="#FF0000"><b>or
      </b></font>even have their value always allocated by using the New <font color="#FF0000"><b>procedure</b></font><font color="#000080">. </font>Any
      valid memory address can be assigned <font color="#FF0000"><b>to </b></font>them <font color="#FF0000"><b>and then </b></font>they can be
      dereferenced <font color="#FF0000"><b>as </b></font>shown above<font color="#000080">.  </font><font color="#FF0000"><b>As </b></font>a simple example <font color="#FF0000"><b>of </b></font>this lets say you
      want <font color="#FF0000"><b>to </b></font>examine the contents <font color="#FF0000"><b>of </b></font>the <font color="#800000">16 </font>byte area at <font color="#800000">$40</font><font color="#000080">:</font><font color="#800000">$f0 </font><font color="#000080">(</font>the ICA
      area<font color="#000080">). </font>You could <font color="#000080">- (</font>TP specific<font color="#000080">)

         </font><font color="#FF0000"><b>type
           </b></font>ICA_Ptr <font color="#000080">= ^</font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">15</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
         </font><font color="#FF0000"><b>var
           </b></font>B       <font color="#000080">: </font>byte<font color="#000080">;
           </font>ICA     <font color="#000080">: </font>ICA_Ptr<font color="#000080">;

          </font>ICA <font color="#000080">:= </font>ptr<font color="#000080">(</font><font color="#800000">$40</font><font color="#000080">,</font><font color="#800000">$f0</font><font color="#000080">);

      </font>Now ICA points <font color="#FF0000"><b>to </b></font>the address specified <font color="#FF0000"><b>and </b></font>you can dereference it <font color="#000080">-

          </font>B <font color="#000080">:= </font>ICA<font color="#000080">^[</font><font color="#800000">10</font><font color="#000080">];

      </font>Hope that helps get you started into the complex world <font color="#FF0000"><b>of </b></font>memory
      management <font color="#FF0000"><b>and </b></font>manipulation using pointers<font color="#000080">.  </font>There are countless
      permutations <font color="#FF0000"><b>and </b></font>methods that can be used<font color="#000080">.


 </font><font color="#800000">18.

   </font>Q<font color="#000080">. </font>How <font color="#FF0000"><b>do </b></font>I <font color="#FF0000"><b>do </b></font>word wrap<font color="#000080">?

   </font>A<font color="#000080">. </font>The demo <font color="#FF0000"><b>program </b></font>WRAP<font color="#000080">.</font>PAS <font color="#FF0000"><b>in </b></font>this archive demonstrates both word wrap
      <font color="#FF0000"><b>and </b></font>the justifying <font color="#FF0000"><b>of </b></font>text<font color="#000080">.










</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0001.PAS">Original</a><b>]</b></p></body>
</html>
