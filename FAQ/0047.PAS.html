<html>
<head><title> "Assembler tutorial" by CAMERON CLARK</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0047.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code>
<font color="#000000">The non<font color="#000080">-</font>general use registers<font color="#000080">, </font>What are they <font color="#FF0000"><b>for</b></font><font color="#000080">?

***********************************************************************
*</font>GENERAL REGISTERS <font color="#000080">*</font><font color="#FF0000"><b>register</b></font><font color="#000080">*               </font>definition                <font color="#000080">*
*                  *   </font>AX   <font color="#000080">*  </font>accumulator                   <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">) *
*                  *   </font>AH   <font color="#000080">*  </font>accumulator high<font color="#000080">-</font>order byte   <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>AL   <font color="#000080">*  </font>accumulator low order byte    <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>BX   <font color="#000080">*  </font>base                          <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">) *
*                  *   </font>BH   <font color="#000080">*  </font>base high<font color="#000080">-</font>order byte          <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>BL   <font color="#000080">*  </font>base low<font color="#000080">-</font>order byte           <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>CX   <font color="#000080">*  </font>count                         <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">) *
*                  *   </font>CH   <font color="#000080">*  </font>count high order byte         <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>CL   <font color="#000080">*  </font>count low order byte          <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>DX   <font color="#000080">*  </font>data                          <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">) *
*                  *   </font>DH   <font color="#000080">*  </font>date high order byte          <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
*                  *   </font>DL   <font color="#000080">*  </font>data low order byte           <font color="#000080">( </font><font color="#800000">8 </font>bit<font color="#000080">) *
***********************************************************************
*</font>SEGMENT REGISTERS <font color="#000080">*</font><font color="#FF0000"><b>register</b></font><font color="#000080">*               </font>definition                <font color="#000080">*
*                  *   </font>CS   <font color="#000080">*  </font>code  segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *
*                  *   </font>DS   <font color="#000080">*  </font>data  segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *
*                  *   </font>SS   <font color="#000080">*  </font>stack segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *
*                  *   </font>ES   <font color="#000080">*  </font>extra segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *
***********************************************************************
*</font>INDEX REGISTERS   <font color="#000080">*</font><font color="#FF0000"><b>register</b></font><font color="#000080">*               </font>definition                <font color="#000080">*
*                  *   </font>DI   <font color="#000080">*  </font>destination index <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)             *
*                  *   </font>SI   <font color="#000080">*  </font>source      index <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)             *
***********************************************************************
*</font>POINTERS          <font color="#000080">*</font><font color="#FF0000"><b>register</b></font><font color="#000080">*               </font>definition                <font color="#000080">*
*                  *   </font>SP   <font color="#000080">*  </font>stack       pointer <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)           *
*                  *   </font>BP   <font color="#000080">*  </font>base        pointer <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)           *
*                  *   </font>IP   <font color="#000080">*  </font>instruction pointer <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)           *
***********************************************************************
*</font>FLAGS               AF<font color="#000080">, </font>CF<font color="#000080">, </font>DF<font color="#000080">, </font><font color="#FF0000"><b>IF</b></font><font color="#000080">, </font><font color="#FF0000"><b>OF</b></font><font color="#000080">, </font>PF<font color="#000080">, </font>SF<font color="#000080">, </font>TF<font color="#000080">, </font>ZF               <font color="#000080">*
 
     </font>Once again here <font color="#FF0000"><b>is </b></font>the list <font color="#FF0000"><b>of </b></font>registers <font color="#000080">[</font><font color="#FF0000"><b>and </b></font>flags<font color="#000080">] </font><font color="#FF0000"><b>on </b></font>you <font color="#800000">80</font>xxx
     processor<font color="#000080">. </font><font color="#FF0000"><b>As </b></font>was said before registers AX<font color="#000080">-</font>DX are general use<font color="#000080">;
     </font>however they <font color="#FF0000"><b>do </b></font>have some other special <font color="#FF0000"><b>uses</b></font><font color="#000080">. </font><font color="#FF0000"><b>In </b></font>part II we saw
     that CX <font color="#FF0000"><b>is </b></font>known <font color="#FF0000"><b>as </b></font>the counting <font color="#FF0000"><b>register </b></font>because <font color="#FF0000"><b>in is </b></font>can be
     automatically inc<font color="#000080">/</font>dec durring a loop<font color="#000080">. </font>It can also be used <font color="#FF0000"><b>to
     repeat </b></font>a single <font color="#FF0000"><b>type of </b></font>machine instruction<font color="#000080">. [</font>scambling <font color="#FF0000"><b>for </b></font>Doc<font color="#000080">]
     </font>The <font color="#000080">&quot;</font>prefix<font color="#000080">&quot; </font><font color="#FF0000"><b>and </b></font>the instructions are <font color="#FF0000"><b>as </b></font>follows<font color="#000080">:
 
     </font>Prefix <font color="#000080">= </font>REP
 
     Instructions <font color="#000080">= </font>Movs<font color="#000080">,</font>Lods<font color="#000080">,</font>Stos<font color="#000080">,</font>Ins<font color="#000080">, </font><font color="#FF0000"><b>or </b></font>outs
 
     We already know that Mov <font color="#FF0000"><b>is </b></font>used <font color="#FF0000"><b>to </b></font>move a value <font color="#FF0000"><b>to </b></font>a <font color="#FF0000"><b>register or
     </b></font>a <font color="#FF0000"><b>register </b></font>value some address<font color="#000080">, </font>but what<font color="#800000">'s a (lod,sto,ins,out)?
     </font>That<font color="#800000">'s were are other registers come into play.
 
     </font><font color="#FF0000"><b>In </b></font>order <font color="#FF0000"><b>to do </b></font>operation like <font color="#FF0000"><b>in pascal</b></font><font color="#000080">, </font>you must use <font color="#FF0000"><b>to </b></font>special
     pointers <font color="#FF0000"><b>to </b></font>get information that <font color="#FF0000"><b>is far </b></font>away from the current
     code being executed<font color="#000080">. </font>These pointers can be thought <font color="#FF0000"><b>of as </b></font><font color="#000080">[</font>es<font color="#000080">:</font>di<font color="#000080">],
     </font><font color="#FF0000"><b>and </b></font><font color="#000080">[</font>ds<font color="#000080">:</font>si<font color="#000080">]. </font>I like <font color="#FF0000"><b>to label </b></font>them <font color="#FF0000"><b>as

     </b></font><font color="#000080">[</font>es<font color="#000080">:</font>di<font color="#000080">] -&gt; </font>put
     <font color="#000080">[</font>ds<font color="#000080">:</font>si<font color="#000080">] -&gt; </font>get
 
     These two are used <font color="#FF0000"><b>to </b></font>get <font color="#FF0000"><b>or </b></font>put the value that they point <font color="#FF0000"><b>to</b></font><font color="#000080">.
     </font>Notice that DS <font color="#FF0000"><b>is </b></font>called the data segment <font color="#FF0000"><b>register</b></font><font color="#000080">, </font><font color="#FF0000"><b>and </b></font>it <font color="#FF0000"><b>is
     </b></font>used <font color="#FF0000"><b>to </b></font><font color="#000080">&quot;</font>get<font color="#000080">&quot; </font>values from where DS points<font color="#000080">. </font><font color="#FF0000"><b>To </b></font>get back <font color="#FF0000"><b>to pascal</b></font><font color="#000080">,
     </font>lets use some examples<font color="#000080">.
 
     </font><font color="#FF0000"><b>var </b></font>x <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">22</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
     [...]
     </font>fillchar<font color="#000080">(</font>X<font color="#000080">,</font><font color="#800000">32</font><font color="#000080">,</font><font color="#800000">#0</font><font color="#000080">); </font><font color="#008000"><i>{I may have this in reverse}
 
     </i></font>This <font color="#FF0000"><b>procedure </b></font>takes the address <font color="#FF0000"><b>of </b></font>X <font color="#FF0000"><b>and </b></font>fills <font color="#FF0000"><b>is with </b></font><font color="#800000">32 </font>zero
     values<font color="#000080">.
     </font>now<font color="#000080">...
     </font><font color="#FF0000"><b>asm
       </b></font><font color="#FF00FF">push es
       push di
 
       mov ax,seg X
       mov es,ax
       mov di,offset X
 
       mov cx,32d  </font><font color="#008000"><i>{number of times to repeat}
       </i></font><font color="#FF00FF">mov ax,0    </font><font color="#008000"><i>{the &quot;char&quot; we want to move}
 
       </i></font><font color="#FF00FF">REP         </font><font color="#008000"><i>{tells the processor to repeat the next repeatable}
                   {instruction CX times                             }
           </i></font><font color="#FF00FF">stosB   </font><font color="#008000"><i>{store whats in AX to [es:di] and increment di}
 
       </i></font><font color="#FF00FF">pop di
       pop es
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
     </font>There<font color="#800000">'s alot of extra stuff there and you may want to know why.
     </font>The non<font color="#000080">-</font>general use registers are used by <font color="#FF0000"><b>pascal and </b></font>they
     _must_ remain the same value <font color="#FF0000"><b>in </b></font>order <font color="#FF0000"><b>for pascal to </b></font>run correctly<font color="#000080">.
     </font>That<font color="#800000">'s why we push and pop
 
     </font>what<font color="#800000">'s push &amp; pop? If you know, skip the next paragraph.
     </font>Push <font color="#FF0000"><b>and </b></font>pop <font color="#000080">&quot;</font>Push<font color="#000080">&quot; </font><font color="#FF0000"><b>and </b></font><font color="#000080">&quot;</font>pop<font color="#000080">&quot; </font>values onto the stack<font color="#000080">. </font>The stack <font color="#FF0000"><b>is
     </b></font>part <font color="#FF0000"><b>of </b></font>the operation system <font color="#FF0000"><b>and </b></font>it <font color="#FF0000"><b>is </b></font>used by most calling programs<font color="#000080">.
     </font>Misuse <font color="#FF0000"><b>of </b></font>the stack can cause you <font color="#FF0000"><b>program to </b></font>crash the computer<font color="#000080">.
     </font>Think <font color="#FF0000"><b>of </b></font>the stack <font color="#FF0000"><b>as </b></font>like a deck <font color="#FF0000"><b>of </b></font>cards<font color="#000080">. </font><font color="#FF0000"><b>IF </b></font>you put a Jack<font color="#000080">, </font><font color="#FF0000"><b>then
     and </b></font>Ace<font color="#000080">, </font><font color="#FF0000"><b>and then </b></font>a King <font color="#FF0000"><b>in </b></font>a pile you have just pushed Jack<font color="#000080">,</font>Ace<font color="#000080">, </font><font color="#FF0000"><b>and
     </b></font>King<font color="#000080">. </font>Know when you pick up the cards you <font color="#000080">&quot;</font>pop<font color="#000080">&quot; </font>King<font color="#000080">,</font>Ace<font color="#000080">,</font>Jack<font color="#000080">. </font>This
     <font color="#FF0000"><b>is </b></font>known <font color="#FF0000"><b>as </b></font>a <font color="#000080">&quot;</font>last <font color="#FF0000"><b>in </b></font>first <font color="#FF0000"><b>out</b></font><font color="#000080">&quot; </font>way <font color="#FF0000"><b>of </b></font>storage<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>any storage
     using the scheme can be called a stack<font color="#000080">. </font>A stack must always take
     the last value first <font color="#FF0000"><b>and </b></font>it can<font color="#800000">'t jump around. What you put into
     </font>the stack always comes <font color="#FF0000"><b>out in </b></font>reverse order<font color="#000080">. </font>That<font color="#800000">'s why when I
     </font>push ES <font color="#FF0000"><b>and </b></font>DI<font color="#000080">, </font>I must Pop Di <font color="#FF0000"><b>then </b></font>ES<font color="#000080">. </font>The stack <font color="#FF0000"><b>is </b></font>a quick way
     <font color="#FF0000"><b>of </b></font>storing <font color="#FF0000"><b>and </b></font>retrieving values<font color="#000080">.
 
     </font>Next<font color="#000080">, </font>whats that <font color="#000080">&quot;</font>Seg<font color="#000080">&quot; </font><font color="#FF0000"><b>and </b></font><font color="#000080">&quot;</font>offset<font color="#000080">&quot;?
     </font>These are Key words that tell the compiler <font color="#FF0000"><b>to </b></font>substitute at that
     position the <font color="#FF0000"><b>absolute </b></font>address <font color="#FF0000"><b>of </b></font>the Variable refrenced<font color="#000080">. </font>It<font color="#800000">'s kinda
     </font>like <font color="#FF0000"><b>pascal</b></font><font color="#800000">'s Addr(variable) procedure. In order for you to access
     </font>variables that aren<font color="#800000">'t part of a procedure call, its best to use
     </font>this method<font color="#000080">. </font>Remeber that ES<font color="#000080">:</font>DI must point <font color="#FF0000"><b>to </b></font>the variable you
     are wanting <font color="#FF0000"><b>to </b></font>change <font color="#FF0000"><b>in </b></font>the code about <font color="#000080">- </font>so you must tell the
     compiler <font color="#000080">- &quot;</font>I want you <font color="#FF0000"><b>to </b></font>give the location <font color="#FF0000"><b>of </b></font>this variable<font color="#000080">, </font><font color="#FF0000"><b>and
     not </b></font>the variables value<font color="#000080">&quot; </font>using the segment <font color="#FF0000"><b>and </b></font>offset key words<font color="#000080">.
 
     </font>Why didn<font color="#800000">'t you move the segment of array X dirrectly to DS?
     </font>Answer<font color="#000080">, </font>you can<font color="#800000">'t. You can move the value of a register to a
     </font>segment <font color="#FF0000"><b>register</b></font><font color="#000080">, </font>but you can<font color="#800000">'t move immediate values.
     </font>Illegal
        mov DS<font color="#000080">,</font><font color="#800000">938</font>d
        mov DS<font color="#000080">,</font>seg X
        mov CS<font color="#000080">,</font><font color="#800000">832</font>d
        mov ES<font color="#000080">,</font><font color="#800000">21</font>h
     Legal
        mov ax<font color="#000080">,</font><font color="#800000">938</font>d
        mov ds<font color="#000080">,</font>ax
        mov ax<font color="#000080">,</font>seg X
        mov ds<font color="#000080">,</font>ax
     <font color="#FF0000"><b>or </b></font>also legal
        push <font color="#800000">938</font>d
        pop  DS
        push seg X
        pop  DS

Tpas <font color="#000080">-&gt; </font>asmb
part III      <font color="#000080">[</font><font color="#800000">2 </font><font color="#FF0000"><b>of </b></font><font color="#800000">2</font><font color="#000080">]

</font>This section may have a bit too much information <font color="#FF0000"><b>for </b></font>now<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>you don<font color="#800000">'t
</font>quite get all <font color="#FF0000"><b>of </b></font>it<font color="#000080">, </font>don<font color="#800000">'t worry! Most of this section will be repeated
</font><font color="#FF0000"><b>and </b></font>explain <font color="#FF0000"><b>in </b></font>greater detail <font color="#FF0000"><b>in </b></font>the next upcomming sections<font color="#000080">.


</font><font color="#FF0000"><b>var </b></font>x <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">22</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
 
[...]
 
</font><font color="#FF0000"><b>asm
 </b></font><font color="#FF00FF">push es
 push di
 
 mov ax,seg X
 mov es,ax
 mov di,offset X
 
 mov cx,32d  </font><font color="#008000"><i>{number of times to repeat}
 </i></font><font color="#FF00FF">mov ax,0    </font><font color="#008000"><i>{the &quot;char&quot; we want to move}
 
 </i></font><font color="#FF00FF">REP         </font><font color="#008000"><i>{tells the processor to repeat the next repeatable}
             {instruction CX times                             }
    </i></font><font color="#FF00FF">stosB   </font><font color="#008000"><i>{store whats in AX to [es:di] and increment di}
 
 </i></font><font color="#FF00FF">pop di
 pop es
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
  </font>Starting from the top<font color="#000080">, </font>we know that we should push the original
  values <font color="#FF0000"><b>of </b></font>registers that aren<font color="#800000">'t general use [non AX-DX]. Next,
  </font>we know that we are telling the compiler <font color="#FF0000"><b>to </b></font>give us the address
  that X <font color="#FF0000"><b>is </b></font>located at <font color="#FF0000"><b>and not to </b></font>give us the value <font color="#FF0000"><b>of </b></font>X<font color="#000080">. </font>Segment
  registers can only be assinged values by a <font color="#FF0000"><b>Register or </b></font>a Pop<font color="#000080">.
 
  </font>That bring us <font color="#FF0000"><b>to </b></font>CX gets the number <font color="#FF0000"><b>of </b></font>times we want <font color="#FF0000"><b>to REPeat</b></font><font color="#000080">,
  </font><font color="#FF0000"><b>and </b></font>AX get the value we want <font color="#FF0000"><b>to </b></font>move <font color="#FF0000"><b>to </b></font>X<font color="#000080">. </font>We are know at the
  meaty instruction <font color="#FF0000"><b>and </b></font>that <font color="#FF0000"><b>is </b></font>STOSB<font color="#000080">. </font>STOSB does a lot at once<font color="#000080">.
 
  </font>First<font color="#000080">,  </font>it moves the byte located <font color="#FF0000"><b>in </b></font>AL <font color="#FF0000"><b>to </b></font><font color="#000080">[</font>es<font color="#000080">:</font>di<font color="#000080">].
  </font>Second<font color="#000080">, </font>it increments DI so it points <font color="#FF0000"><b>to </b></font>the next byte <font color="#FF0000"><b>of </b></font>X<font color="#000080">.
  </font>Third<font color="#000080">,  </font>CX <font color="#FF0000"><b>is </b></font>decremented
  fourth<font color="#000080">, </font><font color="#FF0000"><b>if </b></font>CX <font color="#FF0000"><b>in not </b></font>Zero <font color="#FF0000"><b>then </b></font>the process <font color="#FF0000"><b>is </b></font>repeated
 
  When you have a simple loop like
  <font color="#000080">&quot; </font><font color="#FF0000"><b>for </b></font>I <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font><font color="#800000">32 </font><font color="#FF0000"><b>do </b></font>x<font color="#000080">[</font>i<font color="#000080">] := </font><font color="#800000">0</font><font color="#000080">; &quot;;
  </font><font color="#FF0000"><b>then</b></font><font color="#000080">, </font>the above <font color="#FF0000"><b>is </b></font>a _really_quick_ way <font color="#FF0000"><b>to do </b></font>the same thing<font color="#000080">.
  </font>Unlike <font color="#FF0000"><b>in </b></font>Part II<font color="#000080">, </font>this loop <font color="#FF0000"><b>is not as </b></font>general<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>cant <font color="#FF0000"><b>as
  </b></font>easily be used <font color="#FF0000"><b>to do </b></font>many things durring a loop<font color="#000080">. </font>The REP only
  works <font color="#FF0000"><b>for </b></font>certain instruction <font color="#FF0000"><b>and </b></font>can only <font color="#FF0000"><b>repeat </b></font>that instruction
  CX times<font color="#000080">.
 
  &quot;</font>OK<font color="#000080">, </font>now what<font color="#800000">'s LOD,INS,OUT ?&quot;
  </font>First off<font color="#000080">, </font>the STOS can be use two other ways<font color="#000080">. </font>There <font color="#FF0000"><b>is </b></font>a STOSW
  that moves a word at a time <font color="#000080">[</font>AX<font color="#000080">] </font><font color="#FF0000"><b>and </b></font>advances DI two bytes<font color="#000080">. </font>The
  other one <font color="#FF0000"><b>is </b></font>STOS <font color="#FF0000"><b>and </b></font>truthfully<font color="#000080">, </font>I haven<font color="#800000">'t and don'</font>t know how
  <font color="#FF0000"><b>to </b></font>use it yet<font color="#000080">.
 
  </font>LODS <font color="#FF0000"><b>is </b></font>kinda the oposite <font color="#FF0000"><b>of </b></font>STOS<font color="#000080">. </font><font color="#FF0000"><b>IF </b></font>stosB<font color="#000080">, </font>it moves the byte at
  DS<font color="#000080">:</font>SI into AL<font color="#000080">, </font><font color="#FF0000"><b>and if </b></font>stosW<font color="#000080">, </font>it moves the word at DS<font color="#000080">:</font>SI into AX<font color="#000080">.
 
  !</font>Unless you know your hardware ports<font color="#000080">, </font>skip INS <font color="#FF0000"><b>and OUT for </b></font>now<font color="#000080">.!
  ]</font>INS <font color="#FF0000"><b>is not </b></font>part <font color="#FF0000"><b>of </b></font>the <font color="#800000">8088 </font><font color="#FF0000"><b>and </b></font><font color="#800000">8086 </font>processor <font color="#FF0000"><b>and </b></font>won<font color="#800000">'t execute.
  </font><font color="#000080">]</font>IT takes a byte <font color="#FF0000"><b>or </b></font>word <font color="#000080">[</font>insB<font color="#000080">, </font>insW<font color="#000080">] </font>from the port listed <font color="#FF0000"><b>in </b></font>DX
  <font color="#000080">]</font><font color="#FF0000"><b>and </b></font>moves it the addess located <font color="#FF0000"><b>in </b></font><font color="#000080">[</font>ES<font color="#000080">:</font>ID<font color="#000080">].
  ]
  ]</font><font color="#FF0000"><b>OUT </b></font>takes a byte <font color="#FF0000"><b>or </b></font>word <font color="#FF0000"><b>and </b></font>moves it <font color="#FF0000"><b>to </b></font>a port<font color="#000080">. </font>It can be done
  <font color="#000080">]</font><font color="#FF0000"><b>as </b></font>follows
  <font color="#000080">]
  ]</font><font color="#FF0000"><b>OUT </b></font><font color="#800000">13</font>h<font color="#000080">,</font>AL  <font color="#008000"><i>{moves byte in AL to port 13h}
  </i></font><font color="#000080">]</font><font color="#FF0000"><b>OUT </b></font><font color="#800000">13</font>h<font color="#000080">,</font>AX  <font color="#008000"><i>{moves word in AX to port 13h}
  </i></font><font color="#000080">]</font><font color="#FF0000"><b>OUT </b></font>DX<font color="#000080">,</font>al   <font color="#008000"><i>{move byte in al to port listed DX}
  </i></font><font color="#000080">]</font><font color="#FF0000"><b>out </b></font>DX<font color="#000080">,</font>ax   <font color="#008000"><i>{move word in ax to port listed DX}
  </i></font><font color="#000080">]
  ]</font>outs<font color="#000080">, </font>outsB<font color="#000080">,</font>outsW are <font color="#FF0000"><b>not </b></font>part <font color="#FF0000"><b>of </b></font>the <font color="#800000">8088 </font><font color="#FF0000"><b>and </b></font><font color="#800000">8086 </font>instruction
  <font color="#000080">]</font>outsB moves byte <font color="#000080">[</font>ds<font color="#000080">:</font>si<font color="#000080">] </font><font color="#FF0000"><b>to </b></font>port listed <font color="#FF0000"><b>in </b></font>DX <font color="#FF0000"><b>and </b></font>advances SI
  <font color="#000080">]</font>outsW moves word <font color="#000080">[</font>ds<font color="#000080">:</font>si<font color="#000080">] </font><font color="#FF0000"><b>to </b></font>port listed <font color="#FF0000"><b>in </b></font>DX <font color="#FF0000"><b>and </b></font>advances SI
  <font color="#000080">]</font>I<font color="#800000">'ve not used OUTS &amp; don'</font>t yet know how<font color="#000080">.
 
 
  </font>That brings us back <font color="#FF0000"><b>to </b></font>the rest <font color="#FF0000"><b>of </b></font>the special use registers<font color="#000080">,
  </font><font color="#FF0000"><b>And </b></font>they are
     CS   <font color="#000080">*  </font>code  segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *
     </font>SS   <font color="#000080">*  </font>stack segment <font color="#000080">(</font><font color="#800000">16 </font>bit<font color="#000080">)                 *.
 
  </font>My best advice <font color="#FF0000"><b>is </b></font>DON<font color="#800000">'T TOUCH! Your processor uses pointers
  </font>just like you so it knows what <font color="#FF0000"><b>to </b></font>execute next <font color="#FF0000"><b>and </b></font>where the
  top <font color="#FF0000"><b>of </b></font>the stack <font color="#FF0000"><b>is</b></font><font color="#000080">. </font>CS<font color="#000080">:</font>IP points the next instuction <font color="#FF0000"><b>to </b></font>execute
  <font color="#FF0000"><b>and </b></font>SS<font color="#000080">:</font>SP points <font color="#FF0000"><b>to </b></font>the top <font color="#FF0000"><b>of </b></font>the stack<font color="#000080">.
  </font>CS<font color="#000080">:</font>IP are changed by jumps <font color="#FF0000"><b>and </b></font>calls<font color="#000080">.
  </font>SS<font color="#000080">:</font>SP are changed by pushes <font color="#FF0000"><b>and </b></font>pops
 
  <font color="#000080">-------------------------------------------------------------
  </font>I screwed up a little bit <font color="#FF0000"><b>in </b></font>order so I need <font color="#FF0000"><b>to </b></font>rectify this
  now<font color="#000080">.
 
  </font>I need <font color="#FF0000"><b>to </b></font>define immediate values<font color="#000080">, </font>effective addresses<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>so forth<font color="#000080">.
 
  </font>mov ax<font color="#000080">,</font><font color="#800000">983</font>d
  An immediate value <font color="#FF0000"><b>is </b></font>a byte <font color="#FF0000"><b>or </b></font>word that <font color="#FF0000"><b>is </b></font>part <font color="#FF0000"><b>of </b></font>the instruction<font color="#000080">.
  </font><font color="#FF0000"><b>In </b></font>the example above<font color="#000080">, </font><font color="#800000">938</font>d <font color="#FF0000"><b>is </b></font>the immediate value that <font color="#FF0000"><b>is </b></font>going <font color="#FF0000"><b>to
  </b></font>be moved into ax<font color="#000080">.
  &quot;</font>mov ax<font color="#000080">,</font>bx<font color="#000080">&quot; </font>has no immediate values<font color="#000080">. </font>The value <font color="#FF0000"><b>is </b></font>stored <font color="#FF0000"><b>in </b></font>BX <font color="#FF0000"><b>and
  </b></font>the word associated <font color="#FF0000"><b>is not </b></font>part <font color="#FF0000"><b>of </b></font>the instruction<font color="#000080">.
 
 
  </font>mov ax<font color="#000080">,[</font><font color="#800000">0000</font><font color="#000080">]
  </font>An effective address can be a word value that <font color="#FF0000"><b>is </b></font>part <font color="#FF0000"><b>of </b></font>the instuction
  but <font color="#FF0000"><b>is </b></font>a location <font color="#FF0000"><b>and </b></font>an immediate value<font color="#000080">. </font>When this <font color="#FF0000"><b>is </b></font>compiled
  <font color="#800000">0000 </font><font color="#FF0000"><b>is not </b></font>moved into ax<font color="#000080">, </font>the word pointed <font color="#FF0000"><b>to </b></font>by cs<font color="#000080">:[</font><font color="#800000">0000</font><font color="#000080">] </font><font color="#FF0000"><b>is </b></font>moved
  into ax<font color="#000080">. </font>Why CS<font color="#000080">? </font><font color="#FF0000"><b>If </b></font>you don<font color="#800000">'t overide the segment the compiler used
  </font>defaults<font color="#000080">. </font>Unfortunatly I don<font color="#800000">'t readily know which are which, but
  </font>seeing that you might be a beginner<font color="#000080">, </font>this won<font color="#800000">'t be a problem that
  </font>has <font color="#FF0000"><b>to </b></font>be delt <font color="#FF0000"><b>with </b></font>know<font color="#000080">. </font><font color="#FF0000"><b>In </b></font>other word ignore <font color="#FF0000"><b>for </b></font>now<font color="#000080">.
 
  </font>mov ax<font color="#000080">,[</font>bx<font color="#000080">]
  </font>This has <font color="#000080">[</font>bx<font color="#000080">] </font><font color="#FF0000"><b>as </b></font>the effective address<font color="#000080">. </font>The value <font color="#FF0000"><b>in </b></font>BX <font color="#FF0000"><b>is </b></font>thought
  <font color="#FF0000"><b>of as </b></font>an address <font color="#FF0000"><b>and </b></font>the word pointed <font color="#FF0000"><b>to </b></font>by BX <font color="#FF0000"><b>is </b></font>moved into ax<font color="#000080">.
 
  </font>There are several addressing modes <font color="#FF0000"><b>and </b></font>I will <font color="#FF0000"><b>try to </b></font>explain them <font color="#FF0000"><b>as
  </b></font>I get <font color="#FF0000"><b>to </b></font>them <font color="#FF0000"><b>and as </b></font>they are needed<font color="#000080">.
 
 
  </font>_I HIGHLY suggest that we start <font color="#FF0000"><b>out with assembler procedure and
  </b></font>functions <font color="#FF0000"><b>in Pascal and </b></font>leave it at that_<font color="#000080">! </font>I think that <font color="#FF0000"><b>asm </b></font><font color="#FF00FF">should
  be used only for critical procedures that are too slow in pascal
  or are things not supported by native pascal. This way you code can
  be effiecient and still easily understandable.
 
  Next section Part IV - assembler functions and procedures in pascal.

tpas -&gt; asmb
part IV - assembler functions and procedures in pascal.
     [1 of 2]
 
     Now that we know just a little bit, let learn through example.
     Translation from tpas to </font><font color="#FF0000"><b>asm </b></font><font color="#FF00FF">is not an exact science. There
     are several way to do about the same structure as pascal and
     it is this reason that </font><font color="#FF0000"><b>ASM </b></font><font color="#FF00FF">procedures can be so efficient. You
     can completetly eliminate the legnthy and general machine code
     that pascal produces when things like overflow,range checking,
     and so forth, are not as important as speeding things up.
 
     For the first example, we are going to write a procedure in
     Tpascal that clears the screen in mode $13. We will assume
     that we are already in mode $13.
 
     mov ax,13h
     int 10h    </font><font color="#008000"><i>{bios call}
 
 
 
     </i></font><font color="#FF00FF">procedure ClearScrn13;
     var i,j : word;
     begin
       for I := 0 to 199 do
           For J := 0 to 319 do
                 mem[$a000:(i*320) + j] := 0;
 
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
 
     </font>First off<font color="#000080">, </font>I assume you know that <font color="#FF0000"><b>in </b></font>ram at <font color="#800000">$a000</font><font color="#000080">:</font><font color="#800000">0000 </font><font color="#FF0000"><b>is
     </b></font>were the vga screen memory <font color="#FF0000"><b>is </b></font>stored<font color="#000080">. </font>I can be thought <font color="#FF0000"><b>of
     as </b></font>an <font color="#FF0000"><b>array of </b></font><font color="#800000">64</font><font color="#000080">,</font><font color="#800000">000 </font>bytes<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>you must <font color="#FF0000"><b>do </b></font>the Row_Major
     math <font color="#FF0000"><b>to </b></font>access it by Row <font color="#FF0000"><b>and </b></font>Column<font color="#000080">.
     </font><font color="#FF0000"><b>For </b></font>every row there are <font color="#800000">320 </font>bytes<font color="#000080">, </font><font color="#FF0000"><b>in </b></font>order <font color="#FF0000"><b>to </b></font>access <font color="#000080">[</font><font color="#800000">2</font><font color="#000080">,</font><font color="#800000">2</font><font color="#000080">]
     </font><font color="#FF0000"><b>of </b></font>a <font color="#000080">[</font><font color="#800000">320</font><font color="#000080">,</font><font color="#800000">200</font><font color="#000080">] </font><font color="#FF0000"><b>array </b></font>we must pass up <font color="#800000">320 </font>bytes <font color="#FF0000"><b>in </b></font>the first row
     <font color="#FF0000"><b>and and </b></font><font color="#800000">1 </font>more byte <font color="#FF0000"><b>to </b></font>get <font color="#FF0000"><b>to </b></font><font color="#000080">[</font><font color="#800000">2</font><font color="#000080">,</font><font color="#800000">2</font><font color="#000080">].
 
     </font><font color="#FF0000"><b>In </b></font>this <font color="#FF0000"><b>case</b></font><font color="#000080">, </font>who cares about rows <font color="#FF0000"><b>and </b></font>colums<font color="#000080">. </font>We know the
     size <font color="#FF0000"><b>of </b></font>the <font color="#800000">1 </font>dimesional <font color="#FF0000"><b>array </b></font>so when can just loop <font color="#800000">64000 </font>times<font color="#000080">.
     </font>This keeps us from having <font color="#FF0000"><b>to do </b></font>any math <font color="#000080">- </font>which will slow every<font color="#000080">-
     </font>thing down<font color="#000080">.
 
     </font><font color="#FF0000"><b>procedure </b></font>clearScrn13asm<font color="#000080">;
     </font><font color="#FF0000"><b>begin
     asm
       </b></font><font color="#FF00FF">push es  </font><font color="#008000"><i>{remeber to store the values of non-general}
       </i></font><font color="#FF00FF">push di
 
       mov ax,0a000h
       mov es,ax      </font><font color="#008000"><i>{es := $a000}
       </i></font><font color="#FF00FF">xor di,di      </font><font color="#008000"><i>{di := 0}
 
       </i></font><font color="#FF00FF">mov cx,32000d   </font><font color="#008000"><i>{cx := 64000 div 2;}
       </i></font><font color="#FF00FF">xor ax,ax      </font><font color="#008000"><i>{ax := 0;}
 
       </i></font><font color="#FF00FF">rep stosW
 
       pop di
       pop es
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
     </font>I know<font color="#000080">, </font>you saying <font color="#000080">&quot;</font>what the f<font color="#000080">..?&quot;. </font>Remember first we point our
     <font color="#000080">&quot;</font>put<font color="#000080">&quot; </font>pointer <font color="#000080">[</font>es<font color="#000080">:</font>di<font color="#000080">] </font><font color="#FF0000"><b>to </b></font>where we are going <font color="#FF0000"><b>to </b></font>store stuff<font color="#000080">. </font>So what
     <font color="#FF0000"><b>is </b></font><font color="#000080">&quot;</font><font color="#FF0000"><b>xor </b></font>di<font color="#000080">,</font>di<font color="#000080">&quot;? &quot;</font><font color="#FF0000"><b>Xor</b></font><font color="#000080">&quot; </font><font color="#FF0000"><b>or is </b></font><font color="#000080">&quot;</font>exclusive <font color="#FF0000"><b>or</b></font><font color="#000080">&quot;. </font>It means either A <font color="#FF0000"><b>or </b></font>B
     but <font color="#FF0000"><b>not </b></font>A <font color="#FF0000"><b>and </b></font>B<font color="#000080">. </font>The truth table <font color="#FF0000"><b>is as </b></font>follows
 
     true  <font color="#FF0000"><b>xor </b></font>false <font color="#000080">= </font>true
     false <font color="#FF0000"><b>xor </b></font>true  <font color="#000080">= </font>true
     false <font color="#FF0000"><b>xor </b></font>false <font color="#000080">= </font>false
     true  <font color="#FF0000"><b>xor </b></font>true  <font color="#000080">= </font>false
 
     <font color="#FF0000"><b>in </b></font>bits
     <font color="#800000">1 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">1
     0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">1
     0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#000080">= </font><font color="#800000">0
     1 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">1 </font><font color="#000080">= </font><font color="#800000">0
 
     </font>So any number <font color="#FF0000"><b>xor</b></font><font color="#800000">'d it self is zero. For example, 48 decimal is 30
     </font>hexidecimal<font color="#000080">. </font><font color="#FF0000"><b>In </b></font>binary <font color="#800000">30 </font><font color="#FF0000"><b>is </b></font><font color="#800000">00110000. </font>Now <font color="#FF0000"><b>if </b></font>you <font color="#FF0000"><b>xor </b></font>each
     individual bit by using the table above you get
 
     <font color="#800000">0 0 1 1 0 0 0 0   </font><font color="#000080">|
 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 0 1 1 0 0 0 0   </font><font color="#000080">|
 -------------------   </font>v
   <font color="#000080">= </font><font color="#800000">0 0 0 0 0 0 0 0
 
     </font><font color="#FF0000"><b>For </b></font>each column use the table<font color="#000080">. </font>From left <font color="#FF0000"><b>to </b></font>right <font color="#800000">0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#FF0000"><b>is </b></font><font color="#800000">0</font><font color="#000080">,
     </font><font color="#800000">0 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">0 </font><font color="#FF0000"><b>is </b></font><font color="#800000">0</font><font color="#000080">, </font><font color="#800000">1 </font><font color="#FF0000"><b>xor </b></font><font color="#800000">1 </font><font color="#FF0000"><b>is </b></font><font color="#800000">0 </font><font color="#FF0000"><b>and </b></font>so forth<font color="#000080">.
 
     &quot;</font>Why <font color="#FF0000"><b>not </b></font>mov di<font color="#000080">,</font><font color="#800000">0 </font><font color="#000080">? </font><font color="#FF0000"><b>or </b></font>mov ax<font color="#000080">,</font><font color="#800000">0 </font><font color="#000080">?&quot;
     </font>Code size<font color="#000080">. </font>Mov di<font color="#000080">,</font><font color="#800000">0 </font>will produce <font color="#800000">3 </font>bytes <font color="#FF0000"><b>of </b></font>code <font color="#FF0000"><b>and </b></font><font color="#000080">&quot;</font><font color="#FF0000"><b>xor </b></font>di<font color="#000080">,</font>di<font color="#000080">&quot;
     </font>should produce <font color="#800000">1 </font>byte <font color="#FF0000"><b>of </b></font>code<font color="#000080">. </font><font color="#FF0000"><b>For </b></font>more information<font color="#000080">, </font>get the
     opcode list from <font color="#000080">&quot;</font>ftp<font color="#000080">.</font>intel<font color="#000080">.</font>com<font color="#000080">&quot;. </font>It list all possible <font color="#FF0000"><b>and </b></font>valid
     instructions<font color="#000080">.
 
 
     &quot;</font>Why <font color="#FF0000"><b>is is </b></font>mov cx<font color="#000080">,</font><font color="#800000">32000 </font><font color="#FF0000"><b>and not </b></font>mov cx<font color="#000080">,</font><font color="#800000">64000</font><font color="#000080">?&quot;
     </font>Well <font color="#FF0000"><b>If </b></font>you look at the repeated instruction<font color="#000080">, </font><font color="#FF0000"><b>is </b></font>will move
     a word at a time<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>a word <font color="#FF0000"><b>is </b></font>two bytes<font color="#000080">. </font>So moving <font color="#800000">32000
     </font>words <font color="#FF0000"><b>is </b></font>the same <font color="#FF0000"><b>as </b></font>moving <font color="#800000">64000 </font>bytes but just much
     quicker<font color="#000080">.
 
     </font>Remeber the <font color="#000080">&quot;</font>REP stosW<font color="#000080">&quot; </font>will automatically mov ax <font color="#FF0000"><b>to </b></font>es<font color="#000080">:</font>di
     <font color="#FF0000"><b>and </b></font>increment di <font color="#FF0000"><b>and </b></font>decrement cx <font color="#FF0000"><b>until </b></font>repeated <font color="#800000">32000 </font>times<font color="#000080">.
 
 
     </font>Know lets use an example that won<font color="#800000">'t let us use the repeat prefix.
     </font>Lets mov a <font color="#FF0000"><b>virtual </b></font>screen <font color="#FF0000"><b>to </b></font>the physical screen<font color="#000080">.
 
     </font><font color="#FF0000"><b>type </b></font>V_scrn <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">319</font><font color="#000080">,</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">199</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
     </font><font color="#FF0000"><b>var </b></font>V_P <font color="#000080">: ^</font>V_scrn<font color="#000080">;
 
     </font><font color="#FF0000"><b>procedure </b></font>Paste_scrn<font color="#000080">( </font>P <font color="#000080">: </font>V_P <font color="#000080">);
     </font><font color="#FF0000"><b>var </b></font>i<font color="#000080">,</font>j <font color="#000080">: </font>word<font color="#000080">;
     </font><font color="#FF0000"><b>begin
       for </b></font>I <font color="#000080">:= </font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#800000">199 </font><font color="#FF0000"><b>do
           For </b></font>J <font color="#000080">:= </font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#800000">319 </font><font color="#FF0000"><b>do
                 </b></font>mem<font color="#000080">[</font><font color="#800000">$a000</font><font color="#000080">:(</font>i<font color="#000080">*</font><font color="#800000">320</font><font color="#000080">) + </font>j<font color="#000080">] := </font>V<font color="#000080">^[</font>j<font color="#000080">,</font>i<font color="#000080">];; </font><font color="#008000"><i>{or ist ^V[j,i]?}
     </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
</font>part IV <font color="#000080">- </font><font color="#FF0000"><b>assembler </b></font>functions <font color="#FF0000"><b>and </b></font>procedures <font color="#FF0000"><b>in pascal</b></font><font color="#000080">.
      [</font><font color="#800000">2 </font><font color="#FF0000"><b>of </b></font><font color="#800000">2</font><font color="#000080">]
 
</font><font color="#FF0000"><b>procedure </b></font>Paste_scrnASM<font color="#000080">( </font>P <font color="#000080">: </font>V_P <font color="#000080">);
     </font><font color="#FF0000"><b>begin
     asm
        </b></font><font color="#FF00FF">push es
        push di
        push ds
        push si
 
        </font><font color="#008000"><i>{: Setup or Get and Put pointers :}
 
        {get}
        </i></font><font color="#FF00FF">mov ax,word ptr P[2]  </font><font color="#008000"><i>{ds:si -&gt; V_screen }
        </i></font><font color="#FF00FF">mov ds,ax
        mov si,word ptr P
 
        </font><font color="#008000"><i>{put}
        </i></font><font color="#FF00FF">mov ax,0a000h         </font><font color="#008000"><i>{es:di -&gt; screen}
        </i></font><font color="#FF00FF">mov es,ax
        xor di,di
 
        mov cx,32000d         </font><font color="#008000"><i>{ for I := 1 to 32000 do begin }
     </i></font><font color="#FF00FF">@looper:
        lodsW                 </font><font color="#008000"><i>{  ax  := -&gt; get } { inc si }
        </i></font><font color="#FF00FF">stosW                 </font><font color="#008000"><i>{  put := ax     } { inc di }
        </i></font><font color="#FF00FF">loop @looper          </font><font color="#008000"><i>{ end;           } { dec CX }
 
        </i></font><font color="#FF00FF">pop si
        pop ds
        pop di
        pop es
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
     </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
 
 
     </font>OK lets start <font color="#FF0000"><b>with </b></font><font color="#000080">&quot;</font>P<font color="#000080">[</font><font color="#800000">2</font><font color="#000080">]&quot; </font>a Pointer <font color="#FF0000"><b>type is </b></font><font color="#800000">4 </font>bytes <font color="#FF0000"><b>in </b></font>legnth<font color="#000080">.
     </font>The first <font color="#800000">2 </font>bytes are the offset that it points <font color="#FF0000"><b>to and </b></font>the
     second <font color="#800000">2 </font>bytes are the segment that it point <font color="#FF0000"><b>to</b></font><font color="#000080">.
     </font>The <font color="#000080">&quot;[]&quot; </font>symbols also mean indexing <font color="#000080">- </font>much like an <font color="#800000">1 </font>dimensional
     <font color="#FF0000"><b>array in pascal</b></font><font color="#000080">. </font>Seeing that the Segment <font color="#FF0000"><b>is </b></font><font color="#800000">2 </font>bytes passed the
     begining <font color="#FF0000"><b>of </b></font>the pointer<font color="#000080">, </font>we tell th copmiler that we are talking
     about the word <font color="#800000">2 </font>bytes passed the begining <font color="#FF0000"><b>of </b></font>the <font color="#800000">4 </font>byte pointer<font color="#000080">.
 
     &quot;</font>word ptr<font color="#000080">?&quot;
     </font><font color="#FF0000"><b>If </b></font>we didn<font color="#800000">'t tell the copmiler that we want that this is a word
     </font><font color="#FF0000"><b>and </b></font>it an effective address <font color="#FF0000"><b>and not </b></font>a varialbe<font color="#000080">, </font>we<font color="#800000">'d have a
     </font>problem<font color="#000080">. </font>We can<font color="#800000">'t use the Offset and Seg key words; becuase, we
     </font>we want the value <font color="#FF0000"><b>of </b></font>the <font color="#FF0000"><b>of </b></font>the pointer <font color="#FF0000"><b>and not </b></font>its location<font color="#000080">.
 
 
 
     </font><font color="#FF0000"><b>Pascal </b></font>takes all the parameters <font color="#FF0000"><b>of </b></font>the <font color="#FF0000"><b>procedure and
     </b></font>pushes them <font color="#FF0000"><b>on </b></font>the stack write before a call <font color="#FF0000"><b>to </b></font>the <font color="#FF0000"><b>procedure</b></font><font color="#000080">.
     </font><font color="#FF0000"><b>In </b></font>a <font color="#FF0000"><b>procedure </b></font>when you use one <font color="#FF0000"><b>of </b></font>those variables you are actually
     using a values that <font color="#FF0000"><b>is on </b></font>the stack<font color="#000080">. </font>When you use the <font color="#000080">&quot;</font><font color="#FF0000"><b>VAR</b></font><font color="#000080">&quot; </font>keyword
     <font color="#FF0000"><b>is </b></font>pushes the address <font color="#FF0000"><b>of </b></font>the variable <font color="#FF0000"><b>on </b></font>the stack<font color="#000080">, </font><font color="#FF0000"><b>and </b></font>therefore
     any changes made <font color="#FF0000"><b>to </b></font>that variable are actually chaning the value
     <font color="#FF0000"><b>of </b></font>the original variable<font color="#000080">. </font>Otherwise<font color="#000080">, </font><font color="#FF0000"><b>is </b></font>just pushes the value <font color="#FF0000"><b>of
     </b></font>the variable <font color="#FF0000"><b>on </b></font>the stack <font color="#FF0000"><b>and </b></font>any changes <font color="#FF0000"><b>to </b></font>that value are made
     only <font color="#FF0000"><b>in </b></font>the stack <font color="#FF0000"><b>and </b></font>are thrown away after completion<font color="#000080">.
 
     </font>example
 
     <font color="#FF0000"><b>Procedure </b></font>test<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>X <font color="#000080">: </font>byte<font color="#000080">; </font>Y<font color="#000080">,</font>Z <font color="#000080">: </font>byte<font color="#000080">);
     </font><font color="#FF0000"><b>begin
     end</b></font><font color="#000080">;
 
 
 
     </font>a<font color="#000080">:= </font><font color="#800000">1</font><font color="#000080">;
     </font>b<font color="#000080">:= </font><font color="#800000">2</font><font color="#000080">;
     </font>c<font color="#000080">:= </font><font color="#800000">3</font><font color="#000080">;
 
     </font>When you call test<font color="#000080">(</font>a<font color="#000080">,</font>b<font color="#000080">,</font>c<font color="#000080">);
 
     </font>It pushed all the paramters starting backwards <font color="#FF0000"><b>with </b></font>C
 
     STACK
     SP <font color="#000080">-&gt;   [ </font>addr<font color="#000080">(</font>A<font color="#000080">) ]   </font>a
             <font color="#000080">[    </font><font color="#800000">2    </font><font color="#000080">]   </font>b
             <font color="#000080">[    </font><font color="#800000">3    </font><font color="#000080">]   </font>c
 
     <font color="#FF0000"><b>to </b></font>move C<font color="#800000">'s value into AX you could say
        </font>mov ax<font color="#000080">,</font>word ptr Z
     <font color="#FF0000"><b>to </b></font>move B<font color="#800000">'s value into AX you could say
        </font>mov ax<font color="#000080">,</font>word ptr Y
     <font color="#FF0000"><b>to </b></font>move A<font color="#800000">'s value into AX you could say
        </font>mov ax<font color="#000080">,</font>word ptr X<font color="#000080">[</font><font color="#800000">2</font><font color="#000080">]
        </font>mov ds<font color="#000080">,</font>ax
        mov si<font color="#000080">,</font>word ptr X     <font color="#008000"><i>{[ds:si] -&gt; A}
        </i></font>lodsB                 <font color="#008000"><i>{ax := [ds:si] }
 
     </i></font>because the value <font color="#FF0000"><b>of </b></font>A <font color="#FF0000"><b>is not on </b></font>the stack<font color="#000080">, </font>but A<font color="#800000">'s address is.
 
 
     </font><font color="#000080">!</font>Back <font color="#FF0000"><b>to </b></font>the code<font color="#000080">!
 
     </font>Next es<font color="#000080">:</font>di points <font color="#FF0000"><b>to </b></font>the vga memory <font color="#FF0000"><b>in </b></font>ram<font color="#000080">.
 
     </font>This<font color="#000080">...
 
       </font>mov cx<font color="#000080">,</font><font color="#800000">32000</font>d         <font color="#008000"><i>{ for I := 1 to 32000 do begin }
     </i></font><font color="#000080">@</font>looper<font color="#000080">:
        </font>lodsW                 <font color="#008000"><i>{  ax  := -&gt; get } { inc si }
        </i></font>stosW                 <font color="#008000"><i>{  put := ax     } { inc di }
        </i></font>loop <font color="#000080">@</font>looper          <font color="#008000"><i>{ end;           } { dec CX }
 
     </i></font>sets up our loop counter CX
     lodsW gets from <font color="#FF0000"><b>out virtual </b></font>screen the first word <font color="#FF0000"><b>and </b></font>increments si <font color="#800000">2
     </font>bytes <font color="#000080">[</font>word size <font color="#FF0000"><b>in </b></font>bytes<font color="#000080">]
     </font>AX holds the word
 
     stosW takes the word <font color="#FF0000"><b>in </b></font>AX <font color="#FF0000"><b>and </b></font>puts it <font color="#FF0000"><b>to </b></font>the screen <font color="#FF0000"><b>and </b></font>increments
     di <font color="#800000">2 </font>bytes<font color="#000080">.
 
     </font>Loop decrements CX <font color="#FF0000"><b>and </b></font>compares it <font color="#FF0000"><b>to </b></font>zero<font color="#000080">, </font><font color="#FF0000"><b>if </b></font>its <font color="#FF0000"><b>not </b></font>equal <font color="#FF0000"><b>to </b></font>zero
     it jumps <font color="#FF0000"><b>to </b></font><font color="#000080">@</font>Looper <font color="#000080">[</font>this changes the values <font color="#FF0000"><b>of </b></font>CS<font color="#000080">:</font>IP<font color="#000080">].
 
     </font>You get all that done <font color="#FF0000"><b>with </b></font>just a tinty bit <font color="#FF0000"><b>of </b></font>speedy code<font color="#000080">.
 
 
 
     </font>I didn<font color="#800000">'t get to functions this time, but in part V I'</font>ll get <font color="#FF0000"><b>to </b></font>functions
     <font color="#FF0000"><b>and </b></font>how <font color="#FF0000"><b>to </b></font>acccess <font color="#FF0000"><b>pascal </b></font>variables like a <font color="#FF0000"><b>string</b></font><font color="#000080">.
 
 
     </font><font color="#FF0000"><b>As </b></font>always<font color="#000080">, </font>I<font color="#800000">'ll be glad to answer any questions. Just one warning,_all
     </font>the code <font color="#FF0000"><b>in </b></font>these section have _NOT_ been compiled <font color="#FF0000"><b>and </b></font>are sure <font color="#FF0000"><b>to </b></font>have
     errors<font color="#000080">. </font><font color="#FF0000"><b>If </b></font>you find these errors <font color="#FF0000"><b>then </b></font>maybe these lessons are too simple
     <font color="#FF0000"><b>for </b></font>you <font color="#FF0000"><b>and </b></font>you may be ready <font color="#FF0000"><b>to </b></font>start learning from an intermediate <font color="#FF0000"><b>to
     </b></font>advanced <font color="#FF0000"><b>asm </b></font><font color="#FF00FF">book. However, I'll try to be as unassuming as possible,
     but if I loose you on some concept, just mail me.
 
     Later
     **%CpC%**
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to FAQ SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0047.PAS">Original</a><b>]</b></p></body>
</html>
