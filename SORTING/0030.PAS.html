<html>
<head><title> "SORTFAST.PAS" by SWAG SUPPORT TEAM</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to SORTING SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0030.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt; I might share With you a sorting Procedure which I developed For
&gt; 'those Arrays we were talking about:
&gt; ...
&gt; Exeperimentally I used it on 1485 Strings, which took about 3 sec
&gt; on my 386DX40.  Could you advise on some method to do it even
&gt; faster?

I'll share With you a little sort routine which I use often in my Programs
whenever I need a fast and efficient routine With very low overhead... It Uses
considerably less code than your example, and should outperForm it. (It would
be even faster if it was all coded in Assembly!-- hint hint DJ) :-)
}

</i></font><font color="#FF0000"><b>Procedure </b></font>Sort_It<font color="#000080">( </font>totalItems <font color="#000080">: </font>Word <font color="#000080">);

  </font><font color="#FF0000"><b>Function </b></font>Is_Less<font color="#000080">( </font>TemPtr1<font color="#000080">, </font>TemPtr2 <font color="#000080">: </font>Pointer <font color="#000080">) : </font>Boolean<font color="#000080">;
  </font><font color="#FF0000"><b>begin
    </b></font>Is_Less <font color="#000080">:= ( </font>YourStruct<font color="#000080">(</font>TemPtr1<font color="#000080">^).</font>Item <font color="#000080">&lt; </font>YourStruct<font color="#000080">(</font>TemPtr2<font color="#000080">^).</font>Item <font color="#000080">);
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>Var
  </b></font>I<font color="#000080">,</font>J <font color="#000080">: </font>Word<font color="#000080">;
  </font>Cur <font color="#000080">: </font>Word<font color="#000080">;

</font><font color="#FF0000"><b>begin
  For </b></font>I <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Pred<font color="#000080">(</font>totalItems<font color="#000080">) </font><font color="#FF0000"><b>do
  begin
    </b></font>Cur <font color="#000080">:= </font>I<font color="#000080">;

    </font><font color="#FF0000"><b>For </b></font>J <font color="#000080">:= </font>I <font color="#000080">+ </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>totalItems <font color="#FF0000"><b>do
      if </b></font>Is_Less<font color="#000080">( </font>Item<font color="#000080">[</font>J<font color="#000080">], </font>Item<font color="#000080">[</font>Cur<font color="#000080">] ) </font><font color="#FF0000"><b>then
        </b></font>ExchangeLongInts<font color="#000080">( </font>LongInt<font color="#000080">(</font>Item<font color="#000080">[</font>J<font color="#000080">]), </font>LongInt<font color="#000080">(</font>Item<font color="#000080">[</font>Cur<font color="#000080">]) );
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ For }

</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">; </font><font color="#008000"><i>{ Proc }

{
There's a couple things I should explain: The &quot;ExchangeLongInts&quot; Procedure is
from the TurboPower Opro's OpInline Unit. All it does is exchange two LongInt
Types without you having to use a temporary Variable. It's fast and convenient,
but not the only possible solution here. (I'm Typecasting the Pointer into a
LongInt For a 4-Byte swap.)

&quot;totalItems&quot; is the total number of items in your Array to sort.

&quot;Item&quot; is the actual Array; Item : Array[1..xx] of Pointer_to_Record;

&quot;YourStruct&quot; used in the &quot;Is_Less&quot; Function is Typecasting the actual structure
or Record that &quot;Item&quot; is referring to. It's the only portion of the code which
looks at your actual data. to reverse the sort order, simply change the &quot;&lt;&quot; to
&quot;&gt;&quot;. to change what is being sorted, just change the &quot;.Item&quot; to something else
like &quot;.Name&quot; or &quot;.Zip&quot; or whatever else might be contained in your structure.

This routine is simple, has a minimum amount of code, Uses very little stack,
works only With Pointers and you are only sorting memory addresses; it never
actually move any of your physical data. (if you did, then it would be slow.)

It'll sort several thousand items in only a couple seconds even on slower
machines, and is super on small volume runs. I would imagine that it would
(90 min left), (H)elp, More? start loosing steam around 1,000 to 2,000 items, but For me, it's the best
choice when memory is at a premium and the Arrays are fairly small.
}

</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to SORTING SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0030.PAS">Original</a><b>]</b></p></body>
</html>
