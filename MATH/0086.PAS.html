<html>
<head><title> "ASM Array Min/Max Finder" by TERJE MATHISEN</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MATH SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0086.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt;I need to find the minimum and maximum values in large arrays (~20,000
&gt;points) of type word.  Looking for a faster way using TP7 (assembler?)
&gt;to do it than:
&gt;
&gt;min := data^[1];
&gt;max := data^[1];
&gt;
&gt;for i := 2 to num_points do
&gt;begin
&gt; data_value := data^[i];
&gt; if data_value &lt; min then min := data_value;
&gt; if data_value &gt; max then max := data_value;
&gt;end;
&gt;
Lets try some asm here:

From: terjem@hda.hydro.com (Terje Mathisen)
}

</i></font><font color="#FF0000"><b>Procedure </b></font>FindMinMax<font color="#000080">(</font><font color="#FF0000"><b>var </b></font>data<font color="#000080">; </font>num_points <font color="#000080">: </font>word<font color="#000080">; </font><font color="#FF0000"><b>var </b></font>min<font color="#000080">, </font>max <font color="#000080">: </font>word<font color="#000080">);
</font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
  </b></font><font color="#FF00FF">push ds
  lds si,[data]
  mov cx,[num_points]
  sub cx,1
   jc @done   </font><font color="#008000"><i>{Empty array! }
  </i></font><font color="#FF00FF">mov dx,[si] </font><font color="#008000"><i>{Min value}
  </i></font><font color="#FF00FF">lea si,[si+2] </font><font color="#008000"><i>{Point at second table entry}
  </i></font><font color="#FF00FF">mov bx,dx   </font><font color="#008000"><i>{Max value}
   </i></font><font color="#FF00FF">jz @store  </font><font color="#008000"><i>{Single-entry array!}

</i></font><font color="#FF00FF">@loop:
  mov ax,[si]
  add si,2
  cmp ax,dx
   jb @new_min
  cmp ax,bx
   ja @new_max
  dec cx
   jnz @loop
   jmp @store

@new_min:
  mov dx,ax   </font><font color="#008000"><i>{Save new min value}
  </i></font><font color="#FF00FF">dec cx
   jnz @loop
   jmp @store

@new_max:
  mov bx,ax   </font><font color="#008000"><i>{Save new max value}
  </i></font><font color="#FF00FF">dec cx
   jnz @loop

@store:       </font><font color="#008000"><i>{Return the values found!}
  </i></font><font color="#FF00FF">lds si,[min]
  mov [si],dx
  lds si,[max]
  mov [si],bx
@done:
  pop ds
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>{
This was written from scratch, so no testing whatsoever!  It should be quite
well optimized for both 486 and Pentium-class machines, running in about 10
cycles/word on a 486, and just 4 cycles/word on a Pentium, since the
8 inner-loop instructions will pair perfectly.  With 20,000 points in your
array, this should correspond to 6ms on a 486-33, and less than a milli-
second on a Pentium-90.

The most important feature to note is that new extremal values will be quite
rare, averaging just O(log(n)) for a random n-element array.  That's why I
jump out of the loop to handle these cases, making the normal case much
faster.  With a worst-case, already sorted array, we will find a new max
value on each iteration, which will increase the running time to 12 cycles
on the 486, while the Pentium will stay constant at 4 cycles.

If the array is pre-sorted in reverse (declining) order, the 486 is back to
10 cycles, while the P5 is actually faster, at just 3 cycles/word.

I think the only way to improve on this code is by unrolling it, which will
save up to 4 cycles/word for the 486, and just a single P5 cycle.

PS. Make sure that your array is naturally aligned (16-bit word), if not it
will run a lot slower, esp. on a P5.
}
</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MATH SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0086.PAS">Original</a><b>]</b></p></body>
</html>
