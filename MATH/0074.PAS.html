<html>
<head><title> "FFT Algorithm in Pascal" by BOB SCHOR</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to MATH SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0074.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&Auml; Area: U-PASCAL      |61 &Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;
  Msg#: 5727                                         Date: 07-05-94  08:14
  From: Bschor@vms.cis.pitt.edu                      Read: Yes    Replied: No
    To: All                                          Mark:
  Subj: FFT Algorithm in Pascal
&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;&Auml;
From: bschor@vms.cis.pitt.edu

     Over the past several weeks, there have been questions about the Fast
Fourier Transform, including requests for a version of the algorithm.  The
following is one such implementation, optimized for clarity (??) at the
possible expense of a few percentage points in speed (it's pretty darn
fast).  It is written in &quot;vanilla&quot; Pascal, so it should work with all
variants of the language.

     Note that buried in the comments is a reasonable reference for the
algorithm.
   }


</i></font><font color="#FF0000"><b>PROGRAM </b></font>fft <font color="#000080">(</font>input<font color="#000080">, </font>output<font color="#000080">);

  </font><font color="#008000"><i>{****************************************}
  {                                        }
  {         Bob Schor                      }
  {         Eye and Ear Institute          }
  {         203 Lothrop Street             }
  {         Pittsburgh, PA   15213         }
  {                                        }
  {****************************************}

  { test routine for FFT in Pascal -- includes real and complex }

  { Version 1.6 -- first incarnation }
  { Version 10.7 -- upgrade, allow in-place computation of coefficients }
  { Version 14.6 -- comments added for didactic purposes }
 
</i></font><font color="#FF0000"><b>CONST
  </b></font>version <font color="#000080">= </font><font color="#800000">'FFT       Version 14.6'</font><font color="#000080">;
 
</font><font color="#FF0000"><b>CONST
  </b></font>maxarraysize <font color="#000080">= </font><font color="#800000">128</font><font color="#000080">;
  </font>halfmaxsize <font color="#000080">= </font><font color="#800000">64</font><font color="#000080">;
  </font>maxfreqsize <font color="#000080">= </font><font color="#800000">63</font><font color="#000080">;
</font><font color="#FF0000"><b>TYPE
  </b></font>dataindextype <font color="#000080">= </font><font color="#800000">1 </font><font color="#000080">.. </font>maxarraysize<font color="#000080">;
  </font>cmpxindextype <font color="#000080">= </font><font color="#800000">1 </font><font color="#000080">.. </font>halfmaxsize<font color="#000080">;
  </font>freqindextype <font color="#000080">= </font><font color="#800000">1 </font><font color="#000080">.. </font>maxfreqsize<font color="#000080">;
  </font>complex <font color="#000080">= </font><font color="#FF0000"><b>RECORD
              </b></font>realpart<font color="#000080">, </font>imagpart <font color="#000080">: </font>real
            <font color="#FF0000"><b>END</b></font><font color="#000080">;
  </font>dataarraytype <font color="#000080">= </font><font color="#FF0000"><b>RECORD
                    CASE </b></font><font color="#000080">(</font>r<font color="#000080">, </font>c<font color="#000080">) </font><font color="#FF0000"><b>OF
                      </b></font>r <font color="#000080">: (</font>rp <font color="#000080">: </font><font color="#FF0000"><b>ARRAY </b></font><font color="#000080">[</font>dataindextype<font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>real<font color="#000080">);
                      </font>c <font color="#000080">: (</font>cp <font color="#000080">: </font><font color="#FF0000"><b>ARRAY </b></font><font color="#000080">[</font>cmpxindextype<font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>complex<font color="#000080">)
                  </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
  </font>cstermtype <font color="#000080">= </font><font color="#FF0000"><b>RECORD
                 </b></font>cosineterm<font color="#000080">, </font>sineterm <font color="#000080">: </font>real
               <font color="#FF0000"><b>END</b></font><font color="#000080">;
  </font>fouriertype <font color="#000080">= </font><font color="#FF0000"><b>RECORD
                  </b></font>dcterm <font color="#000080">: </font>real<font color="#000080">;
                  </font>noiseterm <font color="#000080">: </font>real<font color="#000080">;
                  </font>freqterms <font color="#000080">: </font><font color="#FF0000"><b>ARRAY </b></font><font color="#000080">[</font>freqindextype<font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>cstermtype
                <font color="#FF0000"><b>END</b></font><font color="#000080">;
  </font>mixedtype <font color="#000080">= </font><font color="#FF0000"><b>RECORD
                CASE </b></font><font color="#000080">(</font>dtype<font color="#000080">, </font>ctype<font color="#000080">) </font><font color="#FF0000"><b>OF
                  </b></font>dtype <font color="#000080">: (</font>dataslot <font color="#000080">: </font>dataarraytype<font color="#000080">);
                  </font>ctype <font color="#000080">: (</font>coefslot <font color="#000080">: </font>fouriertype<font color="#000080">)
              </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
 
</font><font color="#FF0000"><b>CONST
  </b></font>twopi <font color="#000080">= </font><font color="#800000">6.2831853</font><font color="#000080">;
</font><font color="#FF0000"><b>VAR
  </b></font>data <font color="#000080">: </font>dataarraytype<font color="#000080">;
  </font>didx <font color="#000080">: </font>dataindextype<font color="#000080">;
  </font>fidx <font color="#000080">: </font>freqindextype<font color="#000080">;
  </font>coefficients <font color="#000080">: </font>fouriertype<font color="#000080">;
  </font>mixed <font color="#000080">: </font>mixedtype<font color="#000080">;
 
  </font><font color="#008000"><i>{ A note on declarations, above.  Pascal does not have a base type of
   &quot;complex&quot;, but it is fairly simple, given the strong typing in the
   language, to define such a type.  One needs to write procedures (see
   below) that implement the common arithmetic operators.  Functions
   would be even better, from a logical standpoint, but the language
   standard does not permit returning a record type from a function.
   .     The FFT, strictly speaking, is a technique for transforming a
   complex array of points-in-time into a complex array of points-in-
   Fourier space (complex numbers that represent the gain and phase of
   the response at discrete frequencies).  One typically has data,
   representing samples taken at some fixed sampling rate, for which
   one wants the Fourier transform, to compute a power spectrum, for
   example.  Such data, of course, are &quot;real&quot; quantities.  One could
   take these N points, make them the real part of a complex array of
   size N (setting the imaginary part to zero), and take the FFT.
   However, in the interest of speed (the first F of FFT means &quot;fast&quot;,
   after all), one can also do a trick where the N &quot;real&quot; points are
   identified with the real, imaginary, real, imaginary, etc. points of
   a complex array of size N/2.  The FFT now takes about half the time,
   and one needs to do some final twiddling to obtain the sine/cosine
   coefficients of the size N real array from the coefficients of the
   size N/2 complex array.
   .     To clarify the dual interpretation of the data array as either
   N reals or N/2 complex points, the tagged type &quot;dataarraytype&quot; was
   defined.  On input, it represents the complex data; on output from the
   complex FFT, it represents the complex Fourier coefficients.  A final
   transformation on these complex coefficients can convert them into a
   series of real sine/cosine terms; for this purpose, the tagged type
   &quot;mixed&quot; was defined for the real FFT.
   .     Finally, note that this, and most, FFT routines get their
   speed when the number of points is a power of 2.  This is because
   the speed comes from a divide-and-conquer approach -- to do an FFT
   of N points, do two FFTs of N/2 points and combine the results. }
 
 
  </i></font><font color="#FF0000"><b>PROCEDURE </b></font>fftofreal <font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>mixed <font color="#000080">: </font>mixedtype<font color="#000080">;
                       </font>realpoints <font color="#000080">: </font>integer<font color="#000080">);
 
    </font><font color="#008000"><i>{ This routine performs a forward Fourier transform of an array
     &quot;mixed&quot;, which on input is assumed to consist of &quot;realpoints&quot; data
     points and on output consists of a set of Fourier coefficients (a
     DC term, (N/2 - 1) sine and cosine terms, and a residual &quot;noise&quot;
     term). }
 
  </i></font><font color="#FF0000"><b>CONST
    </b></font>twopi <font color="#000080">= </font><font color="#800000">6.2831853</font><font color="#000080">;
  </font><font color="#FF0000"><b>VAR
    </b></font>index<font color="#000080">, </font>minusindex <font color="#000080">: </font>freqindextype<font color="#000080">;
    </font>temp1<font color="#000080">, </font>temp2<font color="#000080">, </font>temp3<font color="#000080">, </font>w <font color="#000080">: </font>complex<font color="#000080">;
    </font>baseangle <font color="#000080">: </font>real<font color="#000080">;
 
    </font><font color="#008000"><i>{ The following procedures implement complex arithmetic -- }
 
    </i></font><font color="#FF0000"><b>PROCEDURE </b></font>cadd <font color="#000080">(</font>a<font color="#000080">, </font>b <font color="#000080">: </font>complex<font color="#000080">;
                    </font><font color="#FF0000"><b>VAR </b></font>c <font color="#000080">: </font>complex<font color="#000080">);
 
      </font><font color="#008000"><i>{ c := a + b }
 
     </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ cadd }
       </i></font><font color="#FF0000"><b>WITH </b></font>c <font color="#FF0000"><b>DO
        BEGIN
          </b></font>realpart <font color="#000080">:= </font>a<font color="#000080">.</font>realpart <font color="#000080">+ </font>b<font color="#000080">.</font>realpart<font color="#000080">;
          </font>imagpart <font color="#000080">:= </font>a<font color="#000080">.</font>imagpart <font color="#000080">+ </font>b<font color="#000080">.</font>imagpart
        <font color="#FF0000"><b>END
     END</b></font><font color="#000080">;
 
    </font><font color="#FF0000"><b>PROCEDURE </b></font>csubtract <font color="#000080">(</font>a<font color="#000080">, </font>b <font color="#000080">: </font>complex<font color="#000080">;
                         </font><font color="#FF0000"><b>VAR </b></font>c <font color="#000080">: </font>complex<font color="#000080">);
 
      </font><font color="#008000"><i>{ c := a - b }
 
     </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ csubtract }
       </i></font><font color="#FF0000"><b>WITH </b></font>c <font color="#FF0000"><b>DO
        BEGIN
          </b></font>realpart <font color="#000080">:= </font>a<font color="#000080">.</font>realpart <font color="#000080">- </font>b<font color="#000080">.</font>realpart<font color="#000080">;
          </font>imagpart <font color="#000080">:= </font>a<font color="#000080">.</font>imagpart <font color="#000080">- </font>b<font color="#000080">.</font>imagpart
        <font color="#FF0000"><b>END
     END</b></font><font color="#000080">;
 
    </font><font color="#FF0000"><b>PROCEDURE </b></font>cmultiply <font color="#000080">(</font>a<font color="#000080">, </font>b <font color="#000080">: </font>complex<font color="#000080">;
                         </font><font color="#FF0000"><b>VAR </b></font>c <font color="#000080">: </font>complex<font color="#000080">);

      </font><font color="#008000"><i>{ c := a * b }
 
     </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ cmultiply }
       </i></font><font color="#FF0000"><b>WITH </b></font>c <font color="#FF0000"><b>DO
        BEGIN
          </b></font>realpart <font color="#000080">:= </font>a<font color="#000080">.</font>realpart<font color="#000080">*</font>b<font color="#000080">.</font>realpart <font color="#000080">- </font>a<font color="#000080">.</font>imagpart<font color="#000080">*</font>b<font color="#000080">.</font>imagpart<font color="#000080">;
          </font>imagpart <font color="#000080">:= </font>a<font color="#000080">.</font>realpart<font color="#000080">*</font>b<font color="#000080">.</font>imagpart <font color="#000080">+ </font>b<font color="#000080">.</font>realpart<font color="#000080">*</font>a<font color="#000080">.</font>imagpart
        <font color="#FF0000"><b>END
     END</b></font><font color="#000080">;
 
    </font><font color="#FF0000"><b>PROCEDURE </b></font>conjugate <font color="#000080">(</font>a <font color="#000080">: </font>complex<font color="#000080">;
                         </font><font color="#FF0000"><b>VAR </b></font>b <font color="#000080">: </font>complex<font color="#000080">);
 
      </font><font color="#008000"><i>{ b := a* }
 
     </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ conjugate }
       </i></font><font color="#FF0000"><b>WITH </b></font>b <font color="#FF0000"><b>DO
        BEGIN
          </b></font>realpart <font color="#000080">:= </font>a<font color="#000080">.</font>realpart<font color="#000080">;
          </font>imagpart <font color="#000080">:= -</font>a<font color="#000080">.</font>imagpart
        <font color="#FF0000"><b>END
     END</b></font><font color="#000080">;
 
    </font><font color="#FF0000"><b>PROCEDURE </b></font>forwardfft <font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>data <font color="#000080">: </font>dataarraytype<font color="#000080">;
                          </font>complexpoints <font color="#000080">: </font>integer<font color="#000080">);
 

      </font><font color="#008000"><i>{ The basic FFT is a recursive routine that basically works as
       follows:
       1)  The FFT is a linear operator, so the FFT of a sum is simply
       .   the sum of the FFTs of each addend.
       2)  The FFT of a time series shifted in time is the FFT of the
       .   unshifted series adjusted by a twiddle factor which looks
       .   like a (complex) root of 1 (an nth root of unity).
       3)  Consider N points, equally spaced in time, for which you
       .   want an FFT.  Start by splitting the series into odd and
       .   even samples, giving you two series with N/2 points,
       .   equally spaced, but with the second series delayed in time
       .   by one sample.  Take the FFT of each series.  Using property
       .   2), adjust the FFT of the second series for the time delay.
       .   Now using property 1), since the original N points is simply
       .   the sum of the two N/2 series, the FFT we want is simply the
       .   sum of the FFTs of the two sub-series (with the adjustment
       .   in the second for the time delay).
       4)  This is essentially a recursive definition.  To do an N-point
       .   FFT, do two N/2 point FFTs and combine the answers.  All we
       .   need to stop the recursion is to know how to do a 2-point
       .   FFT: if a and b are the two (complex) input points, the
       .   two-point FFT equations are A := a+b; B := a-b.
       5)  The FFT is rarely coded in its fully-recursive form.  It
       .   turns out to be fairly simple to &quot;unroll&quot; the recursion and
       .   reorder it a bit, which simplifies the computation of the
       .   roots-of-unity complex twiddle factors.  The only drawback
       .   is that the output array ends up scrambled -- if the array
       .   indices are represented as going from 0 to M-1, then if one
       .   represents the array index as a binary number, one needs to
       .   bit-reverse the number to get the proper place in the array.
       .   Thus, the next step is to swap values by bit-reversing the
       .   indices.
       6)  There are numerous references on the FFT.  A reasonable one
       .   is &quot;Numerical Recipes&quot; by Press et al., Cambridge University
       .   Press, which I believe exists in several language flavors. }
 
    </i></font><font color="#FF0000"><b>CONST
      </b></font>twopi <font color="#000080">= </font><font color="#800000">6.2831853</font><font color="#000080">;
 
      </font><font color="#FF0000"><b>PROCEDURE </b></font>docomplextransform<font color="#000080">;
 
      </font><font color="#FF0000"><b>VAR
        </b></font>partitionsize<font color="#000080">, </font>halfsize<font color="#000080">, </font>offset<font color="#000080">,
        </font>lowindex<font color="#000080">, </font>highindex <font color="#000080">: </font>dataindextype<font color="#000080">;
        </font>baseangle<font color="#000080">, </font>angle <font color="#000080">: </font>real<font color="#000080">;
        </font>bits <font color="#000080">: </font>integer<font color="#000080">;
        </font>w<font color="#000080">, </font>temp <font color="#000080">: </font>complex<font color="#000080">;
 
       </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ docomplextransform }
         </i></font>partitionsize <font color="#000080">:= </font>complexpoints<font color="#000080">;
         </font><font color="#FF0000"><b>WITH </b></font>data <font color="#FF0000"><b>DO
          REPEAT
           </b></font>halfsize <font color="#000080">:= </font>partitionsize <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">;
           </font>baseangle <font color="#000080">:= </font>twopi<font color="#000080">/</font>partitionsize<font color="#000080">;
           </font><font color="#FF0000"><b>FOR </b></font>offset <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>halfsize <font color="#FF0000"><b>DO
            BEGIN
              </b></font>angle <font color="#000080">:= </font>baseangle <font color="#000080">* </font>pred<font color="#000080">(</font>offset<font color="#000080">);
              </font>w<font color="#000080">.</font>realpart <font color="#000080">:= </font>cos<font color="#000080">(</font>angle<font color="#000080">);
              </font>w<font color="#000080">.</font>imagpart <font color="#000080">:= -</font>sin<font color="#000080">(</font>angle<font color="#000080">);
              </font>lowindex <font color="#000080">:= </font>offset<font color="#000080">;
               </font><font color="#FF0000"><b>REPEAT
                </b></font>highindex <font color="#000080">:= </font>lowindex <font color="#000080">+ </font>halfsize<font color="#000080">;
                </font>csubtract <font color="#000080">(</font>cp<font color="#000080">[</font>lowindex<font color="#000080">], </font>cp<font color="#000080">[</font>highindex<font color="#000080">], </font>temp<font color="#000080">);
                </font>cadd <font color="#000080">(</font>cp<font color="#000080">[</font>lowindex<font color="#000080">], </font>cp<font color="#000080">[</font>highindex<font color="#000080">], </font>cp<font color="#000080">[</font>lowindex<font color="#000080">]);
                </font>cmultiply <font color="#000080">(</font>temp<font color="#000080">, </font>w<font color="#000080">, </font>cp<font color="#000080">[</font>highindex<font color="#000080">]);
                </font>lowindex <font color="#000080">:= </font>lowindex <font color="#000080">+ </font>partitionsize
               <font color="#FF0000"><b>UNTIL </b></font>lowindex <font color="#000080">&gt;= </font>complexpoints
            <font color="#FF0000"><b>END</b></font><font color="#000080">;
           </font>partitionsize <font color="#000080">:= </font>partitionsize <font color="#FF0000"><b>DIV </b></font><font color="#800000">2
          </font><font color="#FF0000"><b>UNTIL </b></font>partitionsize <font color="#000080">= </font><font color="#800000">1
       </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
 
      </font><font color="#FF0000"><b>PROCEDURE </b></font>shufflecoefficients<font color="#000080">;
 
      </font><font color="#FF0000"><b>VAR
        </b></font>lowindex<font color="#000080">, </font>highindex <font color="#000080">: </font>dataindextype<font color="#000080">;
        </font>bits <font color="#000080">: </font>integer<font color="#000080">;
 
        </font><font color="#FF0000"><b>FUNCTION </b></font>log2 <font color="#000080">(</font>index <font color="#000080">: </font>integer<font color="#000080">) : </font>integer<font color="#000080">;
 
          </font><font color="#008000"><i>{ Recursive routine, where &quot;index&quot; is assumed a power of 2.
           Note the routine will fail (by endless recursion) if
           &quot;index&quot; &lt;= 0. }
 
         </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ log2 }
           </i></font><font color="#FF0000"><b>IF </b></font>index <font color="#000080">= </font><font color="#800000">1
            </font><font color="#FF0000"><b>THEN </b></font>log2 <font color="#000080">:= </font><font color="#800000">0
            </font><font color="#FF0000"><b>ELSE </b></font>log2 <font color="#000080">:= </font>succ<font color="#000080">(</font>log2<font color="#000080">(</font>index <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">))
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;

        </font><font color="#FF0000"><b>FUNCTION </b></font>bitreversal <font color="#000080">(</font>index<font color="#000080">, </font>bits <font color="#000080">: </font>integer<font color="#000080">) : </font>integer<font color="#000080">;
 
          </font><font color="#008000"><i>{ Takes an index, in the range 1 .. 2**bits, and computes a
           bit-reversed index in the same range.  It first undoes the
           offset of 1, bit-reverses the &quot;bits&quot;-bit binary number,
           then redoes the offset.  Thus if bits = 4, the range is
           1 .. 16, and bitreversal (1, 4) = 9,
           bitreversal (16, 4) = 16, etc. }
 
          </i></font><font color="#FF0000"><b>FUNCTION </b></font>reverse <font color="#000080">(</font>bits<font color="#000080">, </font>stib<font color="#000080">, </font>bitsleft <font color="#000080">: </font>integer<font color="#000080">) : </font>integer<font color="#000080">;

            </font><font color="#008000"><i>{ Recursive bit-reversing function, transforms &quot;bits&quot; into
             bit-reversed &quot;stib.  It's pretty easy to convert this to
             an iterative form, but I think the recursive form is
             easier to understand, and should entail a trivial penalty
             in speed (in the overall algorithm). }
 
           </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ reverse }
             </i></font><font color="#FF0000"><b>IF </b></font>bitsleft <font color="#000080">= </font><font color="#800000">0
              </font><font color="#FF0000"><b>THEN </b></font>reverse <font color="#000080">:= </font>stib
              <font color="#FF0000"><b>ELSE
              IF </b></font>odd <font color="#000080">(</font>bits<font color="#000080">)
               </font><font color="#FF0000"><b>THEN </b></font>reverse <font color="#000080">:= </font>reverse <font color="#000080">(</font>bits <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">, </font>succ <font color="#000080">(</font>stib <font color="#000080">* </font><font color="#800000">2</font><font color="#000080">),
                                        </font>pred <font color="#000080">(</font>bitsleft<font color="#000080">))
               </font><font color="#FF0000"><b>ELSE </b></font>reverse <font color="#000080">:= </font>reverse <font color="#000080">(</font>bits <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">, </font>stib <font color="#000080">* </font><font color="#800000">2</font><font color="#000080">,
                                        </font>pred <font color="#000080">(</font>bitsleft<font color="#000080">))
           </font><font color="#FF0000"><b>END</b></font><font color="#000080">;

         </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ bitreversal }
           </i></font>bitreversal <font color="#000080">:= </font>succ <font color="#000080">(</font>reverse <font color="#000080">(</font>pred<font color="#000080">(</font>index<font color="#000080">), </font><font color="#800000">0</font><font color="#000080">, </font>bits<font color="#000080">))
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
 
        </font><font color="#FF0000"><b>PROCEDURE </b></font>swap <font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>a<font color="#000080">, </font>b <font color="#000080">: </font>complex<font color="#000080">);
 
        </font><font color="#FF0000"><b>VAR
          </b></font>temp <font color="#000080">: </font>complex<font color="#000080">;
 
         </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ swap }
           </i></font>temp <font color="#000080">:= </font>a<font color="#000080">;
           </font>a <font color="#000080">:= </font>b<font color="#000080">;
           </font>b <font color="#000080">:= </font>temp
         <font color="#FF0000"><b>END</b></font><font color="#000080">;
 
       </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ shufflecoefficients }
         </i></font>bits <font color="#000080">:= </font>log2 <font color="#000080">(</font>complexpoints<font color="#000080">);
         </font><font color="#FF0000"><b>WITH </b></font>data <font color="#FF0000"><b>DO
         FOR </b></font>lowindex <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>complexpoints <font color="#FF0000"><b>DO
          BEGIN
            </b></font>highindex <font color="#000080">:= </font>bitreversal<font color="#000080">(</font>lowindex<font color="#000080">, </font>bits<font color="#000080">);
            </font><font color="#FF0000"><b>IF </b></font>highindex <font color="#000080">&gt; </font>lowindex
             <font color="#FF0000"><b>THEN </b></font>swap <font color="#000080">(</font>cp<font color="#000080">[</font>lowindex<font color="#000080">], </font>cp<font color="#000080">[</font>highindex<font color="#000080">])
          </font><font color="#FF0000"><b>END
       END</b></font><font color="#000080">;
 
      </font><font color="#FF0000"><b>PROCEDURE </b></font>dividebyn<font color="#000080">;

      </font><font color="#008000"><i>{ This procedure is needed to get FFT to scale correctly. }
 
      </i></font><font color="#FF0000"><b>VAR
        </b></font>index <font color="#000080">: </font>dataindextype<font color="#000080">;
 
       </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ dividebyn }
         </i></font><font color="#FF0000"><b>WITH </b></font>data <font color="#FF0000"><b>DO
         FOR </b></font>index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>complexpoints <font color="#FF0000"><b>DO
         WITH </b></font>cp<font color="#000080">[</font>index<font color="#000080">] </font><font color="#FF0000"><b>DO
          BEGIN
            </b></font>realpart <font color="#000080">:= </font>realpart<font color="#000080">/</font>complexpoints<font color="#000080">;
            </font>imagpart <font color="#000080">:= </font>imagpart<font color="#000080">/</font>complexpoints

          <font color="#FF0000"><b>END
       END</b></font><font color="#000080">;
 
     </font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ forwardfft }
       </i></font>docomplextransform<font color="#000080">;
       </font>shufflecoefficients<font color="#000080">;
       </font>dividebyn
     <font color="#FF0000"><b>END</b></font><font color="#000080">;
 
     </font><font color="#008000"><i>{ Note that the data slots and coefficient slots in the mixed
     data type share storage.  From the first complex coefficient,
     we can derive the DC and noise term; from pairs of the remaining
     coefficients, we can derive pairs of sine/cosine terms. }
 
 
   </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ fftofreal }
     </i></font>forwardfft <font color="#000080">(</font>mixed<font color="#000080">.</font>dataslot<font color="#000080">, </font>realpoints <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">);
     </font>temp1 <font color="#000080">:= </font>mixed<font color="#000080">.</font>dataslot<font color="#000080">.</font>cp<font color="#000080">[</font><font color="#800000">1</font><font color="#000080">];
     </font><font color="#FF0000"><b>WITH </b></font>mixed<font color="#000080">.</font>coefslot<font color="#000080">, </font>temp1 <font color="#FF0000"><b>DO
      BEGIN
        </b></font>dcterm <font color="#000080">:= (</font>realpart <font color="#000080">+ </font>imagpart<font color="#000080">)/</font><font color="#800000">2</font><font color="#000080">;
        </font>noiseterm <font color="#000080">:= (</font>realpart <font color="#000080">- </font>imagpart<font color="#000080">)/</font><font color="#800000">2
      </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
     </font>baseangle <font color="#000080">:= -</font>twopi<font color="#000080">/</font>realpoints<font color="#000080">;
     </font><font color="#FF0000"><b>FOR </b></font>index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>realpoints <font color="#FF0000"><b>DIV </b></font><font color="#800000">4 </font><font color="#FF0000"><b>DO
      BEGIN
        </b></font>minusindex <font color="#000080">:= (</font>realpoints <font color="#FF0000"><b>DIV </b></font><font color="#800000">2</font><font color="#000080">) - </font>index<font color="#000080">;
        </font><font color="#FF0000"><b>WITH </b></font>mixed<font color="#000080">.</font>dataslot <font color="#FF0000"><b>DO
         BEGIN
           </b></font>conjugate <font color="#000080">(</font>cp<font color="#000080">[</font>succ<font color="#000080">(</font>minusindex<font color="#000080">)], </font>temp2<font color="#000080">);
           </font>cadd <font color="#000080">(</font>cp<font color="#000080">[</font>succ<font color="#000080">(</font>index<font color="#000080">)], </font>temp2<font color="#000080">, </font>temp1<font color="#000080">);
           </font>csubtract <font color="#000080">(</font>cp<font color="#000080">[</font>succ<font color="#000080">(</font>index<font color="#000080">)], </font>temp2<font color="#000080">, </font>temp2<font color="#000080">)
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
        </font>w<font color="#000080">.</font>realpart <font color="#000080">:= </font>sin<font color="#000080">(</font>index<font color="#000080">*</font>baseangle<font color="#000080">);
        </font>w<font color="#000080">.</font>imagpart <font color="#000080">:= -</font>cos<font color="#000080">(</font>index<font color="#000080">*</font>baseangle<font color="#000080">);
        </font>cmultiply <font color="#000080">(</font>w<font color="#000080">, </font>temp2<font color="#000080">, </font>temp2<font color="#000080">);
        </font>cadd <font color="#000080">(</font>temp1<font color="#000080">, </font>temp2<font color="#000080">, </font>temp3<font color="#000080">);
        </font>csubtract <font color="#000080">(</font>temp1<font color="#000080">, </font>temp2<font color="#000080">, </font>temp2<font color="#000080">);
        </font>conjugate <font color="#000080">(</font>temp2<font color="#000080">, </font>temp2<font color="#000080">);
        </font><font color="#FF0000"><b>WITH </b></font>mixed<font color="#000080">.</font>coefslot<font color="#000080">.</font>freqterms<font color="#000080">[</font>index<font color="#000080">], </font>temp3 <font color="#FF0000"><b>DO
         BEGIN
           </b></font>cosineterm <font color="#000080">:= </font>realpart<font color="#000080">/</font><font color="#800000">2</font><font color="#000080">;
           </font>sineterm <font color="#000080">:= -</font>imagpart<font color="#000080">/</font><font color="#800000">2
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
        </font><font color="#FF0000"><b>WITH </b></font>mixed<font color="#000080">.</font>coefslot<font color="#000080">.</font>freqterms<font color="#000080">[</font>minusindex<font color="#000080">], </font>temp2 <font color="#FF0000"><b>DO
         BEGIN
           </b></font>cosineterm <font color="#000080">:= </font>realpart<font color="#000080">/</font><font color="#800000">2</font><font color="#000080">;
           </font>sineterm <font color="#000080">:= </font>imagpart<font color="#000080">/</font><font color="#800000">2
         </font><font color="#FF0000"><b>END
      END
   END</b></font><font color="#000080">;
 
  </font><font color="#FF0000"><b>FUNCTION </b></font>omegat <font color="#000080">(</font>f <font color="#000080">: </font>freqindextype<font color="#000080">; </font>t <font color="#000080">: </font>dataindextype<font color="#000080">) : </font>real<font color="#000080">;
 
    </font><font color="#008000"><i>{ computes omega*t for particular harmonic, index }

   </i></font><font color="#FF0000"><b>BEGIN   </b></font><font color="#008000"><i>{ omegat }
     </i></font>omegat <font color="#000080">:= </font>twopi <font color="#000080">* </font>f <font color="#000080">* </font>pred<font color="#000080">(</font>t<font color="#000080">) / </font>maxarraysize
   <font color="#FF0000"><b>END</b></font><font color="#000080">;
 
  </font><font color="#008000"><i>{ main test routine starts here }
 
 </i></font><font color="#FF0000"><b>BEGIN
   WITH </b></font>mixed<font color="#000080">.</font>dataslot <font color="#FF0000"><b>DO
   FOR </b></font>didx <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>maxarraysize <font color="#FF0000"><b>DO
   </b></font>rp<font color="#000080">[</font>didx<font color="#000080">] := (</font><font color="#800000">23
                </font><font color="#000080">+ </font><font color="#800000">13 </font><font color="#000080">* </font>sin<font color="#000080">(</font>omegat <font color="#000080">(</font><font color="#800000">7</font><font color="#000080">, </font>didx<font color="#000080">))
                + </font><font color="#800000">28 </font><font color="#000080">* </font>cos<font color="#000080">(</font>omegat <font color="#000080">(</font><font color="#800000">22</font><font color="#000080">, </font>didx<font color="#000080">)));
   </font>fftofreal <font color="#000080">(</font>mixed<font color="#000080">, </font>maxarraysize<font color="#000080">);
   </font><font color="#FF0000"><b>WITH </b></font>mixed<font color="#000080">.</font>coefslot <font color="#FF0000"><b>DO
   </b></font>writeln <font color="#000080">(</font><font color="#800000">'DC = '</font><font color="#000080">, </font>dcterm<font color="#000080">:</font><font color="#800000">10</font><font color="#000080">:</font><font color="#800000">2</font><font color="#000080">, </font><font color="#800000">' '</font><font color="#000080">:</font><font color="#800000">5</font><font color="#000080">, </font><font color="#800000">'Noise = '</font><font color="#000080">, </font>noiseterm<font color="#000080">:</font><font color="#800000">10</font><font color="#000080">:</font><font color="#800000">2</font><font color="#000080">);
   </font><font color="#FF0000"><b>FOR </b></font>fidx <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>TO </b></font>maxfreqsize <font color="#FF0000"><b>DO
    BEGIN
      WITH </b></font>mixed<font color="#000080">.</font>coefslot<font color="#000080">.</font>freqterms<font color="#000080">[</font>fidx<font color="#000080">] </font><font color="#FF0000"><b>DO
      </b></font>write <font color="#000080">(</font>fidx<font color="#000080">:</font><font color="#800000">4</font><font color="#000080">, </font>round<font color="#000080">(</font>cosineterm<font color="#000080">):</font><font color="#800000">4</font><font color="#000080">, </font>round<font color="#000080">(</font>sineterm<font color="#000080">):</font><font color="#800000">4</font><font color="#000080">, </font><font color="#800000">' '</font><font color="#000080">:</font><font color="#800000">4</font><font color="#000080">);
      </font><font color="#FF0000"><b>IF </b></font>fidx <font color="#FF0000"><b>MOD </b></font><font color="#800000">4 </font><font color="#000080">= </font><font color="#800000">0
       </font><font color="#FF0000"><b>THEN </b></font>writeln
    <font color="#FF0000"><b>END</b></font><font color="#000080">;
   </font>writeln<font color="#000080">;
   </font>writeln <font color="#000080">(</font><font color="#800000">'The expected result should have been:'</font><font color="#000080">);
   </font>writeln <font color="#000080">(</font><font color="#800000">'  DC = 23, noise = 0, '</font><font color="#000080">);
   </font>writeln <font color="#000080">(</font><font color="#800000">'  sine 7th harmonic = 13, cosine 22nd harmonic = 28'</font><font color="#000080">)
 </font><font color="#FF0000"><b>END</b></font><font color="#000080">.
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to MATH SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0074.PAS">Original</a><b>]</b></p></body>
</html>
