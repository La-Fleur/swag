<html>
<head><title> "Advanced measurment of operations" by YUVAL MELAMED</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to TIMING SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0043.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>(*
  Written by Yuval Melamed &lt;melamed@star.net.il&gt;, 25-Oct-1997.

  THIS CODE USES MSRs - REQUIRES PENTIUM AND ABOVE.
  This source code is mainly to show an advanced way to measure the
  performance of operations.
  The ClockOn/ClockOff procedure can be put inside a unit, that you
  can use instead of the old, unreliable but popular timer-based
  testers.

  What makes my procedures so accurate, is the counting of internal
  clock cycles (aka proccessor's speed in MHz), instead of relying on the
  slow RTC (only 18.2 times a sec, compared to 133,000,000 clock cycles on
  a 133MHz Pentium.

  The usage of this is great - starting from small yet accurate speed
  testers for regular procedures, ending by the test of very very gentle
  operations, such as different memory accessing methods !

  To make this procedures to measure TIME instead of CLOCKS, you can use:

    ClockOn;
    Delay(1000); {use CRT, or use Int 15h/AH=86h}
    ClockOff;
    CPUSpeed := Clocks / 1000000; {var CPUSpeed : Real}

  and then produce a *nano-second* (!!!) accurate results by using:

    ClockOn;
    ... whatever ... {put here the operation to measure}
    ClockOff;
    NanoSeconds := Clocks / CPUSpeed; {var NanoSeconds : extended}
*)

</i></font><font color="#FF0000"><b>const
  </b></font>Times <font color="#000080">= </font><font color="#800000">1000000</font><font color="#000080">; </font><font color="#008000"><i>{times to run the test loop}

</i></font><font color="#FF0000"><b>var
  </b></font>Index <font color="#000080">: </font>Longint<font color="#000080">;   </font><font color="#008000"><i>{loop counter}
  </i></font>Clocks<font color="#000080">,            </font><font color="#008000"><i>{clock cycles counter}
  </i></font>Resolution <font color="#000080">: </font>comp<font color="#000080">; </font><font color="#008000"><i>{measurement-resolution in clock cycles}

(* This procedure 'starts' the timer.
   It actually reads the value of the TSC (Time Stamp Counter) of the
   Pentium/Compatible proccessor (TSC is one of the MSRs = Model Specific
   Registers, first introduced with the Pentium).
   The TSC is set to 0 on cold-boot, and increments every internal clock
   cycle (nnn million times on a nnnMHz proccessor).
   The TSC is a 64-bit register, thus we use a comp type to hold it.
   We use a 10h-ECX-indexed 'rdmsr' (Read MSR) even though there's a
   specific opcode to read the TSC (rdtsc), because 'rdmsr' works better
   in most cases.                                                         *)
</i></font><font color="#FF0000"><b>procedure </b></font>ClockOn<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
  </b></font><font color="#FF00FF">db 66h; mov cx,0010h; dw 0000h   </font><font color="#008000"><i>(* mov ecx,10h                *)
  </i></font><font color="#FF00FF">db 0Fh,32h                       </font><font color="#008000"><i>(* rdmsr                      *)
  </i></font><font color="#FF00FF">db 66h; mov word ptr Clocks,ax   </font><font color="#008000"><i>(* mov dword ptr Clocks,eax   *)
  </i></font><font color="#FF00FF">db 66h; mov word ptr Clocks+4,dx </font><font color="#008000"><i>(* mov dword ptr Clocks+4,edx *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>(* This procedure 'stops' the timer.
   It reads the TSC again, and substract the last TSC read from it (to
   substract 64-bit register, I use 32-bit sub's, with overflow check). *)
</i></font><font color="#FF0000"><b>procedure </b></font>ClockOff<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
  </b></font><font color="#FF00FF">db 66h; mov cx,0010h; dw 0000h   </font><font color="#008000"><i>(* mov ecx,10h                *)
  </i></font><font color="#FF00FF">db 0Fh,32h                       </font><font color="#008000"><i>(* rdmsr                      *)
  </i></font><font color="#FF00FF">db 66h; sub ax,word ptr Clocks   </font><font color="#008000"><i>(* sub eax,dword ptr Clocks   *)
  </i></font><font color="#FF00FF">db 66h; sbb dx,word ptr Clocks+4 </font><font color="#008000"><i>(* sbb edx,dword ptr Clocks+4 *)
  </i></font><font color="#FF00FF">db 66h; mov word ptr Clocks,ax   </font><font color="#008000"><i>(* mov dword ptr Clocks,eax   *)
  </i></font><font color="#FF00FF">db 66h; mov word ptr Clocks+4,dx </font><font color="#008000"><i>(* mov dword ptr Clocks+4,edx *)
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>(* This procedure does nothing (using NOP mnemonic), except being a
   'standard' pascal procedure, that is - 'begin end;' bounded.     *)
</i></font><font color="#FF0000"><b>procedure </b></font>PascalProc<font color="#000080">;
</font><font color="#FF0000"><b>begin
  asm
    </b></font><font color="#FF00FF">nop
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>(* This procedure uses the 'assembler' directive, to prevent 'call'
   command to it, from allocating superflouos stack memory (see Help
   for details, or track this code with a debugger).
   On my configuration (Turbo-Pascal 7.0, Pentium 133MHz) it is 225% (!)
   faster than a standard procedure.                                     *)
</i></font><font color="#FF0000"><b>procedure </b></font>AssemblerProc<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
  </b></font><font color="#FF00FF">nop
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#008000"><i>(* This is not actually a procedure, since it never gets to be really
   'call'ed. That is, because 'inline' means the code is inserted
   directly each time it is 'called' (again, see Help/Debugger).
   On my PC, it is 900% faster than using a regular Pascal procedure to
   implement the same code... GO OPTIMIZE !!! ;)                        *)
</i></font><font color="#FF0000"><b>procedure </b></font>InlineProc<font color="#000080">; </font><font color="#FF0000"><b>inline
</b></font><font color="#000080">(
  </font><font color="#800000">$90 </font><font color="#008000"><i>{90h is the value of the byte-sized NOP mnemonic}
</i></font><font color="#000080">);

</font><font color="#FF0000"><b>begin
  </b></font>Writeln<font color="#000080">;
  </font>Writeln<font color="#000080">(</font>Times<font color="#000080">, </font><font color="#800000">' calls to different types of identical procedures :'</font><font color="#000080">);
  </font>ClockOn<font color="#000080">;
  </font><font color="#FF0000"><b>for </b></font>Index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Times <font color="#FF0000"><b>do</b></font><font color="#000080">;
  </font>ClockOff<font color="#000080">;
  </font>Resolution <font color="#000080">:= </font>Clocks<font color="#000080">; </font><font color="#008000"><i>{use 'Resolution' to filter the loop timings}

  </i></font>ClockOn<font color="#000080">;
  </font><font color="#FF0000"><b>for </b></font>Index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Times <font color="#FF0000"><b>do </b></font>PascalProc<font color="#000080">;
  </font>ClockOff<font color="#000080">;
  </font>Writeln<font color="#000080">(</font><font color="#800000">'  Standard Pascal procedure            : '</font><font color="#000080">,
    </font>Clocks<font color="#000080">-</font>Resolution<font color="#000080">:</font><font color="#800000">10</font><font color="#000080">:</font><font color="#800000">0</font><font color="#000080">, </font><font color="#800000">' clks.'</font><font color="#000080">);

  </font>ClockOn<font color="#000080">;
  </font><font color="#FF0000"><b>for </b></font>Index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Times <font color="#FF0000"><b>do </b></font>AssemblerProc<font color="#000080">;
  </font>ClockOff<font color="#000080">;
  </font>Writeln<font color="#000080">(</font><font color="#800000">'  assembler-directived procedure       : '</font><font color="#000080">,
    </font>Clocks<font color="#000080">-</font>Resolution<font color="#000080">:</font><font color="#800000">10</font><font color="#000080">:</font><font color="#800000">0</font><font color="#000080">, </font><font color="#800000">' clks.'</font><font color="#000080">);

  </font>ClockOn<font color="#000080">;
  </font><font color="#FF0000"><b>for </b></font>Index <font color="#000080">:= </font><font color="#800000">1 </font><font color="#FF0000"><b>to </b></font>Times <font color="#FF0000"><b>do </b></font>InlineProc<font color="#000080">;
  </font>ClockOff<font color="#000080">;
  </font>Writeln<font color="#000080">(</font><font color="#800000">'  procedure of type inline (no call)   : '</font><font color="#000080">,
    </font>Clocks<font color="#000080">-</font>Resolution<font color="#000080">:</font><font color="#800000">10</font><font color="#000080">:</font><font color="#800000">0</font><font color="#000080">, </font><font color="#800000">' clks.'</font><font color="#000080">);
</font><font color="#FF0000"><b>end</b></font><font color="#000080">.
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to TIMING SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0043.PAS">Original</a><b>]</b></p></body>
</html>
