<html>
<head><title> "COD Images" by KAI ROHRBACHER</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0061.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt; This doesn't have anything to do with the flicker problem, but I was
&gt; wondering if you could tell me how to scale and rotate .COD images.

Although  I  posted  some code to flip COD's horizontally &amp; vertically
some  time  ago,  I  won't make it a regular feature of AniVGA, as I'm
working on compiled bitmaps and thus, altering the &quot;data&quot; after having
it compiled into a procedure is close to impossible...
However,  if  you are speaking about scaling &amp; rotation in MAKES: yes,
one  could  include  it.  To be honest, I was just to lazy to code all
that matrix crap necessary.
For  the  interested  reader: to scale the points (x,y) of a matrix by
some factor f, you just have to apply the matrix
(f 0)
(0 f)
to all its points.
A  rotation  by  an  angle  of  z  degrees  counterclockwise about the
rotation  center (u,v) is more complex: one first has to transform the
point coordinates to homogeneous coordinates (that is: append a one as
the  3rd  component: (x,y) -&gt; (x,y,1); if during computations this 3rd
component  &quot;c&quot;  of  a vector (a,b,c) becomes &lt;&gt;1, then renormalize the
vector to (a/c,b/c,1)).
Having done so, the rotation consists of three steps:
a) make (u,v) the new origin of your pixels (instead of (0,0))
b) rotate the data by z degrees about the new origin (0,0)
c) retransform the true (0,0) origin

Step  a)  consists  of  applying the following matrix M1 to the pixels
(x,y,1):
( 1  0 0)
( 0  1 0)
(-u -v 1)

Likewise, step b) is done by the matrix M2:
( cos(z) sin(z) 0 )
(-sin(z) cos(z) 0 )
(   0      0    1 )

And step c) is done by M3:
( 1  0 0)
( 0  1 0)
(+u +v 1)

These  three  steps  can  be  squeezed  into one matrix application by
combining  the  three  matrices into one matrix M=M1*M2*M3 (with &quot;*&quot; =
matrix multiplication operator from linear algebra).


</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0061.PAS">Original</a><b>]</b></p></body>
</html>
