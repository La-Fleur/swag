<html>
<head><title> "Improved Graphics Rountines Part 1" by SCOTT TUNSTALL</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0221.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>(*
PART 1 OF NEWGRAPH.PAS
APPEND NEWGRPH2.PAS TO THE BOTTOM OF THIS FILE AND SAVE THE
COMBINED FILES AS NEWGRAPH.PAS - COMPILE NEWGRAPH.PAS AND
NOW SEE HOW MUCH FASTER AND MORE COMPLETE IT IS THAN ALL OF 
THE OTHER SWAG GRAPHIC &amp; SPRITE UNITS.


**************************************************************
NEWGRAPH! The (now slightly outdated) 320 x 200 x 256 VGA MODE
SUPPORT UNIT by Scott Tunstall (C) 1994, 1996. (Rev 1. created
in 1994, Final rev. Sept 1995)

Next project : This package converted to support VESA 16.7
               Million Colour graphic modes. (That'll be a
               task and a half)

After that   : Sleep for a year!!!

**************************************************************

READ THE DISCLAIMER FIRST BEFORE DOING ANYTHING!!!




Purpose of unit
---------------
The purpose of this unit is to provide an all-in-one package to
allow you to write FAST games in Turbo Pascal.

The unit incorporates :

         o Easy bitmap initialisation and manipulation routines

         o The fastest masked/unmasked/clipped sprite graphics
           routines you will EVER see for a 386/486 processor.

         o Easy to use palette routines (Not as many as I would
           have liked to have included but there are 100s of
           them available in the public domain - feel free to
           use em if ya like.)

         o Font load/save/display routines which are also the
           fastest you'll see (in 1994).

         o Versatile PCX load routines which can handle page sizes
           up to 320 x 200 (Handy for grabbing sprites.)


ALL time critical routines (i.e. Sprite drawing, Bitmap copying)
are written in 100% assembly language and have all been tested
extensively. (Yes Ronny I did write the assembler)

So in other words your machine shouldn't bomb when you use this unit!
(See Disclaimer)

Any drawbacks ?

Err.. unfortunately (due to the limitations of Pascal's 286
restrictions) you can't have a bitmap that exceeds 64K - yes
I know this sucks but huge pointers don't exist in Pascal!!

The speed in some areas isn't as fast as it could be.. shit!!
So, I am considering writing a version of this unit which does
not use standard Pascal &quot;stack frames&quot; (Where Procedure parameters are
moved to) but instead requires registers to be set on entry (about
100% faster).

But this will all be done once me B.Sc is over.


THE DISCLAIMER
--------------

Scott Tunstall (Me), the programmer of this pascal source and hence unit
cannot be held responsible if ANY damage, be it physical or otherwise, to
your system/peripherals etc. occurs from use/misuse of the code
and/or unit. (Not that this unit uses any system-unfriendly hack
tricks..)

You can distribute this unit UNALTERED and it would be nice if you
mentioned me in any software you create with this unit.

Feel free to add parts to the unit. If any good, please post em to the SWAG 
and let everyone see them. However, I would prefer to see ASM stuff be added
instead of plain vanilla pascal.


Name    : Scott Tunstall
Address : 40 leadside crescent, Fife, Scotland.


Minimum System requirements
---------------------------
Turbo Pascal 6 - (Mind and check some of the &quot;switches&quot; below ).
TP7 recommended though.

386 processor.
VGA graphics card that supports mode 13h and the 262,144
    colour palette.



CONTACT: CG93SAT@IBMRISC.DCT.AC.UK (Up till June 15 1996)
*)








{ You may have to remove some of these switches if using TP6.
  Turbo 7 really is the bees knees (?) when it comes to software
  development, laddie.
 }

{$A+,B-,E+,F-,G+,N+,Q-,R-,S-}

</i></font><font color="#FF0000"><b>UNIT </b></font>NEWGRAPH<font color="#000080">;

</font><font color="#FF0000"><b>INTERFACE

Const
      </b></font>GetMaxX                 <font color="#000080">= </font><font color="#800000">319</font><font color="#000080">;    </font><font color="#008000"><i>{ Maximum X &amp; Y coordinates }
      </i></font>GetMaxY                 <font color="#000080">= </font><font color="#800000">199</font><font color="#000080">;
      </font>GetMaxColour             <font color="#000080">= </font><font color="#800000">255</font><font color="#000080">;
      </font>MaxColours               <font color="#000080">= </font><font color="#800000">256</font><font color="#000080">;

      </font>Int1fFont               <font color="#000080">= </font><font color="#800000">0</font><font color="#000080">;
      </font>Int43Font               <font color="#000080">= </font><font color="#800000">1</font><font color="#000080">;
      </font>StandardVGAFont         <font color="#000080">= </font><font color="#800000">1</font><font color="#000080">;
      </font>Font8x8                 <font color="#000080">= </font><font color="#800000">1</font><font color="#000080">;      </font><font color="#008000"><i>{ Why do I get a &quot;Constant Out
                                        of range error&quot; with this ? }
      </i></font>Font8x14                <font color="#000080">= </font><font color="#800000">2</font><font color="#000080">;
      </font>Font8x8dd               <font color="#000080">= </font><font color="#800000">3</font><font color="#000080">;      </font><font color="#008000"><i>{ Abbreviated }
      </i></font>Font8x8ddHigh           <font color="#000080">= </font><font color="#800000">4</font><font color="#000080">;
      </font>AlphaAlternateFont      <font color="#000080">= </font><font color="#800000">5</font><font color="#000080">;
      </font>FontAlpha               <font color="#000080">= </font><font color="#800000">5</font><font color="#000080">;
      </font>Font8x16                <font color="#000080">= </font><font color="#800000">6</font><font color="#000080">;
      </font>Font9x16                <font color="#000080">= </font><font color="#800000">7</font><font color="#000080">;      </font><font color="#008000"><i>{ This doesn't appear, though }
      </i></font>FontRomAlt              <font color="#000080">= </font><font color="#800000">7</font><font color="#000080">;      </font><font color="#008000"><i>{ it may just be my VGA }


{
This record is used to hold a screen/PCX's palette.
}

</i></font><font color="#FF0000"><b>TYPE
</b></font>PaletteType <font color="#000080">= </font><font color="#FF0000"><b>record
   </b></font>RedLevel<font color="#000080">:   </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>MaxColours<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
   </font>GreenLevel<font color="#000080">: </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>MaxColours<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
   </font>BlueLevel<font color="#000080">:  </font><font color="#FF0000"><b>Array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font>MaxColours<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;




</font><font color="#008000"><i>{
This record is used to hold a Font's details, if you didn't guess
that already ;-)
}


</i></font>FontType <font color="#000080">= </font><font color="#FF0000"><b>record
   </b></font>FontSeg       <font color="#000080">: </font>Word<font color="#000080">;           </font><font color="#008000"><i>{ Where Font is located }
   </i></font>FontOfs       <font color="#000080">: </font>Word<font color="#000080">;
   </font>FontWidth     <font color="#000080">: </font>Byte<font color="#000080">;           </font><font color="#008000"><i>{ Width (In Pixels) }
   </i></font>FontByteWidth <font color="#000080">: </font>Byte<font color="#000080">;           </font><font color="#008000"><i>{ Pixel width divided by 8 }
   </i></font>FontHeight    <font color="#000080">: </font>Byte<font color="#000080">;           </font><font color="#008000"><i>{ Height (In Pixels) }
   </i></font>FontChars     <font color="#000080">: </font>Byte<font color="#000080">;           </font><font color="#008000"><i>{ Number of characters in Font }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;




</font><font color="#008000"><i>{ Jump into Mode 13h }

</i></font><font color="#FF0000"><b>Procedure </b></font>InitVGAMode<font color="#000080">;

</font><font color="#008000"><i>{
Bitmap initialisation and manipulation routines.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>Bitmap<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>FreeBitmap<font color="#000080">(</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>ShowBitmap<font color="#000080">(</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>GetSourceBitmapAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>SourceSeg<font color="#000080">,</font>SourceOfs<font color="#000080">: </font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetSourceBitmapAddr<font color="#000080">(</font>NewSourceSeg<font color="#000080">,</font>NewSourceOfs<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>GetDestinationBitmapAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>DestinationSeg<font color="#000080">,</font>DestinationOfs<font color="#000080">: </font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetDestinationBitmapAddr<font color="#000080">(</font>NewDestinationBitmapSeg<font color="#000080">,</font>NewDestinationBitmapOfs<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>CopySourceBitmap<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>OverlaySourceBitmap<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>DoubleBufferOff<font color="#000080">;


</font><font color="#008000"><i>{ Drawing primitives }

</i></font><font color="#FF0000"><b>Procedure </b></font>PutPixel<font color="#000080">(</font>x<font color="#000080">, </font>y <font color="#000080">: </font>integer<font color="#000080">; </font>ColourValue <font color="#000080">: </font>Byte<font color="#000080">);
</font><font color="#FF0000"><b>Function  </b></font>GetPixel<font color="#000080">(</font>X<font color="#000080">,</font>Y<font color="#000080">: </font>integer<font color="#000080">): </font>integer<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>Line<font color="#000080">(</font>X1<font color="#000080">, </font>Y1<font color="#000080">, </font>X2<font color="#000080">, </font>Y2<font color="#000080">:</font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>LineRel<font color="#000080">(</font>DiffX<font color="#000080">,</font>DiffY<font color="#000080">: </font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>LineTo<font color="#000080">(</font>Endx<font color="#000080">,</font>Endy<font color="#000080">:</font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>Rectangle<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>MoveTo<font color="#000080">(</font>NewCursX<font color="#000080">,</font>NewCursY<font color="#000080">:</font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Function  </b></font>GetX<font color="#000080">: </font>integer<font color="#000080">;
</font><font color="#FF0000"><b>Function  </b></font>GetY<font color="#000080">: </font>integer<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>OutTextXY<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font>txt<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>OutText<font color="#000080">(</font>txt<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">);


</font><font color="#008000"><i>{ Palette stuff }

</i></font><font color="#FF0000"><b>Procedure </b></font>SetColour<font color="#000080">(</font>NewColour<font color="#000080">:</font>byte<font color="#000080">);
</font><font color="#FF0000"><b>Function  </b></font>GetColour<font color="#000080">: </font>byte<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>GetPalette<font color="#000080">(</font>ColourNumber <font color="#000080">: </font>Byte<font color="#000080">; </font><font color="#FF0000"><b>VAR </b></font>RedValue<font color="#000080">, </font>GreenValue<font color="#000080">, </font>BlueValue <font color="#000080">: </font>Byte<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetPalette<font color="#000080">(</font>ColourNumber<font color="#000080">, </font>RedValue<font color="#000080">, </font>GreenValue<font color="#000080">, </font>BlueValue <font color="#000080">: </font>Byte<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>LoadPalette<font color="#000080">(</font>FileName<font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SavePalette<font color="#000080">(</font>FileName<font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>GetAllPalette<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetAllPalette<font color="#000080">(</font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);


</font><font color="#008000"><i>{
Fast sprite (shape) routines.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>GetAShape<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>word<font color="#000080">;</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>FreeShape<font color="#000080">(</font>DataPtr<font color="#000080">:</font>pointer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>Blit<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>word<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>ClipBlit<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>Block<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>word<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>ClipBlock<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">);
</font><font color="#FF0000"><b>Function  </b></font>BlitColl<font color="#000080">(</font>x<font color="#000080">,</font>y <font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>dataptr<font color="#000080">) : </font>boolean<font color="#000080">;
</font><font color="#FF0000"><b>Function  </b></font>ShapeSize<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>word<font color="#000080">):</font>word<font color="#000080">;
</font><font color="#FF0000"><b>Function  </b></font>ExtShapeSize<font color="#000080">(</font>ShapeWidth<font color="#000080">, </font>ShapeHeight <font color="#000080">: </font>byte<font color="#000080">): </font>word<font color="#000080">;
</font><font color="#FF0000"><b>Function  </b></font>ShapeWidth<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">): </font>byte<font color="#000080">;
</font><font color="#FF0000"><b>Function  </b></font>ShapeHeight<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">): </font>byte<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>LoadShape<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">:</font>Pointer<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SaveShape<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font>DataPtr<font color="#000080">:</font>Pointer<font color="#000080">);


</font><font color="#008000"><i>{
Custom Font routines. Unfortunately, I don't know how to load
in Windows bitmapped Fonts which is a real bast..

}

</i></font><font color="#FF0000"><b>Procedure </b></font>UseFont<font color="#000080">(</font>FontNumber<font color="#000080">:</font>byte<font color="#000080">);
</font><font color="#FF0000"><b>Function  </b></font>GetROMCharOffset<font color="#000080">(</font>CharNum<font color="#000080">:</font>byte<font color="#000080">): </font>word<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>GetCurrentFontAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>FontSeg<font color="#000080">,</font>FontOfs<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetCurrentFontAddr<font color="#000080">(</font>NewFontSeg<font color="#000080">,</font>NewFontOfs<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>GetCurrentFontSize<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>CurrFontWidth<font color="#000080">, </font>CurrFontHeight<font color="#000080">:</font>byte<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SetCurrentFontSize<font color="#000080">(</font>NewFontWidth<font color="#000080">, </font>NewFontHeight<font color="#000080">:</font>byte<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>LoadFont<font color="#000080">(</font>FontFileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>FontRec<font color="#000080">: </font>FontType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>UseLoadedFont<font color="#000080">(</font>FontRec <font color="#000080">: </font>FontType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SaveFont<font color="#000080">(</font>FontFileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font>FirstChar<font color="#000080">, </font>Numchars<font color="#000080">:</font>byte<font color="#000080">);


</font><font color="#008000"><i>{
Can't include a GIF loader.. Compuserve don't like people using
their GIF datatype without paying a small fee.. :(
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LoadPCX<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>LocatePCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">;
          </font>x<font color="#000080">,</font>y<font color="#000080">,</font>widthtoshow<font color="#000080">,</font>heighttoshow<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SavePCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">;</font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>SaveAreaAsPCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">;</font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">;
          </font>x<font color="#000080">,</font>y<font color="#000080">, </font>PCXWidth<font color="#000080">,</font>PCXHeight<font color="#000080">: </font>word<font color="#000080">);


</font><font color="#008000"><i>{
Miscellaneous useful routines.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>Vwait<font color="#000080">(</font>TimeOut<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Procedure </b></font>Cls<font color="#000080">;
</font><font color="#FF0000"><b>Procedure </b></font>CCls<font color="#000080">(</font>TheColour <font color="#000080">: </font>byte<font color="#000080">);




</font><font color="#FF0000"><b>IMPLEMENTATION


Uses </b></font>CRT<font color="#000080">,</font>Dos<font color="#000080">;


</font><font color="#008000"><i>{
This ** structure ** was nicked from READPCX.PAS that's currently
in the SWAG. Credit to Norman Yen for writing a PCX loader program,
it was very useful for understanding the PCX compression.

But my version of the PCX loader (rewritten from scratch) is faster
(and better) than Norm's effort. And what's more it can handle Mode 13h
PCX's of any size up to 320 x 200 pixels.

}

</i></font><font color="#FF0000"><b>type </b></font>Pcxheader_rec<font color="#000080">=</font><font color="#FF0000"><b>record               </b></font><font color="#008000"><i>{ EXPECTED VALUES / COMMENTS}
                                        { --------------------------}
     </i></font>manufacturer<font color="#000080">: </font>byte<font color="#000080">;                </font><font color="#008000"><i>{ 10. (Why does Z-Soft have
                                          this field ?) }
     </i></font>version<font color="#000080">: </font>byte<font color="#000080">;                     </font><font color="#008000"><i>{ 5. }
     </i></font>encoding<font color="#000080">: </font>byte<font color="#000080">;                    </font><font color="#008000"><i>{ 0.  (RLE PCX encryption) }
     </i></font>bits_per_pixel<font color="#000080">: </font>byte<font color="#000080">;              </font><font color="#008000"><i>{ 8.  (8 bits = 256 colours) }
     </i></font>xmin<font color="#000080">, </font>ymin<font color="#000080">: </font>word<font color="#000080">;                  </font><font color="#008000"><i>{ 0,0 (Top Left) }
     </i></font>xmax<font color="#000080">, </font>ymax<font color="#000080">: </font>word<font color="#000080">;                  </font><font color="#008000"><i>{ 319,199 (Bottom right) }
     </i></font>hres<font color="#000080">: </font>word<font color="#000080">;                        </font><font color="#008000"><i>{ 320 (although this (and vres)
                                          may be ignored by some
                                          programs)}
     </i></font>vres<font color="#000080">: </font>word<font color="#000080">;                        </font><font color="#008000"><i>{ 200 }
     </i></font>palette<font color="#000080">: </font><font color="#FF0000"><b>array </b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">47</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>byte<font color="#000080">;    </font><font color="#008000"><i>{ Don't use }
     </i></font>reserved<font color="#000080">: </font>byte<font color="#000080">;                    </font><font color="#008000"><i>{ Don't use }
     </i></font>colour_planes<font color="#000080">: </font>byte<font color="#000080">;               </font><font color="#008000"><i>{ 0 (Mode 13h is not planar) }
     </i></font>bytes_per_line<font color="#000080">: </font>word<font color="#000080">;              </font><font color="#008000"><i>{ 320 (usually, may differ -
                                          although I hear this should
                                          be an even number my PCX load
                                          /save routines work with odd
                                          numbers too) }
     </i></font>palette_type<font color="#000080">: </font>word<font color="#000080">;                </font><font color="#008000"><i>{ 12 (to work with this unit) }
     </i></font>filler<font color="#000080">: </font><font color="#FF0000"><b>string</b></font><font color="#000080">[</font><font color="#800000">58</font><font color="#000080">];                </font><font color="#008000"><i>{ Don't know the purpose of this,
                                          could it be for comments etc ? }
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;



</font><font color="#008000"><i>{
****************
Variable section
****************

Note : You could make these public variables and that would probably
increase the speed of your programs as you can access the data
directly (via assembler, for example) instead of using the
Setxxx() Procedures.
}

</i></font><font color="#FF0000"><b>Var
    </b></font>SourceBitmapSegment<font color="#000080">:          </font>word<font color="#000080">;
    </font>SourceBitmapOffset<font color="#000080">:           </font>word<font color="#000080">;
    </font>DestinationBitmapSegment<font color="#000080">:     </font>word<font color="#000080">;
    </font>DestinationBitmapOffset<font color="#000080">:      </font>word<font color="#000080">;

    </font>CurrentFontSegment<font color="#000080">:         </font>word<font color="#000080">;
    </font>CurrentFontOffset<font color="#000080">:          </font>word<font color="#000080">;
    </font>CurrentFontWidth<font color="#000080">:           </font>byte<font color="#000080">;
    </font>CurrentFontByteWidth<font color="#000080">:       </font>byte<font color="#000080">;
    </font>CurrentFontHeight<font color="#000080">:          </font>byte<font color="#000080">;
    </font>CurrentColour<font color="#000080">:               </font>byte<font color="#000080">;
    </font>CursorX<font color="#000080">:                    </font>integer<font color="#000080">;
    </font>CursorY<font color="#000080">:                    </font>integer<font color="#000080">;

    </font>header<font color="#000080">:                     </font>Pcxheader_rec<font color="#000080">;




</font><font color="#008000"><i>(*
This routine has nothing to do with graphics - it just helps
with some routines.

Expects : PT is a standard pointer.
          Segm and Offs are uninitialised word variables.

Returns : On exit Segm holds the segment part of the pointer
          Offs holds the offset.

Corrupts : AX,BX,DI,ES.

*)

</i></font><font color="#FF0000"><b>Procedure </b></font>GetPtrData<font color="#000080">(</font>pt<font color="#000080">:</font>pointer<font color="#000080">; </font><font color="#FF0000"><b>VAR </b></font>Segm<font color="#000080">, </font>Offs<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">LES DI,PT            </font><font color="#008000"><i>{ Point ES:DI to where PT is in memory }
   </i></font><font color="#FF00FF">MOV AX,ES            </font><font color="#008000"><i>{ Set AX to hold segment }
   </i></font><font color="#FF00FF">MOV BX,DI            </font><font color="#008000"><i>{ BX to hold offset }

   </i></font><font color="#FF00FF">LES DI,Segm          </font><font color="#008000"><i>{ Now write directly to variable Segm }
   </i></font><font color="#FF00FF">MOV [ES:DI],AX
   LES DI,Offs          </font><font color="#008000"><i>{ And variable Offs }
   </i></font><font color="#FF00FF">MOV [ES:DI],BX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;




</font><font color="#008000"><i>{
Switch into VGA256 (320 x 200 x 256 Colour mode).

Expects : Nothing

Returns : Nothing

Affects : It affects the current screen mode (obviously) palette,
          Font (and the weather in eastern Czechoslovakia :-) )

Notes  : If all you want to do is clear the screen then use
         Cls or CCls, which does not affect palettes etc.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>InitVGAMode<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
   </b></font><font color="#FF00FF">XOR AH,AH
   MOV AL,$13   </font><font color="#008000"><i>{ Mode 19 is the mode we want ! ;-) }
   </i></font><font color="#FF00FF">INT $10      </font><font color="#008000"><i>{ VGA 256 Colours here we come }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
****************************
BITMAP MANIPULATION ROUTINES
****************************
}



(*
Allocate memory for a virtual screen. (This command
it is ALWAYS 64,000 bytes that are allocated - the same
size as what is used by the VGA bitmap.

Expects  : Two empty variables of word size which will be
           used to hold the segment and offset of the virtual
           screen.

Returns  : The segment and offset of the memory area.

Corrupts : Don't know (and don't care! ).

Notes    : Unfortunately Pascal doesnt allow allocation of
           &gt; 64K or incorportate HUGE pointers so therefore
           it was made impossible for me to have a huge bitmap
           that exceeds 64K.

*)


</i></font><font color="#FF0000"><b>Procedure </b></font>Bitmap<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>MemoryAccessVar<font color="#000080">: </font>pointer<font color="#000080">;
</font><font color="#FF0000"><b>Begin
     </b></font>GetMem<font color="#000080">(</font>MemoryAccessVar<font color="#000080">,</font><font color="#800000">64000</font><font color="#000080">);
     </font>GetPtrData<font color="#000080">(</font>MemoryAccessVar<font color="#000080">,</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>(*
This routine will free a virtual screen allocated by the
Bitmap routine above.

Expects :  The variables passed in as BmapSegment, BmapOffset should hold
           the same contents as what was allocated by Bitmap;

Returns :  Your machine may crash if you try and free a Bitmap that has
           not been allocated !

Corrupts : Don't know which registers are altered.

*)


</i></font><font color="#FF0000"><b>Procedure </b></font>FreeBitmap<font color="#000080">(</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>ThePointer<font color="#000080">: </font>pointer<font color="#000080">;
</font><font color="#FF0000"><b>Begin
     </b></font>ThePointer<font color="#000080">:=</font>Ptr<font color="#000080">(</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">);
     </font>FreeMem<font color="#000080">(</font>ThePointer<font color="#000080">,</font><font color="#800000">64000</font><font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;




</font><font color="#008000"><i>{
Procedure used to blit one bitmap to another bitmap. Private
to unit.

Expects : DS:SI points to source page
          ES:DI points to destination page
          DX holds data segment address

Corrupts : CX,SI,DI.

Returns : Nothing

}



</i></font><font color="#FF0000"><b>Procedure </b></font>FastCopy<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV CX,2000
     CLD

     </font><font color="#008000"><i>{ The reason I have repeated the instructions 8 times is because
     this method is a lot faster than :

@Copy:
     DB $F3,$66,$a5
     LOOP @Copy


     If you are a total speed junkie then why not block copy those
     8 instructions, append them at the bottom, and set CX (Above)
     to 1000. In fact, for total speed freaks why not type 16,000
     of these instructions :-)

     Alternatively, buy a Pentium 120. ;-)

     (Feb 96 update: No point in me cracking that joke now when
     Melv's got a P133 - how fast technology advances eh?)
     }

</i></font><font color="#FF00FF">@Copy:
     DB $66; MOVSW      </font><font color="#008000"><i>{ MOVSD }
     </i></font><font color="#FF00FF">DB $66; MOVSW
     DB $66; MOVSW
     DB $66; MOVSW
     DB $66; MOVSW
     DB $66; MOVSW
     DB $66; MOVSW
     DB $66; MOVSW      </font><font color="#008000"><i>{ 32 bytes moved in one loop. Whoa !}
     </i></font><font color="#FF00FF">DEC CX
     JNZ @Copy          </font><font color="#008000"><i>{ On my 486 this is faster than LOOP }

     </i></font><font color="#FF00FF">MOV DS,DX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Copy a bitmap in memory to the VGA memory, therefore showing it
on screen.

Expects  : BmapSegment, BmapOffset to point to a bitmap in memory.

Returns  : Nothing


Corrupts : AX,CX,DX,SI,DI,ES
}


</i></font><font color="#FF0000"><b>Procedure </b></font>ShowBitmap<font color="#000080">(</font>BmapSegment<font color="#000080">,</font>BmapOffset<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV DX,DS
   MOV AX,$a000
   MOV ES,AX
   XOR DI,DI
   MOV SI,BmapOffset
   MOV DS,BmapSegment
   CALL FastCopy
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>(*
This copies the Source Bitmap to the Destination Bitmap. Simple as that.
If the Destination Bitmap resides at $a000 : 0 then the VGA screen will
be updated (The main purpose for this routine)

Expects : Source Bitmap &amp; Destination Bitmap to point to two legal 64K
          regions of memory (By &quot;legal&quot; I mean you have reserved these
          regions in the program for your own use, or know that they
          are free)

Returns : Nothing.

Corrupts : CX,DX,DI,ES
*)


</i></font><font color="#FF0000"><b>Procedure </b></font>CopySourceBitmap<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV DX,DS
     MOV ES,DestinationBitmapSegment
     MOV DI,DestinationBitmapOffset
     MOV SI,SourceBitmapOffset
     MOV DS,SourceBitmapSegment
     CALL FastCopy
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Get the segment and offset of the source Bitmap. (Where data
is written to, i.e. Sprites, Lines, etc)

Expects : SourceSeg and SourceOfs are two uninitialised word variables

Returns : On exit from this routine SourceSeg shall hold the segment and
          SourceOfs shall hold the offset.

Corrupts : AX,BX,ES

Notes :    The value on unit initialisation is: Segment = $a000
                                                Offset  = 0.

You can change the Source Bitmap address by using SetSourceBitmapAddr.

}


</i></font><font color="#FF0000"><b>Procedure </b></font>GetSourceBitmapAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>SourceSeg<font color="#000080">,</font>SourceOfs<font color="#000080">: </font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,SourceBitmapSegment
   MOV BX,SourceBitmapOffset
   LES DI,SourceSeg
   MOV [ES:DI],AX
   LES DI,SourceOfs
   MOV [ES:DI],AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Set the Source Bitmap address. The source Bitmap is where ALL of the
graphics operations are performed, except for copying.


Expects : NewSourceSeg = Segment of the new Source Bitmap
          NewSourceOfs = Offset of the new Source Bitmap

Returns : Nothing

Notes   : The source Bitmap must reside within the first 640K of DOS memory,
          or at segment $a000 (Video Ram).

          I am sorry about this limitation but that's MS-DOS for you.
          And before a lot of mail floods in saying &quot;what about using XMS&quot;
          etc. I say, &quot;It's in my new unit, old chap&quot; :-)


Corrupts : AX
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SetSourceBitmapAddr<font color="#000080">(</font>NewSourceSeg<font color="#000080">,</font>NewSourceOfs<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX,NewSourceSeg
     MOV SourceBitmapSegment,AX
     MOV AX,NewSourceOfs
     MOV SourceBitmapOffset,AX

</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Get the address of the Destination Bitmap. (Where data is to be copied
to with CopySourceBitmap).

Expects : Two word variables to hold the segment &amp; offset of the
          source Bitmap.

Returns : Segment &amp; Offset of the source Bitmap.

Corrupts : AX,DI,ES.


Note : The Destination Bitmap defaults to segment $a000 offset 0.


}

</i></font><font color="#FF0000"><b>Procedure </b></font>GetDestinationBitmapAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>DestinationSeg<font color="#000080">,</font>DestinationOfs<font color="#000080">: </font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,DestinationBitmapSegment
   LES DI,DestinationSeg
   MOV [ES:DI],AX
   MOV AX,DestinationBitmapOffset
   LES DI,DestinationOfs
   MOV [ES:DI],AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;










</font><font color="#008000"><i>{
Set the address of the Destination Bitmap.


Expects :  NewDestinationBitmapSeg is the segment of the New
           Destination Bitmap. (Never! :-) )
           NewDestinationBitmapOfs is the offset.

Returns :  Nothing

Corrupts : AX

}

</i></font><font color="#FF0000"><b>Procedure </b></font>SetDestinationBitmapAddr<font color="#000080">(</font>NewDestinationBitmapSeg<font color="#000080">,</font>NewDestinationBitmapOfs<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,NewDestinationBitmapSeg
   MOV DestinationBitmapSegment,AX
   MOV AX,NewDestinationBitmapOfs
   MOV DestinationBitmapOffset,AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
By setting the Destination Bitmap to the Source Bitmap, &quot;double buffering&quot;
is effectively turned OFF. This routine is only of use to those who
work with multiple graphics Bitmaps.

This will make sure that data is written to the Destination
Bitmap ALWAYS.

Expects : Nothing.

Returns : DestinationBitmap points to SourceBitmap.

Corrupts : AX
}


</i></font><font color="#FF0000"><b>Procedure </b></font>DoubleBufferOff<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,SourceBitmapSegment
   MOV DestinationBitmapSegment,AX
   MOV AX,SourceBitmapOffset
   MOV DestinationBitmapOffset,AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
This routine will overlay the SOURCE Bitmap with the DESTINATION
Bitmap (writing the overlaid Bitmap data to the DESTINATION screen)
therefore making it possible to create a parallaxing
effect.

Of course, you could simply use it to overlay two PCXs etc. etc.


Expects : SourceBitmapSegment, SourceBitmapOffset to point to an
          initialised Bitmap. This Bitmap is treated as the
          FOREGROUND. All pixels with colour 0 within the
          bitmap are treated as TRANSPARENT.

          The same applies to DestBitmapSegment, DestBitmapOffset.
          The Dest Bitmap is treated as the BACKGROUND.

Returns : Nothing

Corrupts : AX,CX,DX,SI,DI,ES

}

</i></font><font color="#FF0000"><b>Procedure </b></font>OverlaySourceBitmap<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV DX,DS                    </font><font color="#008000"><i>{ Save DS - faster than using stack }

   </i></font><font color="#FF00FF">MOV DI,DestinationBitmapOffset
   MOV ES,DestinationBitmapSegment
   MOV SI,SourceBitmapOffset
   MOV DS,SourceBitmapSegment
   MOV CX,16000

@CheckIfTransparent:
   DB $66                       </font><font color="#008000"><i>{ 66h indicates 32 bit destination }
   </i></font><font color="#FF00FF">LODSW                        </font><font color="#008000"><i>{ LODSD -&gt; Read DWORD from source Bitmap
                                into AX }
   </i></font><font color="#FF00FF">OR AL,AL                     </font><font color="#008000"><i>{ Check if AL is 0 }
   </i></font><font color="#FF00FF">JZ @ALClear                  </font><font color="#008000"><i>{ If so, can't overlay it }
   </i></font><font color="#FF00FF">MOV [ES:DI],AL               </font><font color="#008000"><i>{ Otherwise, write it }

</i></font><font color="#FF00FF">@ALClear:
   INC DI
   OR AH,AH                     </font><font color="#008000"><i>{ Check if AH is 0 }
   </i></font><font color="#FF00FF">JZ @AHClear                  </font><font color="#008000"><i>{ Shouldn't blit with a 0 byte }
   </i></font><font color="#FF00FF">MOV [ES:DI],AH

@AHClear:
   INC DI
   DB $66
   SHR AX,16                    </font><font color="#008000"><i>{ Move upper word of EAX into
                                  into AH and AL }
   </i></font><font color="#FF00FF">OR AL,AL                     </font><font color="#008000"><i>{ Check if AL is 0 }
   </i></font><font color="#FF00FF">JZ @EALClear                 </font><font color="#008000"><i>{ If so, can't overlay it }
   </i></font><font color="#FF00FF">MOV [ES:DI],AL               </font><font color="#008000"><i>{ Otherwise, write it }

</i></font><font color="#FF00FF">@EALClear:
   INC DI
   OR AH,AH                     </font><font color="#008000"><i>{ Check if AH is 0 }
   </i></font><font color="#FF00FF">JZ @NoBlit                   </font><font color="#008000"><i>{ Shouldn't blit with a 0 byte }
   </i></font><font color="#FF00FF">MOV [ES:DI],AH


@NoBlit:
   INC DI                       </font><font color="#008000"><i>{ Next byte }
   </i></font><font color="#FF00FF">DEC CX                       </font><font color="#008000"><i>{ Reduce count }
   </i></font><font color="#FF00FF">JNZ @CheckIfTransparent

   MOV DS,DX                    </font><font color="#008000"><i>{ Restore DS }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
***********************
PRIMITIVE DRAWING TOOLS
***********************
}


{
Calculate the offset of a pixel on the SOURCE Bitmap.

Registers expected on entry:
AX = the horizontal coordinate (0 to GetMaxX) and ..
BX = the vertical coordinate (0 to GetMaxY)


Returns  : BX = -1 if X or Y were out of bounds.
           Otherwise, BX is an offset, which, combined with
           the contents of SourceBitmapSegment point to an address
           in RAM where the pixel can be plotted/read from.

Notes    : This routine is private to the unit. To maintain
           compatibility with further revisions (which I churn out
           with frightening regularity ;-) ) I recommend all extra
           unit routines that require a pixel address calc'ed call
           this proc.

Corrupts : AX, BX, CX are corrupted.

}


</i></font><font color="#FF0000"><b>Procedure </b></font>CalculateOffset<font color="#000080">; </font><font color="#FF0000"><b>Near</b></font><font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">CMP AX,319         </font><font color="#008000"><i>{ Is X&gt; 319 ? }
     </i></font><font color="#FF00FF">JA @OutOfBounds    </font><font color="#008000"><i>{ Yes }
     </i></font><font color="#FF00FF">CMP BX,199         </font><font color="#008000"><i>{ Is Y&gt; 199 ?. Do not use BL instead as this is
                          when problems will occur.}
     </i></font><font color="#FF00FF">JA @OutOfBounds    </font><font color="#008000"><i>{ Yes }

     </i></font><font color="#FF00FF">XOR CH,CH                  </font><font color="#008000"><i>{ CX = Y }
     </i></font><font color="#FF00FF">MOV CL,BL
     SHL CX,6                   </font><font color="#008000"><i>{ Y * 64 }
     </i></font><font color="#FF00FF">MOV BH,BL                  </font><font color="#008000"><i>{ BX = Y * 256 }
     </i></font><font color="#FF00FF">XOR BL,BL
     ADD BX,CX                  </font><font color="#008000"><i>{ BX = BX + CX, which gives Y * 320 }
     </i></font><font color="#FF00FF">ADD BX,AX                  </font><font color="#008000"><i>{ Add the X position to offset in BX }
     </i></font><font color="#FF00FF">ADD BX,SourceBitmapOffset    </font><font color="#008000"><i>{ Take into account the offset in memory
                                  of the source Bitmap }

     </i></font><font color="#FF00FF">JMP @Finito                </font><font color="#008000"><i>{ And exit. }

</i></font><font color="#FF00FF">@OutOfBounds:
     MOV BX,-1                  </font><font color="#008000"><i>{ Signal that coordinates were not within
                                  the screen limits }

</i></font><font color="#FF00FF">@Finito:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
This GetPixel routine differs from the Turbo equivalent as the
return type is integer, not word. A small point, but still
(UN)worth mentioning. &lt;grin&gt;

Expects  : X and Y specify the horizontal and vertical coordinates of
           a pixel. X may be 0..GetMaxX, Y may be 0..GetMaxY.

Returns  : If the coordinates are within screen bounds, then GetPixel =
           Colour at X,Y. If not, then GetPixel = -1.

Corrupts : AX/BX/CX/DX/FS.
}

</i></font><font color="#FF0000"><b>Function </b></font>GetPixel<font color="#000080">(</font>X<font color="#000080">,</font>Y<font color="#000080">: </font>integer<font color="#000080">): </font>integer<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,X
   MOV BX,Y

   CALL CalculateOffset         </font><font color="#008000"><i>{ Now get offset in BX }
   </i></font><font color="#FF00FF">CMP BX,-1                    </font><font color="#008000"><i>{ Is coordinate off screen ? }
   </i></font><font color="#FF00FF">JZ @NoGet                    </font><font color="#008000"><i>{ Yes, so return value of -1 }
   </i></font><font color="#FF00FF">DB $8E, $26
   DW OFFSET SourceBitmapSegment

   XOR AH,AH
   DB $64
   MOV AL,[BX]

   JMP @Finished                </font><font color="#008000"><i>{ Can't put a RET here - maybe this
                                  unit was compiled in FAR mode, and
                                  a crash would occur! }

</i></font><font color="#FF00FF">@NoGet:
   MOV AX,BX                    </font><font color="#008000"><i>{ AX = -1, meaning no pixel could be
                                  read }

</i></font><font color="#FF00FF">@Finished:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Write a pixel to the screen.

Expects :  AX to be the X coord for a pixel (0 to GetMaxX),
           BX for the Y coord (0 to GetMaxY) - Don't be tempted
           to optimize the code by using BL, as this causes
           problems when using negative Y coordinates. (As some
           programs will)
           DL is the colour (0 to 255) to plot.

Returns :  Nothing

Notes   :  This putpixel is private to the unit and should be
           used when plotting pixels that MAY be off screen
           to keep in step with the rest of the unit.

On exit AX,BX,CX,DX,FS are corrupt.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>FPutPixel<font color="#000080">; </font><font color="#FF0000"><b>Near</b></font><font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">CALL CalculateOffset                 </font><font color="#008000"><i>{ AX/ BX already set up }
   </i></font><font color="#FF00FF">CMP BX,-1                            </font><font color="#008000"><i>{ Coordinates off screen ? }
   </i></font><font color="#FF00FF">JA @NoPlot                           </font><font color="#008000"><i>{ Yeah, so don't put pixel }
   </i></font><font color="#FF00FF">DB $8E,$26                           </font><font color="#008000"><i>{ MOV FS, [SourceBitmapSegment] }
   </i></font><font color="#FF00FF">DW OFFSET SourceBitmapSegment
   DB $64                               </font><font color="#008000"><i>{ MOV [FS:BX],DL }
   </i></font><font color="#FF00FF">MOV [BX],DL

@NoPlot:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
This is the Pascal interface for the Fputpixel routine, it's
really quite sad how Pascal uses the stack so much, when you see
the likes of Turbo C &amp; it's (amazingly interesting) register
usage which is quite fast. :(

But not as fast as me when I'm going to the pub. :-)

Expects : X = Horizontal coordinate of a pixel (0-GetMaxX)
          Y = Vertical coordinate of a pixel (0-GetMaxY)
          ColourValue = Colour to plot , 0 - 255.

Returns : Nothing

Corrupts : See FPutPixel.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>PutPixel<font color="#000080">(</font>x<font color="#000080">, </font>y <font color="#000080">: </font>integer<font color="#000080">; </font>ColourValue <font color="#000080">: </font>Byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,x               </font><font color="#008000"><i>{ I wish TP had the capacity to load these
                            automatically for you, instead of creating
                            a crappy stack frame and pushing X, Y. }
   </i></font><font color="#FF00FF">MOV BX,y               </font><font color="#008000"><i>{ Is it any wonder I love C++ more ? }
   </i></font><font color="#FF00FF">MOV DL,ColourValue
   CALL FPutPixel         </font><font color="#008000"><i>{ Don't use a JMP, your program will crash }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
This line routine was converted to assembler (by ME!!) from the
SWAG team's line draw routine (in Pascal) which was very fast.
So this means this'll be ULTRA FAST (hopefully ;-) ).

Bresenham who ? :-)  Diamond Geezer.

I wonder if this is faster than Sean Palmer's line draw in ASM ?
(Check the SWAG for that program - it's smart)

Expects : X1,Y1 defines the horizontal, vertical start of the line
          X2,Y2 defines the horizontal, vertical end of the line.
          Coordinates may be negative or exceed screen bounds.

          Line will be drawn in CurrentColour.

Returns : Nothing

Corrupts: AX,BX,CX,DX,SI,DI,ES,FS.

}


</i></font><font color="#FF0000"><b>Procedure </b></font>Line<font color="#000080">(</font>X1<font color="#000080">, </font>Y1<font color="#000080">, </font>X2<font color="#000080">, </font>Y2<font color="#000080">: </font>Integer<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Var
  </b></font>LgDelta<font color="#000080">,
  </font>ShDelta<font color="#000080">,
  </font>LgStep<font color="#000080">,
  </font>ShStep<font color="#000080">,
  </font>Cycle <font color="#000080">: </font>word<font color="#000080">;

</font><font color="#FF0000"><b>Asm
  </b></font><font color="#FF00FF">MOV BX,X2             </font><font color="#008000"><i>{ LgDelta = X2 - X1 }
  </i></font><font color="#FF00FF">MOV SI,X1
  SUB BX,SI
  MOV LgDelta,BX

  MOV CX,Y2             </font><font color="#008000"><i>{ ShDelta = Y2 - Y1 }
  </i></font><font color="#FF00FF">MOV DI,Y1
  SUB CX,DI
  MOV ShDelta,CX

  TEST BH,$80           </font><font color="#008000"><i>{ If bit 7 not set .. }
  </i></font><font color="#FF00FF">JZ @LgDeltaPos        </font><font color="#008000"><i>{ Goto LgDeltaPos }

  </i></font><font color="#FF00FF">NEG BX
  MOV LgDelta,BX
  MOV LgStep,$FFFF
  JMP @Cont1

@LgDeltaPos:
  MOV LgStep,1

@Cont1:
  CMP CH,$80           </font><font color="#008000"><i>{ If ShDelta &lt; 0 Then.. }
  </i></font><font color="#FF00FF">JB @ShDeltaPos
  NEG CX
  MOV ShDelta,CX
  MOV ShStep,$FFFF
  JMP @Cont2

@ShDeltaPos:
  MOV ShStep,1

@Cont2:
  CMP BX,CX                   </font><font color="#008000"><i>{ BX = LgDelta, CX = ShDelta }
  </i></font><font color="#FF00FF">JB @OtherWay

  SHR BX,1                    </font><font color="#008000"><i>{ Cycle:= LgDelta SHR 1 }
  </i></font><font color="#FF00FF">MOV Cycle,BX

  </font><font color="#008000"><i>{
  O.K. I'm going to use :
  SI as X1, DI as Y1, CX as X2, DX as Y2.
  }

  </i></font><font color="#FF00FF">MOV CX,X2

@FirstLoop:
  CMP SI,CX             </font><font color="#008000"><i>{ While X1 &lt;&gt; X2 }
  </i></font><font color="#FF00FF">JZ @GetTheShitOut     </font><font color="#008000"><i>{ Why not have an expletive as a label ? }

  </i></font><font color="#FF00FF">MOV AX,SI              </font><font color="#008000"><i>{ Set AX and BX to X1,Y1 ready for call }
  </i></font><font color="#FF00FF">MOV BX,DI              </font><font color="#008000"><i>{ BX = Y1 }

  </i></font><font color="#FF00FF">MOV ES,CX              </font><font color="#008000"><i>{ The only free register ! }
  </i></font><font color="#FF00FF">MOV DL,CurrentColour
  CALL FPutPixel
  MOV CX,ES

  ADD SI, LgStep         </font><font color="#008000"><i>{ X1 = X1 + LgStep }
  </i></font><font color="#FF00FF">MOV AX,Cycle
  ADD AX,ShDelta         </font><font color="#008000"><i>{ Inc(Cycle,ShDelta) }
  </i></font><font color="#FF00FF">MOV Cycle,AX           </font><font color="#008000"><i>{ Yes I did check the code and this is fastest }

  </i></font><font color="#FF00FF">MOV BX,LgDelta
  CMP AX,BX              </font><font color="#008000"><i>{ If Cycle &gt; LgDelta }
  </i></font><font color="#FF00FF">JB @FirstLoop

  ADD DI,ShStep          </font><font color="#008000"><i>{ Y1 = Y1 + ShStep }
  </i></font><font color="#FF00FF">SUB AX,LgDelta         </font><font color="#008000"><i>{ Dec(Cycle,LgDelta) }
  </i></font><font color="#FF00FF">MOV Cycle,AX
  JMP @FirstLoop

  </font><font color="#008000"><i>{
  O.K. If we go in a different direction..

  On entry, BX = LgDelta, CX = ShDelta

  }

</i></font><font color="#FF00FF">@OtherWay:
  MOV AX,CX
  SHR AX,1              </font><font color="#008000"><i>{ ShDelta SHR 1 }
  </i></font><font color="#FF00FF">MOV Cycle,AX
  XCHG BX,CX            </font><font color="#008000"><i>{ BX = ShDelta, CX = LgDelta }
  </i></font><font color="#FF00FF">MOV LgDelta, BX
  MOV ShDelta, CX

  MOV BX,LgStep         </font><font color="#008000"><i>{ Swap LgStep and ShStep round }
  </i></font><font color="#FF00FF">MOV CX,ShStep
  MOV ShStep,BX
  MOV LgStep,CX

  </font><font color="#008000"><i>{MOV CX,X2}             { CX = X2, DX = Y2 }
  </i></font><font color="#FF00FF">MOV DX,Y2

@SecondLoop:
  CMP DI,DX             </font><font color="#008000"><i>{ While Y1 &lt;&gt; Y2 do }
  </i></font><font color="#FF00FF">JZ @GetTheShitOut


</font><font color="#008000"><i>{
If it can, then it's time for action!
}

  </i></font><font color="#FF00FF">MOV AX,SI             </font><font color="#008000"><i>{ Set AX and BX to X1,Y1 }
  </i></font><font color="#FF00FF">MOV BX,DI             </font><font color="#008000"><i>{ BX = Y1 }

  </i></font><font color="#FF00FF">MOV ES,DX             </font><font color="#008000"><i>{ Sorry, but this was the only free register ! }
  </i></font><font color="#FF00FF">MOV DL,CurrentColour
  CALL FPutPixel
  MOV DX,ES             </font><font color="#008000"><i>{ .. Please don't think I am sloppy ! }

  </i></font><font color="#FF00FF">ADD DI,LgStep         </font><font color="#008000"><i>{ Inc(Y1,LgStep) }
  </i></font><font color="#FF00FF">MOV AX,Cycle          </font><font color="#008000"><i>{ Inc(Cycle,ShDelta) }
  </i></font><font color="#FF00FF">ADD AX,ShDelta
  MOV Cycle,AX

  MOV BX,LgDelta

  CMP AX,BX             </font><font color="#008000"><i>{ If Cycle &gt; LgDelta Then.. }
  </i></font><font color="#FF00FF">JB @SecondLoop

  ADD SI,ShStep         </font><font color="#008000"><i>{ Inc(X1,ShStep) }
  </i></font><font color="#FF00FF">SUB Cycle,BX          </font><font color="#008000"><i>{ Dec(Cycle,LgDelta) }
  </i></font><font color="#FF00FF">JMP @SecondLoop

@GetTheShitOut:
  MOV AX,X2             </font><font color="#008000"><i>{ Write last pixel. This was an absolute }
  </i></font><font color="#FF00FF">MOV BX,Y2             </font><font color="#008000"><i>{ b****** to debug :-) }
  </i></font><font color="#FF00FF">MOV DL,CurrentColour
  CALL FPutPixel        </font><font color="#008000"><i>{ Just a wee bit of Scottish humour there }

</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
Draw a line relative from the current cursor position.
Relative means that the DiffX and DiffY values are added to the
current cursor coordinates to give the resulting horizontal and vertical
end points of the line.

For example, if CursorX and CursorY were 10,10 and DiffX and DiffY
were -10,-10 then the line would be drawn to position 0,0. Conversely,
if DiffX was 10 and DiffY was 20 then the cursor would be drawn to
X 20, Y 30.


Expects : DiffX is a non zero value that may be negative, which
          specifies the relative distance from the current horizontal
          cursor position.

          DiffY specifies the relative distance from the current
          vertical position.

Returns : Nothing

Corrupts : Probably the same as the Line routine.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LineRel<font color="#000080">(</font>DiffX<font color="#000080">,</font>DiffY<font color="#000080">: </font>integer<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX,CursorX
     MOV BX,AX
     ADD BX,DiffX
     MOV CX,CursorY
     MOV DX,CX
     ADD DX,DiffY

     </font><font color="#008000"><i>{
     Strange method of reading the stack, Borland. :-(
     }

     </i></font><font color="#FF00FF">PUSH BX            </font><font color="#008000"><i>{ X + DiffX }
     </i></font><font color="#FF00FF">PUSH DX            </font><font color="#008000"><i>{ Y + DiffY }
     </i></font><font color="#FF00FF">PUSH AX            </font><font color="#008000"><i>{ X }
     </i></font><font color="#FF00FF">PUSH CX            </font><font color="#008000"><i>{ Y }
     </i></font><font color="#FF00FF">CALL Line          </font><font color="#008000"><i>{ Must return so dynamic vars can be moved.
                          Wish I could get rid of them quicker. }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Draw from the current cursor position to the horizontal and vertical
positions specified by EndX and EndY. The Graphics Cursor will be
moved to EndX, EndY.

Expects : EndX to be the horizontal position of the line end. (0 to GetMaxX)
          EndY to be the vertical position of the line end. (0 to GetMaxY)

Returns : Nothing, but you should be aware that the graphics cursor
          position is now at EndX, EndY.

Corrupts : AX,BX,CX,DX,SI,DI,ES,FS
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LineTo<font color="#000080">(</font>EndX<font color="#000080">,</font>EndY<font color="#000080">:</font>integer<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">PUSH EndX
   PUSH EndY
   PUSH CursorX
   PUSH CursorY
   CALL Line
   MOV AX,EndX
   MOV CursorX,AX
   MOV AX,EndY
   MOV CursorY,AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Probably not the fastest rectangle draw you'll see.
But it is economical with memory, and it works !

Expects  : X1,Y1,X2,Y2 define a rectangular window.

Returns  : Nothing

Corrupts : Not a clue.

Notes    : This routine does not move the graphics cursor.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>Rectangle<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>integer<font color="#000080">);
</font><font color="#FF0000"><b>Begin
     </b></font>Line<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y1<font color="#000080">);         </font><font color="#008000"><i>{ Top Line    }
     </i></font>Line<font color="#000080">(</font>x1<font color="#000080">,</font>y2<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">);         </font><font color="#008000"><i>{ Bottom Line }
     </i></font>Line<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">+</font><font color="#800000">1</font><font color="#000080">,</font>x1<font color="#000080">,</font>y2<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);     </font><font color="#008000"><i>{ Left edge   }
     </i></font>Line<font color="#000080">(</font>x2<font color="#000080">,</font>y1<font color="#000080">+</font><font color="#800000">1</font><font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);     </font><font color="#008000"><i>{ Right edge  }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
Change position of graphics cursor.

Expects : NewCursX and NewCursY are the horizontal and vertical
          coordinates that you wish to move the cursor to.
          NewCursX may be negative or more than GetMaxX.
          NewCursY may be negative or more than GetMaxY.

Returns : Nothing

Corrupts : AX.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>MoveTo<font color="#000080">(</font>NewCursX<font color="#000080">,</font>NewCursY<font color="#000080">:</font>integer<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,NewCursX
   MOV CursorX,AX
   MOV AX,NewCursY
   MOV CursorY,AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;










</font><font color="#008000"><i>{
Returns horizontal position of graphics cursor.
GetX May be negative.

Expects : Nothing

Returns : GetX = Current graphics cursor horizontal position, which
          may be negative or even exceed GetMaxX.
}

</i></font><font color="#FF0000"><b>Function </b></font>GetX<font color="#000080">: </font>integer<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,CursorX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Returns vertical position of graphics cursor.
GetY may be negative.

Expects : Nothing

Returns : GetY = Current graphics cursor vertical position, which
          may be negative or even exceed GetMaxY.


}

</i></font><font color="#FF0000"><b>Function </b></font>GetY<font color="#000080">: </font>integer<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX, CursorY
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;











</font><font color="#008000"><i>{
*************
FONT ROUTINES
*************

}


{
Select which of the Fonts in ROM you use to write text to the
screen.

Expects : FontNumber can be:

          0: For CGA Font (Dunno what size it is tho')
          1: For 8 x 8 Font
          2: For 8 x 14 Font
          3: For 8 x 8 Font
          4: For 8 x 8 Font high 128 characters
          5: For Rom Alpha Alternate Font
          6: For 8 x 16 Font
          7: For Rom Alternate 9 x 16 Font


Returns : Nothing

Corrupts : AX,BX,ES

}

</i></font><font color="#FF0000"><b>Procedure </b></font>UseFont<font color="#000080">(</font>FontNumber<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX,$1130                      </font><font color="#008000"><i>{ Get Font address }
     </i></font><font color="#FF00FF">MOV BH,FontNumber
     CMP BH,7                          </font><font color="#008000"><i>{ Font number &gt; 7 ? }
     </i></font><font color="#FF00FF">JA @NoWriteSize                   </font><font color="#008000"><i>{ Yes, so it's invalid }

     </i></font><font color="#FF00FF">PUSH BP                           </font><font color="#008000"><i>{ Mustn't corrupt BP, as Turbo
                                         needs it preserved for local
                                         variable access }
     </i></font><font color="#FF00FF">PUSH BX                           </font><font color="#008000"><i>{ Nor BH as it's to be used later }
     </i></font><font color="#FF00FF">INT $10                           </font><font color="#008000"><i>{ Now get Font address }
     </i></font><font color="#FF00FF">MOV CurrentFontSegMent,ES         </font><font color="#008000"><i>{ ES:BP points to where Font is }
     </i></font><font color="#FF00FF">MOV CurrentFontOffset,BP          </font><font color="#008000"><i>{ located in ROM }
     </i></font><font color="#FF00FF">POP BX                            </font><font color="#008000"><i>{ Restore Font number }
     </i></font><font color="#FF00FF">POP BP                            </font><font color="#008000"><i>{ Restore BP }

     </i></font><font color="#FF00FF">CMP BH,Int1fFont                  </font><font color="#008000"><i>{ User Font in memory ? }
     </i></font><font color="#FF00FF">JZ @NoWriteSize                   </font><font color="#008000"><i>{ Don't set size, could be more than
                                         8 x 8. User will have to set himself.
                                         Please correct me if I am wrong }
     </i></font><font color="#FF00FF">CMP BH,Font8x8                    </font><font color="#008000"><i>{ User want any of the 8 x 8 Fonts ? }
     </i></font><font color="#FF00FF">JZ @Set8x8
     CMP BH,Font8x8dd
     JZ @Set8x8
     CMP BH,Font8x8ddHigh
     JZ @Set8x8
     CMP BH,AlphaAlternateFont
     JNZ @Check8x14Font

@Set8x8:
     MOV AL,8                          </font><font color="#008000"><i>{ Width of 8 }
     </i></font><font color="#FF00FF">MOV AH,8                          </font><font color="#008000"><i>{ Height of 8 }
     </i></font><font color="#FF00FF">MOV BL,1                          </font><font color="#008000"><i>{ 1 byte's width }
     </i></font><font color="#FF00FF">JMP @DoWrite



@Check8x14Font:
     CMP BH,Font8x14
     JNZ @Check8x16Font
     MOV AL,8                          </font><font color="#008000"><i>{ Width 8, Height 14, ByteWidth 1 }
     </i></font><font color="#FF00FF">MOV AH,14
     MOV BL,1
     JMP @DoWrite

@Check8x16Font:
     CMP BH,Font8x16
     JNZ @UseRomAlternateFont
     MOV AL,8                          </font><font color="#008000"><i>{ Oh C'mon do I have to document }
     </i></font><font color="#FF00FF">MOV AH,16                         </font><font color="#008000"><i>{ this ? }
     </i></font><font color="#FF00FF">MOV BL,1
     JMP @DoWrite

@UseRomAlternateFont:
     MOV AL,9
     MOV AH,16
     MOV BL,2


@DoWrite:
     MOV CurrentFontWidth,AL           </font><font color="#008000"><i>{ Write Font details so that }
     </i></font><font color="#FF00FF">MOV CurrentFontByteWidth,BL       </font><font color="#008000"><i>{ outtextXY etc. can work with }
     </i></font><font color="#FF00FF">MOV CurrentFontHeight,AH          </font><font color="#008000"><i>{ this Font }

</i></font><font color="#FF00FF">@NoWriteSize:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
If you wish to do your own text routines, then this returns the
address of the current Font in FontSeg and FontOfs which specify the
segment and offset address of the character set.

Expects  : Two uninitialised word variables

Returns  : FontSeg = Segment where Font is located
           FontOfs = Offset of Font

Corrupts : AX,DI,ES.

}

</i></font><font color="#FF0000"><b>Procedure </b></font>GetCurrentFontAddr<font color="#000080">(</font><font color="#FF0000"><b>VAR </b></font>FontSeg<font color="#000080">, </font>FontOfs<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,CurrentFontSegment
   LES DI,FontSeg
   MOV [ES:DI],AX
   MOV AX,CurrentFontOffset
   LES DI,FontOfs
   MOV [ES:DI],AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
If you want to use a Font loaded in from disk use SetFontAddr to
specify where the new Font resides in memory.

Expects : NewFontSeg and NewFontOfs are the segment and offset of the
          address.

Returns : Nothing

Corrupts : AX
}

</i></font><font color="#FF0000"><b>Procedure </b></font>SetCurrentFontAddr<font color="#000080">(</font>NewFontSeg<font color="#000080">,</font>NewFontOfs<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,NewFontSeg
   MOV CurrentFontSegment,AX
   MOV AX,NewFontOfs
   MOV CurrentFontOffset,AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Find out what width and height the current Font is.

Expects: CurrFontWidth and CurrFontHeight are two uninitialised
         variables.

Returns: CurrFontWidth and CurrFontHeight on exit hold the width
         and height of the current Font. (Bet you never guessed that, huh)

Corrupts : AX,DI,ES
}


</i></font><font color="#FF0000"><b>Procedure </b></font>GetCurrentFontSize<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>CurrFontWidth<font color="#000080">, </font>CurrFontHeight<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AL,CurrentFontWidth
   MOV AH,CurrentFontHeight

   LES DI,CurrFontWidth         </font><font color="#008000"><i>{ ES: DI points to variable now }
   </i></font><font color="#FF00FF">MOV [ES:DI],AL
   LES DI,CurrFontHeight
   MOV [ES:DI],AH
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Specify width and height of a user created Font.

Expects  : NewFontWidth must be above 7,
           NewFontHeight can be any non-zero number.

Returns  : Nothing

Corrupts : AX

}

</i></font><font color="#FF0000"><b>Procedure </b></font>SetCurrentFontSize<font color="#000080">(</font>NewFontWidth<font color="#000080">, </font>NewFontHeight<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AL,NewFontWidth
     MOV AH,NewFontHeight

     CMP AL,8                   </font><font color="#008000"><i>{ Width &gt;= 8 ? }
     </i></font><font color="#FF00FF">JB @IllegalSize
     OR AH,AH                   </font><font color="#008000"><i>{ Is Height 0 ? }
     </i></font><font color="#FF00FF">JZ @IllegalSize

     MOV CurrentFontWidth,AL
     MOV CurrentFontHeight,AH
     SHR AL,3                   </font><font color="#008000"><i>{ Calculate byte width of characters
                                  i.e. divide width in pixels by 8 }
     </i></font><font color="#FF00FF">MOV CurrentFontByteWidth,AL

@IllegalSize:

</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
For those of you who want to do your own text routines, this
Procedure may lighten your workload a bit.

Expects : Characternumber to be (obviously) the number of the
          character.

Returns : This Function returns the offset address of character.

Corrupts : AX,BX,DX
}

</i></font><font color="#FF0000"><b>Function </b></font>GetROMCharOffset<font color="#000080">(</font>CharNum<font color="#000080">:</font>byte<font color="#000080">): </font>word<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AL,CharNum                  </font><font color="#008000"><i>{ Get number of character into AL }
   </i></font><font color="#FF00FF">MOV BH,CurrentFontByteWidth
   MOV BL,CurrentFontHeight
   MUL BL                          </font><font color="#008000"><i>{ Multiply character num by FontHeight }
   </i></font><font color="#FF00FF">MOV BL,BH
   XOR BH,BH
   MUL BX                          </font><font color="#008000"><i>{ And FontWidth }
   </i></font><font color="#FF00FF">ADD AX,CurrentFontOffset        </font><font color="#008000"><i>{ Now add in the font offset }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>(*
This routine lets you load bitmapped Font files (created by this
unit) from disk. Currently I am examining the file format of
Compugraphic Fonts and basically I understand absolutely sod all
of it.. send me some code for reading them please !!


FontType = record
   FontSeg    : Word;           { Where Font is located; when loaded }
   FontOfs    : Word;           { in these are set by system }
   FontWidth  : Byte;           { Width (In Pixels) }
   FontByteWidth : Byte;
   FontHeight : Byte;           { Height (In Pixels) }
   FontChars  : Byte;           { Number of characters in Font }
End;


*)


</i></font><font color="#FF0000"><b>Procedure </b></font>LoadFont<font color="#000080">(</font>FontFileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>FontRec<font color="#000080">: </font>FontType<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>FontFile <font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
    </font>BytesToReserve <font color="#000080">: </font>word<font color="#000080">;
    </font>FontPtr <font color="#000080">: </font>Pointer<font color="#000080">;

</font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>FontFile<font color="#000080">,</font>FontFileName<font color="#000080">);
     </font>Reset<font color="#000080">(</font>FontFile<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>BlockRead<font color="#000080">(</font>FontFile<font color="#000080">,</font>FontRec<font color="#000080">,</font>SizeOf<font color="#000080">(</font>FontRec<font color="#000080">));
     </font><font color="#FF0000"><b>With </b></font>FontRec <font color="#FF0000"><b>Do
          Begin
          </b></font>BytesToReserve<font color="#000080">:=</font>FontChars <font color="#000080">* (</font>FontByteWidth <font color="#000080">* </font>FontHeight<font color="#000080">);
          </font>GetMem<font color="#000080">(</font>FontPtr<font color="#000080">,</font>BytesToReserve<font color="#000080">);
          </font>GetPtrData<font color="#000080">(</font>FontPtr<font color="#000080">,</font>FontSeg<font color="#000080">,</font>FontOfs<font color="#000080">);
          </font>BlockRead<font color="#000080">(</font>FontFile<font color="#000080">,</font>Mem<font color="#000080">[</font>FontSeg<font color="#000080">:</font>FontOfs<font color="#000080">],</font>BytesToReserve<font color="#000080">);
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
     </font>Close<font color="#000080">(</font>FontFile<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
This routine will save a portion (or all) of the current Font to disk.

Expects : FontFileName to be an MS-DOS filename to hold the char data.
          FirstChar to be the number of the first character to save
          (0-255);
          NumChars to be the number of characters to save (You may
          only want to save part of a Font).

Returns  : Nothing

Corrupts : Don't know.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SaveFont<font color="#000080">(</font>FontFileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font>FirstChar<font color="#000080">, </font>Numchars<font color="#000080">:</font>byte<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>TempFontRec     <font color="#000080">: </font>FontType<font color="#000080">;
    </font>FontFile        <font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
    </font>BytesPerChar    <font color="#000080">: </font>word<font color="#000080">;
    </font>FirstCharOffset <font color="#000080">: </font>word<font color="#000080">;

</font><font color="#FF0000"><b>Begin
     With </b></font>TempFontRec <font color="#FF0000"><b>do
          Begin
          </b></font>FontSeg<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;               </font><font color="#008000"><i>{ 0 Meaning uninitialised }
          </i></font>FontOfs<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
          </font>FontByteWidth<font color="#000080">:=</font>CurrentFontByteWidth<font color="#000080">;
          </font>FontWidth<font color="#000080">:=</font>CurrentFontWidth<font color="#000080">;
          </font>FontHeight<font color="#000080">:=</font>CurrentFontHeight<font color="#000080">;
          </font>FontChars<font color="#000080">:=</font>NumChars<font color="#000080">;
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font>Assign<font color="#000080">(</font>FontFile<font color="#000080">,</font>FontFileName<font color="#000080">);
     </font>Rewrite<font color="#000080">(</font>FontFile<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>BlockWrite<font color="#000080">(</font>FontFile<font color="#000080">,</font>TempFontRec<font color="#000080">,</font>SizeOf<font color="#000080">(</font>TempFontRec<font color="#000080">));

     </font>BytesPerChar<font color="#000080">:=</font>CurrentFontByteWidth <font color="#000080">* </font>CurrentFontHeight<font color="#000080">;
     </font>FirstCharOffset<font color="#000080">:=</font>CurrentFontOffset<font color="#000080">+(</font>FirstChar <font color="#000080">* </font>BytesPerChar<font color="#000080">);

     </font>BlockWrite<font color="#000080">(</font>FontFile<font color="#000080">, </font>Mem<font color="#000080">[</font>CurrentFontSegment<font color="#000080">:</font>FirstCharOffset<font color="#000080">],
     </font>NumChars <font color="#000080">* </font>BytesPerChar<font color="#000080">);

     </font>Close<font color="#000080">(</font>FontFile<font color="#000080">);


</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Use a Font loaded in from disk. Yes, I know there are many Font load
routines in the SWAG and most (if not ALL) use interrupt 10h to do
the business. But my routine doesn't because quite frankly using the
BIOS is slow, cack, and is far too limiting.

This routine allows characters of ANY size.

Expects : Variable FontRec to have been initialised (usually by LoadFont).
          You could initialise FontRec yourself if you liked and
          that would be faster than using SetFontAddr, SetFontSize etc.

Returns : Nothing

Corrupts : Don't know. That's the thing about Pascal!
}


</i></font><font color="#FF0000"><b>Procedure </b></font>UseLoadedFont<font color="#000080">(</font>FontRec <font color="#000080">: </font>FontType<font color="#000080">);
</font><font color="#FF0000"><b>Begin
     With </b></font>FontRec <font color="#FF0000"><b>Do
          Begin
          </b></font>CurrentFontSegment<font color="#000080">:=</font>FontSeg<font color="#000080">;
          </font>CurrentFontOffset<font color="#000080">:=</font>FontOfs<font color="#000080">;
          </font>SetCurrentFontSize<font color="#000080">(</font>FontWidth<font color="#000080">,</font>FontHeight<font color="#000080">);
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Display text at a position on screen. (May be off screen)

Expects : X,Y specify the top left of where the text is to be
          printed.
          txt is the actual text to be printed.

Returns : Graphics cursor position is changed. (In normal Turbo
          it is not, but what the hell)

Corrupts : AX,BX,CX,DX,SI,DI,ES,FS,GS.

}


</i></font><font color="#FF0000"><b>Procedure </b></font>OutTextXY<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font>txt<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
         </b></font><font color="#FF00FF">MOV AX,X
         MOV CursorX,AX
         MOV AX,Y
         MOV CursorY,AX

         XOR BH,BH                    </font><font color="#008000"><i>{ Get Font height into BX }
         </i></font><font color="#FF00FF">MOV BL,CurrentFontHeight
         NEG BX                       </font><font color="#008000"><i>{ Make BX negative number }

         </i></font><font color="#FF00FF">CMP AX,BX                    </font><font color="#008000"><i>{ Check if text would not be
                                        seen at top edge of screen
                                        (i.e. If -FontHeight &gt;
                                        CursorY) }
         </i></font><font color="#FF00FF">JL @NoWrite                  </font><font color="#008000"><i>{ Yes, so don't write text }

         </i></font><font color="#FF00FF">CMP AX,199                   </font><font color="#008000"><i>{ Check if off bottom of screen }
         </i></font><font color="#FF00FF">JG @NoWrite                  </font><font color="#008000"><i>{ Yes, so don't write text }

         </i></font><font color="#FF00FF">PUSH BP
         LES DI,TXT                   </font><font color="#008000"><i>{ Yes, I know LGS DI exists but
                                        it's a lot of hassle to find
                                        out it's opcodes !}
         </i></font><font color="#FF00FF">MOV AX,ES
         DB $8E,$E8                   </font><font color="#008000"><i>{ MOV GS, AX }

         </i></font><font color="#FF00FF">DB $65                       </font><font color="#008000"><i>{ GS : }
         </i></font><font color="#FF00FF">MOV CL,[DI]                  </font><font color="#008000"><i>{ MOV CL, [GS:DI]
                                        CL = Length of string }

</i></font><font color="#FF00FF">@ReadChar:

         INC DI                      </font><font color="#008000"><i>{ Prepare to read char }
         </i></font><font color="#FF00FF">PUSH DI                     </font><font color="#008000"><i>{ And offset of char }
         </i></font><font color="#FF00FF">PUSH CX

         DB $65                      </font><font color="#008000"><i>{ GS : }
         </i></font><font color="#FF00FF">MOV AL,[DI]                 </font><font color="#008000"><i>{ AL = Character }
         </i></font><font color="#FF00FF">XOR AH,AH



         PUSH AX

         MOV AL,CurrentFontByteWidth   </font><font color="#008000"><i>{ Now compute Fontbytewidth
                                         * Fontheight }
         </i></font><font color="#FF00FF">MOV BL,CurrentFontHeight

         MUL BL                        </font><font color="#008000"><i>{ Fontbytewidth * FontHeight }
         </i></font><font color="#FF00FF">MOV DI,AX                     </font><font color="#008000"><i>{ DI = Result }

         </i></font><font color="#FF00FF">POP AX                        </font><font color="#008000"><i>{ Restore character number }
         </i></font><font color="#FF00FF">MUL DI                        </font><font color="#008000"><i>{ AX = Char * (FontByteWidth *
                                         FontHite) }

         </i></font><font color="#FF00FF">ADD AX,CurrentFontOffset
         MOV DI,AX                     </font><font color="#008000"><i>{ Now DI is correctly placed }


         {
         Now blit the data to the screen
         Come on Bas, write something faster for this purpose..
         Bet you can't !
         }

         </i></font><font color="#FF00FF">MOV ES,CurrentFontSegment

         MOV AX,CursorX              </font><font color="#008000"><i>{ Update graphic coordinates }
         </i></font><font color="#FF00FF">MOV BX,CursorY

         MOV CH,CurrentFontHeight

@ScanLineLoop:
         PUSH CX                     </font><font color="#008000"><i>{ Save Vert Count on stack }
         </i></font><font color="#FF00FF">MOV CH,CurrentFontByteWidth

@OuterLoop:

         MOV CL,[ES:DI]        </font><font color="#008000"><i>{ Read byte from charmap }
         </i></font><font color="#FF00FF">OR CL,CL              </font><font color="#008000"><i>{ test if it's 0 }
         </i></font><font color="#FF00FF">JZ @RestoreByteOffset </font><font color="#008000"><i>{ If so, no point in wasting CPU time }

         {
         Otherwise..
         }

         </i></font><font color="#FF00FF">MOV BP, AX            </font><font color="#008000"><i>{ Save X - Coord }
         </i></font><font color="#FF00FF">MOV DH,8              </font><font color="#008000"><i>{ 8 bits make a character's byte }
         </i></font><font color="#FF00FF">MOV DL,CurrentColour   </font><font color="#008000"><i>{ FPutPixel needs this }


</i></font><font color="#FF00FF">@PlotLoop:
         TEST CL,$80           </font><font color="#008000"><i>{ Bit 7 set ? }
         </i></font><font color="#FF00FF">JZ @NoPlot            </font><font color="#008000"><i>{ No, so don't plot a pixel }

         </i></font><font color="#FF00FF">MOV SI,AX             </font><font color="#008000"><i>{ Save X in SI - SI is the only
                                 Free register and it's faster than
                                 a PUSH }

         </i></font><font color="#FF00FF">PUSH BX
         PUSH CX

         CALL FPutPixel        </font><font color="#008000"><i>{ Plot pixel at AX,BX. }

         </i></font><font color="#FF00FF">POP CX
         POP BX
         MOV AX,SI             </font><font color="#008000"><i>{ Restore X coord }

</i></font><font color="#FF00FF">@NoPlot:
         SHL CL,1              </font><font color="#008000"><i>{ Shift char byte left }
         </i></font><font color="#FF00FF">INC AX                </font><font color="#008000"><i>{ Adjust X }

         </i></font><font color="#FF00FF">DEC DH                </font><font color="#008000"><i>{ Reduce horizontal count }
         </i></font><font color="#FF00FF">JNZ @PlotLoop         </font><font color="#008000"><i>{ If not 0, go to plot loop }

         </i></font><font color="#FF00FF">MOV AX,BP




@RestoreByteOffset:
         INC DI                </font><font color="#008000"><i>{ move to next byte }

         </i></font><font color="#FF00FF">DEC CH                </font><font color="#008000"><i>{ Reduce byte count }
         </i></font><font color="#FF00FF">JNZ @OuterLoop

         POP CX                </font><font color="#008000"><i>{ Restore vert count }

         </i></font><font color="#FF00FF">INC BX                </font><font color="#008000"><i>{ Add 1 to Y, assuming Y is not more
                                 than 255. Do NOT use BL to gain more
                                 speed! unexpected side effects will
                                 occur when writing text at the top of
                                 your screen }
         </i></font><font color="#FF00FF">DEC CH                </font><font color="#008000"><i>{ Reduce vert count }

         </i></font><font color="#FF00FF">JNZ @ScanLineLoop


</font><font color="#008000"><i>{
Now is the time to update the graphics cursor after the single
character has been printed.
}

         </i></font><font color="#FF00FF">MOV AL,CurrentFontWidth
         XOR AH,AH                   </font><font color="#008000"><i>{ Make AH 0 }
         </i></font><font color="#FF00FF">ADD CursorX,AX              </font><font color="#008000"><i>{ Update the graphics cursor }

         </i></font><font color="#FF00FF">POP CX                </font><font color="#008000"><i>{ Restore width. Wish there were more
                                 data registers to work with but there
                                 aren't and it's a bad situation really }
         </i></font><font color="#FF00FF">POP DI                </font><font color="#008000"><i>{ Restore next char to print's offset }

         </i></font><font color="#FF00FF">DEC CL                </font><font color="#008000"><i>{ Reduce char length counter }
         </i></font><font color="#FF00FF">JNZ @ReadChar

         POP BP

@NoWrite:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Display a string of text at the current cursor position, using
the current Font.

Expects : Txt is the text to write at the current cursor position.

Returns : Graphics cursor has moved.

Corrupts : See OutTextXY.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>OutText<font color="#000080">(</font>txt<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">);
</font><font color="#FF0000"><b>Begin
     </b></font>OutTextXY<font color="#000080">(</font>CursorX<font color="#000080">,</font>CursorY<font color="#000080">,</font>txt<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;
</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0221.PAS">Original</a><b>]</b></p></body>
</html>
