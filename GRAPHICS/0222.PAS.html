<html>
<head><title> "Improved Graphics Rountines Part 2" by SCOTT TUNSTALL</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0222.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
PART 2 OF NEWGRAPH.PAS

You need NEWGRPH1.PAS first. Insert this into the bottom of the
NEWGRPH1.PAS file, compile and use this TPU till yer blue in the
face!!!



****************
Palette routines
****************

}




{
Get the red, green and blue components of a colour.

Expects :   ColourNumber is the number of the colour of which you
            want to read the Palette values (0-255).
            RedValue, GreenValue, BlueValue need not be initialised.

Returns :   The Red, Green, Blue Values of the colour specified
            by ColourNumber.

}

</i></font><font color="#FF0000"><b>Procedure </b></font>GetPalette<font color="#000080">(</font>ColourNumber <font color="#000080">: </font>Byte<font color="#000080">;
          </font><font color="#FF0000"><b>VAR </b></font>RedValue<font color="#000080">, </font>GreenValue<font color="#000080">, </font>BlueValue <font color="#000080">: </font>Byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV DX,$3C7          </font><font color="#008000"><i>{ $3C7 is colour ** READ ** select port. }
   </i></font><font color="#FF00FF">MOV AL,ColourNumber   </font><font color="#008000"><i>{ Select colour to read }
   </i></font><font color="#FF00FF">OUT DX,AL
   ADD DL,2             </font><font color="#008000"><i>{ DX now = $3C9, which must be read 3 times
                          in order to obtain the Red, Green and
                          Blue values of a colour }

   </i></font><font color="#FF00FF">IN AL,DX             </font><font color="#008000"><i>{ Read red amount. Don't use IN AX,DX as
                          for some strange reason it doesn't work ! }
   </i></font><font color="#FF00FF">LES DI,RedValue
   MOV [ES:DI],AL       </font><font color="#008000"><i>{ Techie saddos note : STOSB is approx 4 cycles
                          slower and requires double cache multiplex,
                          which basically means &quot;who gives a shit ?&quot;. :-)
                        }

   </i></font><font color="#FF00FF">IN AL,DX
   LES DI,GreenValue
   MOV [ES:DI],AL

   IN AL,DX             </font><font color="#008000"><i>{ Read blue }
   </i></font><font color="#FF00FF">LES DI,BlueValue
   MOV [ES:DI],AL
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
This will change the red green and blue components of a colour,
thereby affecting it's shade. How's that for picturesque speech ?

Note : You don't need a PaletteType record to use this command,
it affects the screen directly.

Expects : ColourNumber is the number of the colour from 0 to 255.
          RedValue is the red component of the colour (0-63).
          GreenValue is the green component of the colour (0-63).
          BlueValue is the blue component of the colour (0-63).

Returns : Nothing

Corrupts : AL,DX
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SetPalette<font color="#000080">(</font>ColourNumber<font color="#000080">, </font>RedValue<font color="#000080">, </font>GreenValue<font color="#000080">, </font>BlueValue <font color="#000080">: </font>Byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AL,ColourNumber
   MOV DX,$3c8          </font><font color="#008000"><i>{ Write to Port $3C8 with number of Colour to alter }
   </i></font><font color="#FF00FF">OUT DX,AL
   INC DL               </font><font color="#008000"><i>{ $3C9 again ! }
   </i></font><font color="#FF00FF">MOV AL,RedValue      </font><font color="#008000"><i>{ Store Red }
   </i></font><font color="#FF00FF">OUT DX,AL
   MOV AL,GreenValue    </font><font color="#008000"><i>{ Store Green }
   </i></font><font color="#FF00FF">OUT DX,AL
   MOV AL,BlueValue     </font><font color="#008000"><i>{ Store Blue }
   </i></font><font color="#FF00FF">OUT DX,AL
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>(*
This Procedure takes a snapshot of all of the colours on screen.

Expects : Palette is a variable of type PaletteType which will
          hold the 256 colour palette.

Returns : Nothing

Notes   : Use this command just before a mode change so that
          you can restore the palette to it's original state
          (via SetAllPalette) at the end of the program.
          (Unless of course you want to corrupt everything)

*)


</i></font><font color="#FF0000"><b>Procedure </b></font>GetAllPalette<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>ColourCount<font color="#000080">:</font>byte<font color="#000080">;
</font><font color="#FF0000"><b>Begin
     For </b></font>ColourCount<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#000080">(</font>MaxColours <font color="#000080">- </font><font color="#800000">1</font><font color="#000080">) </font><font color="#FF0000"><b>do
     </b></font>GetPalette<font color="#000080">(</font>ColourCount<font color="#000080">,</font>Palette<font color="#000080">.</font>RedLevel<font color="#000080">[</font>ColourCount<font color="#000080">],
     </font>Palette<font color="#000080">.</font>GreenLevel<font color="#000080">[</font>ColourCount<font color="#000080">],</font>Palette<font color="#000080">.</font>BlueLevel<font color="#000080">[</font>ColourCount<font color="#000080">]);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Do I need to explain what this does? It loads in a Palette
from file FileName and stores it in the variable Palette.
Easy enough to use.

Expects : FileName is standard MS-DOS filename which refers to the
          palette file.
          Palette is variable of type PaletteType used to hold
          the palette data.

Corrupts : Don't know.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LoadPalette<font color="#000080">(</font>FileName<font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>PaletteFile<font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>PaletteFile<font color="#000080">,</font>FileName<font color="#000080">);
     </font>Reset<font color="#000080">(</font>PaletteFile<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>BlockRead<font color="#000080">(</font>PaletteFile<font color="#000080">,</font>Palette<font color="#000080">,</font>SizeOf<font color="#000080">(</font>Palette<font color="#000080">));
     </font>Close<font color="#000080">(</font>PaletteFile<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
Guess what this does then !.

Expects : FileName is the MS-DOS file spec of the palette to be saved.
          Palette is the palette to be saved.

Returns : Nothing

Corrupts : As it's not in assembler it's hard to say, but I guess
           Pascal preserves all registers on entry to a routine ..
           (Don't quote me on that !)
}

</i></font><font color="#FF0000"><b>Procedure </b></font>SavePalette<font color="#000080">(</font>FileName<font color="#000080">: </font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>PaletteFile<font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>PaletteFile<font color="#000080">,</font>FileName<font color="#000080">);
     </font>Rewrite<font color="#000080">(</font>PaletteFile<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>BlockWrite<font color="#000080">(</font>PaletteFile<font color="#000080">,</font>Palette<font color="#000080">,</font>SizeOf<font color="#000080">(</font>Palette<font color="#000080">));
     </font>Close<font color="#000080">(</font>PaletteFile<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
This sets the DACs to the Colours specified in your
Palette array. Do NOT alter the Palette data structure
or else this won't work.

Expects : Palette is an initialised palette of PaletteType.

Returns : Nothing

Corrupts : AL, BX, CL, DX, SI, DI, ES
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SetAllPalette<font color="#000080">(</font>Palette <font color="#000080">: </font>PaletteType<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">PUSH DS
   LDS BX, Palette      </font><font color="#008000"><i>{ DS:BX points to Palette record }
   </i></font><font color="#FF00FF">XOR AL,AL
   MOV DX,$3c8          </font><font color="#008000"><i>{ $3c8 selects the first colour to alter.
                          After 3 writes to $3c9, the VGA automatically
                          moves to the next Colour so there is no
                          need to write to $3c8 again. }
   </i></font><font color="#FF00FF">OUT DX,AL
   INC DL               </font><font color="#008000"><i>{ Make DX = $3c9, which is used to set the
                          Red / Green and Blue values of a Colour }

   </i></font><font color="#FF00FF">MOV CL,(MaxColours-1) </font><font color="#008000"><i>{ 256 colours }

   </i></font><font color="#FF00FF">MOV SI,BX
   ADD SI,MaxColours     </font><font color="#008000"><i>{ Make SI point to green levels }
   </i></font><font color="#FF00FF">MOV DI,BX
   ADD DI,MaxColours     </font><font color="#008000"><i>{ Make DI point to blue levels }
   </i></font><font color="#FF00FF">ADD DI,MaxColours

</font><font color="#008000"><i>{
Note: I read somewhere that some VGA adapters don't like
      being hit with continuous data too quickly..

      If not then you should use the BIOS load palette
      function (which will be 20 times slower than this
      hack trick)
}

</i></font><font color="#FF00FF">@WritePaletteInfo:
   MOV AL, [BX]         </font><font color="#008000"><i>{ Read red level from Palette struct }
   </i></font><font color="#FF00FF">OUT DX,AL            </font><font color="#008000"><i>{ Write to port $3c9 }
   </i></font><font color="#FF00FF">MOV AL, [SI]         </font><font color="#008000"><i>{ Read green level from Palette struct }
   </i></font><font color="#FF00FF">OUT DX,AL            </font><font color="#008000"><i>{ Write to port $3c9 }
   </i></font><font color="#FF00FF">MOV AL, [DI]         </font><font color="#008000"><i>{ Read blue level from Palette struct }
   </i></font><font color="#FF00FF">OUT DX,AL            </font><font color="#008000"><i>{ Write to port $3c9 }

   </i></font><font color="#FF00FF">INC DI               </font><font color="#008000"><i>{ Next Red part of record }
   </i></font><font color="#FF00FF">INC BX               </font><font color="#008000"><i>{ Next Green }
   </i></font><font color="#FF00FF">INC SI               </font><font color="#008000"><i>{ Next Blue }

   </i></font><font color="#FF00FF">DEC CL
   CMP CL,$FF               </font><font color="#008000"><i>{ Dunno if a JNZ works when register is 0
                            or $ff. }
   </i></font><font color="#FF00FF">JNZ @WritePaletteInfo
   POP DS
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Set the new graphics colour. Also affects text routines as well.

Expects : NewColour is the new graphics Colour.

Returns : Nothing.

Corrupts : AL.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SetColour<font color="#000080">(</font>NewColour<font color="#000080">:</font>byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
    </b></font><font color="#FF00FF">MOV AL,NewColour
    MOV CurrentColour,AL
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Get the current graphics colour.
}

</i></font><font color="#FF0000"><b>Function </b></font>GetColour<font color="#000080">: </font>byte<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AL, CurrentColour;
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;
























</font><font color="#008000"><i>{
****************
Sprite Functions
****************
}


{
Get the width of a shape

Expects : DataPtr^ points to a shape in memory

Returns : Width of shape (1-255)

Corrupts : ES, DI
}

</i></font><font color="#FF0000"><b>Function </b></font>ShapeWidth<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">): </font>byte<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">LES DI,DataPtr
   MOV AL,[ES:DI]
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;




</font><font color="#008000"><i>{
Get the height (in pixels) of an Shape.

Expects : DataPtr^ points to a shape held in memory

Returns : Height of shape (1-255)

Corrupts : ES,DI
}

</i></font><font color="#FF0000"><b>Function </b></font>ShapeHeight<font color="#000080">(</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">): </font>byte<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">LES DI,DataPtr
   MOV AL,[ES:DI+1]
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
This Function returns the number of bytes required to store
a shape object of a given width and height.

Expects : ShapeWidth is the width of the Shape (1-255). You can
          obtain the width of a shape by using the ShapeWidth
          Function above.

          Shapeheight is the height of the Shape (1-255). You can
          obtain the height of a shape by using the ShapeHeight
          Function above.

Returns : ExtShapeSize = No of bytes shape uses.


Corrupts : AL,BL.

}


</i></font><font color="#FF0000"><b>Function </b></font>ExtShapeSize<font color="#000080">(</font>ShapeWidth<font color="#000080">, </font>ShapeHeight <font color="#000080">: </font>byte<font color="#000080">): </font>word<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AL, ShapeWidth
   MOV BL, ShapeHeight
   MUL BL
   INC AX
   INC AX
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;




</font><font color="#008000"><i>{
Calculate the number of bytes required to hold a shape in memory,
if grabbed from the screen.

Expects :     X1, Y1, X2, and Y2 define a rectangular region that
              lies on an imaginary screen (No reading of source/
              dest Bitmap is done!). X1 and X2 must be in the range of
              0-319; Y1 and Y2 must be in the range of 0-199.

              You are restricted to images up to 255 x 200 pixels
              in size. (Why 200? Well, you can't grab past the
              vertical limits of the VGA screen can you ?)

Returns :     Number of bytes used to hold image. If 0, then this
              means the image is too large to load into a 64K
              portion of RAM.

Corrupts :    BX,DX.
}

</i></font><font color="#FF0000"><b>Function </b></font>ShapeSize<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>word<font color="#000080">):</font>word<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX,x2          </font><font color="#008000"><i>{ Width = (X2 - X1) + 1 }
     </i></font><font color="#FF00FF">SUB AX,x1
     INC AX             </font><font color="#008000"><i>{ Add one extra width byte }
     </i></font><font color="#FF00FF">AND AH,$7F
     OR AH,AH
     JNZ @TooBig

     MOV BX,y2          </font><font color="#008000"><i>{ Height = (Y2 - Y1) + 1 }
     </i></font><font color="#FF00FF">SUB BX,y1
     INC BX
     AND BH,$7F         </font><font color="#008000"><i>{ And again }
     </i></font><font color="#FF00FF">CMP BX,201
     JB @ShapeFine      </font><font color="#008000"><i>{ No, shape is OK in width and height }

</i></font><font color="#FF00FF">@TooBig:
     XOR AX,AX          </font><font color="#008000"><i>{ Set AX to return 0, meaning error }
     </i></font><font color="#FF00FF">JMP @Finished

@ShapeFine:
     MUL BL             </font><font color="#008000"><i>{ SpriteDataSize = Width * Height }
     </i></font><font color="#FF00FF">ADD AX,2           </font><font color="#008000"><i>{ Take into account 2 bytes for Shape &quot;header&quot; }

</i></font><font color="#FF00FF">@Finished:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;











</font><font color="#008000"><i>{
Display a shape at a given position on screen, over the current
background (Most games with sprites use this technique). And
if this isn't the fastest sprite routine in the SWAG then I'll
eat my C64.

Expects : X and Y specify a horizontal and vertical position for
          the TOP LEFT of an Shape. (Regardless whether or not the
          shape's edge is transparent)

          X and Y are presumed ALWAYS valid : i.e. Within bounds of
          screen; Also, it is presumed that the sprite is not placed
          in a position on screen that over runs the screen borders:
          unexpected effects would occur. Sorry! Use ClipBlit if you
          must place sprites in the screen border.

          DataPtr, the untyped variable, must point to data for a
          sprite which is up to 254 pixels wide and 200 pixels
          tall.

Returns : Nothing

Corrupts : AX,BX,CX,DX,SI,DI,ES, &amp; Direction Flag

}

</i></font><font color="#FF0000"><b>Procedure </b></font>Blit<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>word<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">; </font><font color="#008000"><i>{ A - Ha ! }
</i></font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,x
   MOV BX,y
   CALL CalculateOffset         </font><font color="#008000"><i>{ Calculate where to blit to }

   </i></font><font color="#FF00FF">MOV ES,SourceBitmapSegment   </font><font color="#008000"><i>{ Point ES to source Bitmap }

   </i></font><font color="#FF00FF">MOV CX,DS                    </font><font color="#008000"><i>{ Faster than stack }
   </i></font><font color="#FF00FF">LDS SI,DataPtr               </font><font color="#008000"><i>{ resides in memory. }

   </i></font><font color="#FF00FF">MOV DX,[SI]                  </font><font color="#008000"><i>{ Get Width into DL and height to DH }
   </i></font><font color="#FF00FF">INC SI                       </font><font color="#008000"><i>{ Faster than ADD SI,2 - I think }
   </i></font><font color="#FF00FF">INC SI
   CLD                          </font><font color="#008000"><i>{ Make sure writes are descending }

   </i></font><font color="#FF00FF">MOV AH,DL                    </font><font color="#008000"><i>{ Save width in CL }

</i></font><font color="#FF00FF">@Outer:
   MOV DL,AH                    </font><font color="#008000"><i>{ Reload DL }
   </i></font><font color="#FF00FF">MOV DI,BX                    </font><font color="#008000"><i>{ DI = Where to write to }

{ You could use a LODSD, but to be honest it's more trouble than
  it's worth writing the tons of extra code just to save an extra
  clock cycle or two. That is, if it does..
}


</i></font><font color="#FF00FF">@Main:
   LODSB                </font><font color="#008000"><i>{ Read byte from DS:SI }
   </i></font><font color="#FF00FF">OR AL,AL             </font><font color="#008000"><i>{ Is it value 0, meaning transparent ? }
   </i></font><font color="#FF00FF">JZ @NoBlit           </font><font color="#008000"><i>{ Yes, so ignore byte }
   </i></font><font color="#FF00FF">MOV [ES:DI],AL       </font><font color="#008000"><i>{ Otherwise write it to the screen. Don't
                          use STOSB ! }

</i></font><font color="#FF00FF">@NoBlit:
   INC DI
   DEC DL               </font><font color="#008000"><i>{ Reduce horizontal counter }
   </i></font><font color="#FF00FF">JNZ @Main            </font><font color="#008000"><i>{ If not zero then do next byte of the
                          sprite column }

</i></font><font color="#FF00FF">@NextScanLine:
   ADD BX,320           </font><font color="#008000"><i>{ Move down 1 scan line }
   </i></font><font color="#FF00FF">DEC DH               </font><font color="#008000"><i>{ Reduce vertical count }
   </i></font><font color="#FF00FF">JNZ @Outer           </font><font color="#008000"><i>{ If not all lines of sprite done back to @Outer }
   </i></font><font color="#FF00FF">MOV DS,CX            </font><font color="#008000"><i>{ Restore Data Segment }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
This routine writes a shape to the source Bitmap with no Colour 0
transparency, totally overwriting everything &quot;beneath&quot; it.
Also, there is no clipping of Shape. (Use ClipBlock for this
purpose)

Expects  : X and Y specify the horizontal and vertical coordinate
           of the Shape pointed to by DataPtr.

Returns  : Nothing

Corrupts : AX,BX,CL,DX,SI,DI,ES

Notes    : Block is especially useful for &quot;tile&quot; based maps.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>Block<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>word<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,x
   MOV BX,y
   CALL CalculateOffset
   CMP BX,-1                    </font><font color="#008000"><i>{ Off screen ? }
   </i></font><font color="#FF00FF">JZ @StupidUser

   PUSH DS                      </font><font color="#008000"><i>{ Save DS on stack }
   </i></font><font color="#FF00FF">MOV ES,SourceBitmapSegment   </font><font color="#008000"><i>{ ES: BX -&gt; Where sprite written to }

   </i></font><font color="#FF00FF">CLD                          </font><font color="#008000"><i>{ Make sure writes are descending }
   </i></font><font color="#FF00FF">LDS SI,DataPtr               </font><font color="#008000"><i>{ This has to be last access of memory
                                  variable as DS is now altered }
   </i></font><font color="#FF00FF">MOV DX,[SI]                  </font><font color="#008000"><i>{ Get width into DL, height into DH }
   </i></font><font color="#FF00FF">ADD SI,2                     </font><font color="#008000"><i>{ SI now points to sprite data }


</i></font><font color="#FF00FF">@Outer:
   MOV DI,BX                    </font><font color="#008000"><i>{ DI = Offset into VGA screen }
   </i></font><font color="#FF00FF">MOV CL,DL                    </font><font color="#008000"><i>{ CL = Width of sprite }

   </i></font><font color="#FF00FF">CMP CL,4                     </font><font color="#008000"><i>{ Bytes left &lt; 4 ? }
   </i></font><font color="#FF00FF">JB @CantDoLongWordBlit       </font><font color="#008000"><i>{ Yeah, so can't do the 4 byte blit }

   </i></font><font color="#FF00FF">SHR CL,2                     </font><font color="#008000"><i>{ Divide Bytes left by 4 }

</i></font><font color="#FF00FF">@CopyLong:
   DB $66                       </font><font color="#008000"><i>{ Otherwise, store longword to [ES:DI] ! }
   </i></font><font color="#FF00FF">MOVSW
   DEC CL                       </font><font color="#008000"><i>{ CL is long word count }
   </i></font><font color="#FF00FF">JNZ @CopyLong                </font><font color="#008000"><i>{ If CL &lt;&gt; 0 go back to CopyLong }

   </i></font><font color="#FF00FF">MOV CL,DL                    </font><font color="#008000"><i>{ Restore CL }
   </i></font><font color="#FF00FF">AND CL,3
   OR CL,CL
   JZ @NoBytesLeft

@CantDoLongWordBlit:
   CMP CL,2                     </font><font color="#008000"><i>{ Byte count &lt; 2 ? }
   </i></font><font color="#FF00FF">JB @DoByteBlit               </font><font color="#008000"><i>{ Yes, can't do a word blit (Shit !)
                                  so that means that there's only
                                  1 byte left. }

</i></font><font color="#FF00FF">@CopyWord:
   MOVSW                        </font><font color="#008000"><i>{ Otherwise, write word }

</i></font><font color="#FF00FF">@DoByteBlit:
   TEST CL,1                    </font><font color="#008000"><i>{ Is there a byte left ? }
   </i></font><font color="#FF00FF">JZ @NoBytesLeft              </font><font color="#008000"><i>{ No, so no more blits this line }

   </i></font><font color="#FF00FF">MOVSB                        </font><font color="#008000"><i>{ Store the last byte }

</i></font><font color="#FF00FF">@NoBytesLeft:
   ADD BX,320                   </font><font color="#008000"><i>{ Advance BX to next scan line }
   </i></font><font color="#FF00FF">DEC DH                       </font><font color="#008000"><i>{ Reduce Y count }
   </i></font><font color="#FF00FF">JNZ @Outer                   </font><font color="#008000"><i>{ if &lt;&gt;0 then go to Outer }
   </i></font><font color="#FF00FF">POP DS                       </font><font color="#008000"><i>{ Otherwise, restore Data Segment }

</i></font><font color="#FF00FF">@StupidUser:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Perform clipping calculations on an object.

Expects : AX to be an X coordinate for a sprite
          BX to be a Y coordinate
          ES:DI to point to the sprite data

Returns : If no draw can be done, carry is set TRUE.
          Else carry is FALSE and :

          SI will point to first byte to blit
          DI will be the VGA screen offset for first blit
          (ES still is at sprite segment however so must
          be changed afterwards)
          CL is the number of bytes to blit ACROSS
          CH is the number of bytes to blit DOWN
          DX is the MODULO for the image (i.e. how many bytes SI should
          skip (after reload) to get to the start of next row of
          sprite data)

Notes :   Unless you are planning to write extra routines which may
          clip images up to 256 x 256 it is wise to leave this Procedure
          as private to the unit as it is quite complex.
}


</i></font><font color="#FF0000"><b>Procedure </b></font>ClipCalculations<font color="#000080">; </font><font color="#FF0000"><b>Near</b></font><font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">CMP BX,199              </font><font color="#008000"><i>{ Y &gt; 199 ? }
   </i></font><font color="#FF00FF">JG @NoDraw              </font><font color="#008000"><i>{ JG is for SIGNED integers. If Y pos is
                             &gt; 199 then no blit }

   </i></font><font color="#FF00FF">CMP AX,319              </font><font color="#008000"><i>{ X &gt; 319 ? }
   </i></font><font color="#FF00FF">JG @NoDraw              </font><font color="#008000"><i>{ Yes, Do not do any blits at all }

   </i></font><font color="#FF00FF">MOV SI,DI
   INC SI
   INC SI                  </font><font color="#008000"><i>{ Make SI point to actual sprite data }

   </i></font><font color="#FF00FF">XOR CH,CH
   MOV CL,[ES:DI]          </font><font color="#008000"><i>{ CL holds Clipwidth }

   </i></font><font color="#FF00FF">CMP AH,$80              </font><font color="#008000"><i>{ Quick test if X position is negative }
   </i></font><font color="#FF00FF">JB @XNotNegative        </font><font color="#008000"><i>{ If not then check if image is off right hand
                             of screen }
   </i></font><font color="#FF00FF">NEG AX                  </font><font color="#008000"><i>{ Make X position positive }

   </i></font><font color="#FF00FF">CMP AX,CX               </font><font color="#008000"><i>{ If Abs(X) &gt;= Image Width Then Don't Draw }
   </i></font><font color="#FF00FF">JA @NoDraw

   SUB CX,AX               </font><font color="#008000"><i>{ Dec(ClipWidth, Abs(X)) }
   </i></font><font color="#FF00FF">ADD SI,AX               </font><font color="#008000"><i>{ Inc(DataStart, Abs(X)) }
   </i></font><font color="#FF00FF">XOR AX,AX               </font><font color="#008000"><i>{ Set X to 0 }
   </i></font><font color="#FF00FF">JMP @NowDoY             </font><font color="#008000"><i>{ Do Y portion of data now. }


</i></font><font color="#FF00FF">@XNotNegative:
   MOV DX,CX               </font><font color="#008000"><i>{ Set DX to clipwidth }
   </i></font><font color="#FF00FF">ADD DX,AX               </font><font color="#008000"><i>{ If X + ClipWidth &lt; 320 Then }
   </i></font><font color="#FF00FF">CMP DX,320
   JB @NowDoY              </font><font color="#008000"><i>{ Do Y part (No need to clip width) }
   </i></font><font color="#FF00FF">MOV CX,320
   SUB CX,AX               </font><font color="#008000"><i>{ ClipWidth = 320 - X }


{
At this point:

AX is the X position of the Shape
BX is the Y position of the Shape
CL is the clipped width of the Shape.

Now it is time to do the height part and set the result in
CH.
}

</i></font><font color="#FF00FF">@NowDoY:
   XOR DH,DH               </font><font color="#008000"><i>{ Make DX the height of image }
   </i></font><font color="#FF00FF">MOV DL,[ES:DI+1]
   MOV CH,DL               </font><font color="#008000"><i>{ Set CH also to height for main blit routine }

   </i></font><font color="#FF00FF">CMP BH,$80              </font><font color="#008000"><i>{ Quick test if Y position is negative }
   </i></font><font color="#FF00FF">JB @YNotNegative

   NEG BX                  </font><font color="#008000"><i>{ Make Y a positive number }

   </i></font><font color="#FF00FF">CMP BX,DX               </font><font color="#008000"><i>{ If Y &gt; ClipHeight }
   </i></font><font color="#FF00FF">JA @NoDraw
   SUB DX,BX               </font><font color="#008000"><i>{ Dec(ClipHeight, Abs(Y) ) }
   </i></font><font color="#FF00FF">MOV CH,DL               </font><font color="#008000"><i>{ As an image can only be 255 bytes high
                             this works fine.. }
   </i></font><font color="#FF00FF">PUSH AX                 </font><font color="#008000"><i>{ Save X Coord on stack }
   </i></font><font color="#FF00FF">XOR AH,AH
   MOV AL,[ES:DI]          </font><font color="#008000"><i>{ AX = Width }
   </i></font><font color="#FF00FF">MUL BX                  </font><font color="#008000"><i>{ Calculate Y * Width }
   </i></font><font color="#FF00FF">ADD SI,AX               </font><font color="#008000"><i>{ Inc(DataStart, Abs(Y) * Width ) }
   </i></font><font color="#FF00FF">POP AX
   XOR BX,BX               </font><font color="#008000"><i>{ Set Y to 0 }
   </i></font><font color="#FF00FF">JMP @NowDoBlit          </font><font color="#008000"><i>{ NOW do the blit work. Whew! }



</i></font><font color="#FF00FF">@YNotNegative:
   ADD DX,BX               </font><font color="#008000"><i>{ If Y + ClipHeight &gt; 199 Then }
   </i></font><font color="#FF00FF">CMP DX,200
   JB @NowDoBlit
   MOV DX,200
   SUB DX,BX               </font><font color="#008000"><i>{ ClipHeight = 200 - Y }
   </i></font><font color="#FF00FF">MOV CH,DL


</font><font color="#008000"><i>{
At this point AX is the X position
              BX is the Y position
              CL is the ClipWidth and
              CH is the ClipHeight.

As the width/height of an Shape can only be an 8 bit
quantity (i.e. &lt; 256) I can discard the H portions of
the registers. Whew!

Now follows some weird code.. I'm going to make :

DX = Modulo for datastart (which is the width in bytes of Shape.
And yes, I do know that Width could be held in DL but adding extra
code just to satisfy you optimisation junkies is v. boring.)

DS:SI already points to data
ES:DI points to active (source) Bitmap

}

</i></font><font color="#FF00FF">@NowDoBlit:
   PUSH CX                     </font><font color="#008000"><i>{ Save ClipWidth &amp; ClipHeight on stack }
   </i></font><font color="#FF00FF">CALL CalculateOffset        </font><font color="#008000"><i>{ Use AX and BX to calculate screen
                                 offset. On exit BX is offset }
   </i></font><font color="#FF00FF">POP CX                      </font><font color="#008000"><i>{ Restore ClipWidth and ClipHeight }

   </i></font><font color="#FF00FF">XOR DH,DH
   MOV DL,[ES:DI]              </font><font color="#008000"><i>{ DX = Modulo }
   </i></font><font color="#FF00FF">MOV DI,BX                   </font><font color="#008000"><i>{ Ahhh. Now DI points to the screen offset }
   </i></font><font color="#FF00FF">CLC
   JMP @</font><font color="#FF0000"><b>End

</b></font><font color="#000080">@</font>NoDraw<font color="#000080">:
   </font>STC                         <font color="#008000"><i>{ Indicate no blit possible }

</i></font><font color="#000080">@</font><font color="#FF0000"><b>End</b></font><font color="#000080">:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
This routine does the same as Blit but takes into account
the fact that the sprite may be off the edges of the
screen.

Its quite a bit slower than the normal Blit, but that's only
to be expected as there's more computations to be
done.

Expects  : X, Y specify the horizontal and vertical position of the Shape,
          DataPtr points to the data to blit.

Returns  : Nothing

Corrupts : BX,CX,DX,SI,DI,ES.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>ClipBlit<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,X
   MOV BX,Y
   LES DI,DataPtr
   CALL ClipCalculations
   JC @NoDraw

   PUSH DS
   PUSH BP

   MOV AX,SourceBitmapSegment
   MOV BX,ES
   MOV DS,BX                   </font><font color="#008000"><i>{ Now DS: SI points to correct space }
   </i></font><font color="#FF00FF">MOV ES,AX

   MOV BX,SI                   </font><font color="#008000"><i>{ BX to be used to reload SI }
   </i></font><font color="#FF00FF">MOV BP,DI                   </font><font color="#008000"><i>{ And the screen modulo }

   </i></font><font color="#FF00FF">MOV AH,CL                   </font><font color="#008000"><i>{ AH = Width }
   </i></font><font color="#FF00FF">CLD                         </font><font color="#008000"><i>{ Make sure LODSB works OK }

</i></font><font color="#FF00FF">@Outer:
   MOV CL,AH                   </font><font color="#008000"><i>{ Re-load CL }
   </i></font><font color="#FF00FF">MOV SI,BX                   </font><font color="#008000"><i>{ And SI with address of next sprite row }
   </i></font><font color="#FF00FF">MOV DI,BP                   </font><font color="#008000"><i>{ And DI with address of next scan line }


</i></font><font color="#FF00FF">@WriteByte:
   LODSB                       </font><font color="#008000"><i>{ Read byte from DS:SI }
   </i></font><font color="#FF00FF">OR AL,AL                    </font><font color="#008000"><i>{ Is byte 0 (transparent) ? }
   </i></font><font color="#FF00FF">JZ @NoBlit                  </font><font color="#008000"><i>{ yes, so don't blit }
   </i></font><font color="#FF00FF">MOV [ES:DI],AL              </font><font color="#008000"><i>{ Otherwise store byte }

</i></font><font color="#FF00FF">@NoBlit:
   INC DI                       </font><font color="#008000"><i>{ Move DI to next pos. on screen }
   </i></font><font color="#FF00FF">DEC CL                       </font><font color="#008000"><i>{ Reduce shape width count }
   </i></font><font color="#FF00FF">JNZ @WriteByte               </font><font color="#008000"><i>{ If not zero, end of shape not reached }

   </i></font><font color="#FF00FF">ADD BX,DX                    </font><font color="#008000"><i>{ BX = BX + Modulo, so BX now points
                                  to first byte of next sprite line
                                  to blit }
   </i></font><font color="#FF00FF">ADD BP,320                   </font><font color="#008000"><i>{ Make BP point to next line. Note :
                                  If you are going to add some extra
                                  stuff here make sure you're not
                                  accessing local variables! }


   </i></font><font color="#FF00FF">DEC CH
   JNZ @Outer

   POP BP
   POP DS
@NoDraw:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
This routine does the same as Block except that it takes into account
that the shape object may be off screen.

Expects  : Same as Block.

Returns  : Nothing

Corrupts : AX,BX,CX,DX,SI,DI,ES are corrupt on exit.
}



</i></font><font color="#FF0000"><b>Procedure </b></font>ClipBlock<font color="#000080">(</font>x<font color="#000080">,</font>y<font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,X
   MOV BX,Y
   LES DI,DataPtr          </font><font color="#008000"><i>{ ES:DI points to data }
   </i></font><font color="#FF00FF">CALL ClipCalculations
   JC @NoDraw


</font><font color="#008000"><i>{
Prepare for blit !
}

   </i></font><font color="#FF00FF">PUSH DS
   PUSH BP

   MOV AX,SourceBitmapSegment
   MOV BX,ES
   MOV DS,BX                   </font><font color="#008000"><i>{ Now DS: SI points to correct space }
   </i></font><font color="#FF00FF">MOV ES,AX

   MOV BX,SI                   </font><font color="#008000"><i>{ BX to be used to reload SI (+Image Width) }
   </i></font><font color="#FF00FF">MOV BP,DI                   </font><font color="#008000"><i>{ And BP to reload DI (+Screen Width) }

   </i></font><font color="#FF00FF">CLD                         </font><font color="#008000"><i>{ Make sure LODSB works OK }

</i></font><font color="#FF00FF">@Outer:
   PUSH CX
   MOV CH,CL                   </font><font color="#008000"><i>{ CH is set to ClipWidth }

   </i></font><font color="#FF00FF">MOV SI,BX
   MOV DI,BP

   CMP CH,4                     </font><font color="#008000"><i>{ Bytes left &lt; 4 ? }
   </i></font><font color="#FF00FF">JB @CantDoLongWordBlit       </font><font color="#008000"><i>{ Yeah, so can't do the 4 byte blit }

   </i></font><font color="#FF00FF">SHR CH,2                     </font><font color="#008000"><i>{ Divide Bytes left by 4 }

</i></font><font color="#FF00FF">@CopyLong:
   DB $66                       </font><font color="#008000"><i>{ Otherwise, store longword to [ES:DI] ! }
   </i></font><font color="#FF00FF">MOVSW
   DEC CH                       </font><font color="#008000"><i>{ Reduce long word count }
   </i></font><font color="#FF00FF">JNZ @CopyLong

   MOV CH,CL                    </font><font color="#008000"><i>{ Restore CL }
   </i></font><font color="#FF00FF">AND CH,3
   OR CH,CH
   JZ @NoBytesLeft



@CantDoLongWordBlit:
   CMP CH,2                     </font><font color="#008000"><i>{ Byte count &lt; 2 ? }
   </i></font><font color="#FF00FF">JB @CheckDoByteBlit          </font><font color="#008000"><i>{ Yes, can't do a word blit (Shit !)
                                  so that means that there's only
                                  1 byte left. }
</i></font><font color="#FF00FF">@CopyWord:
   MOVSW                        </font><font color="#008000"><i>{ Otherwise, write word }


</i></font><font color="#FF00FF">@CheckDoByteBlit:
   TEST CH,1                    </font><font color="#008000"><i>{ Is there a byte left ? }
   </i></font><font color="#FF00FF">JZ @NoBytesLeft              </font><font color="#008000"><i>{ No, so no more blits this line }

</i></font><font color="#FF00FF">@DoByteBlit:
   MOVSB                        </font><font color="#008000"><i>{ Store the last byte }

</i></font><font color="#FF00FF">@NoBytesLeft:
   ADD BX,DX                    </font><font color="#008000"><i>{ BP to next byte of image to read }
   </i></font><font color="#FF00FF">ADD BP,320                   </font><font color="#008000"><i>{ Advance BX to next scan line }

   </i></font><font color="#FF00FF">POP CX
   DEC CH                       </font><font color="#008000"><i>{ Reduce Y count }
   </i></font><font color="#FF00FF">JNZ @Outer                   </font><font color="#008000"><i>{ if &lt;&gt;0 then go to Outer }

   </i></font><font color="#FF00FF">POP BP                       </font><font color="#008000"><i>{ Restore base pointer and }
   </i></font><font color="#FF00FF">POP DS                       </font><font color="#008000"><i>{ Data Segment }

</i></font><font color="#FF00FF">@NoDraw:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;







</font><font color="#008000"><i>{
Grab a rectangular area of bytes from the screen for use
as a shape object.

Expects     : X1,Y1 define the TOP LEFT of the area to grab.
              X2,Y2 define the BOTTOM RIGHT of the area.

              X1 MUST be less than X2;
              Similarly, Y1 MUST be less than Y2.

              Also, it is NOT possible to grab an image that
              is more than 255 pixels wide and 200 pixels
              high.

Returns     : Nothing

Notes       : Use the ShapeSize Function to calculate
              bytes needed to hold shape object in memory .

Corrupts    : AX,BX,CX,DX,SI,DI,ES

}

</i></font><font color="#FF0000"><b>Procedure </b></font>GetAShape<font color="#000080">(</font>x1<font color="#000080">,</font>y1<font color="#000080">,</font>x2<font color="#000080">,</font>y2<font color="#000080">:</font>word<font color="#000080">;</font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,x1
   MOV BX,y1
   CALL CalculateOffset
   CMP BX,-1
   JZ @StupidUser

   MOV AX,x2                    </font><font color="#008000"><i>{ Width = (X2 - X1) +1 }
   </i></font><font color="#FF00FF">SUB AX,x1
   INC AX                       </font><font color="#008000"><i>{ Take into account extra pixel }
   </i></font><font color="#FF00FF">MOV DL,AL

   MOV AX,y2                    </font><font color="#008000"><i>{ Height = (Y2 - Y1) +1 }
   </i></font><font color="#FF00FF">SUB AX,y1
   INC AX
   MOV DH,AL

   LES DI,DataPtr
   MOV [ES:DI],DX               </font><font color="#008000"><i>{ Store Width &amp; Height }
   </i></font><font color="#FF00FF">ADD DI,2

   PUSH DS
   MOV DS,SourceBitmapSegment
   CLD                          </font><font color="#008000"><i>{ Make sure writes are descending }


</i></font><font color="#FF00FF">@Outer:
   MOV SI,BX                    </font><font color="#008000"><i>{ SI = Offset into VGA screen }
   </i></font><font color="#FF00FF">MOV CL,DL                    </font><font color="#008000"><i>{ CL = Width of sprite held in DL }

   </i></font><font color="#FF00FF">CMP CL,4                     </font><font color="#008000"><i>{ Bytes left &lt; 4 ? }
   </i></font><font color="#FF00FF">JB @CantDoLongWordBlit       </font><font color="#008000"><i>{ Yeah, so can't do the 4 byte blit }

   </i></font><font color="#FF00FF">SHR CL,2                     </font><font color="#008000"><i>{ Divide Count by 4 }

</i></font><font color="#FF00FF">@CopyLong:
   DB $66                       </font><font color="#008000"><i>{ Otherwise, store longword to [ES:EDI] ! }
   </i></font><font color="#FF00FF">MOVSW
   DEC CL                       </font><font color="#008000"><i>{ CL is long word count }
   </i></font><font color="#FF00FF">JNZ @CopyLong                </font><font color="#008000"><i>{ If CL &lt;&gt; 0 go back to CopyLong }

   </i></font><font color="#FF00FF">MOV CL,DL                    </font><font color="#008000"><i>{ Restore CL to width of Shape }

</i></font><font color="#FF00FF">@CantDoLongWordBlit:
   AND CL,3
   OR CL,CL                     </font><font color="#008000"><i>{ Any bytes left ? }
   </i></font><font color="#FF00FF">JZ @NoBytesLeft

   CMP CL,2                     </font><font color="#008000"><i>{ Byte count &lt; 2 ? }
   </i></font><font color="#FF00FF">JB @DoByteBlit               </font><font color="#008000"><i>{ Yes, can't do a word blit (Shit !)
                                  so that means that there's only
                                  1 byte left. }

</i></font><font color="#FF00FF">@CopyWord:
   MOVSW                        </font><font color="#008000"><i>{ Otherwise, write word }
   </i></font><font color="#FF00FF">TEST CL,1
   JZ @NoBytesLeft              </font><font color="#008000"><i>{ No, so no more blits this line }


</i></font><font color="#FF00FF">@DoByteBlit:
   MOVSB                        </font><font color="#008000"><i>{ Store the last byte }

</i></font><font color="#FF00FF">@NoBytesLeft:
   ADD BX,320                   </font><font color="#008000"><i>{ Advance BX to next scan line }
   </i></font><font color="#FF00FF">DEC DH                       </font><font color="#008000"><i>{ Reduce Y count }
   </i></font><font color="#FF00FF">JNZ @Outer                   </font><font color="#008000"><i>{ if &lt;&gt;0 then go to Outer }

   </i></font><font color="#FF00FF">POP DS                       </font><font color="#008000"><i>{ Otherwise, restore Data Segment }

</i></font><font color="#FF00FF">@StupidUser:
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
This routine checks if the data contained within a Shape will
&quot;Collide&quot; with the background. (Background data is held within
the Source Bitmap)

This command is very useful for games that need accurate
Shape to background collision detection.

Expects : X and Y specify the horizontal and vertical position
          of a shape pointed to by DataPtr.

Returns : If the Shape has collided with ANY background (represented
          by colours 1-255) on the SOURCE Bitmap then BlitColl is TRUE.

Corrupts : AX,BX,CX,DX,SI,DI,ES
}

</i></font><font color="#FF0000"><b>Function </b></font>BlitColl<font color="#000080">(</font>x<font color="#000080">,</font>y <font color="#000080">:</font>integer<font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>dataptr<font color="#000080">) : </font>boolean<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV AX,x
   MOV BX,y
   CALL CalculateOffset         </font><font color="#008000"><i>{ On exit, BX will hold screen &quot;Offset&quot; }

   </i></font><font color="#FF00FF">MOV ES,SourceBitmapSegment

   PUSH DS
   PUSH BP
   LDS SI,DataPtr


   MOV DX,[SI]             </font><font color="#008000"><i>{ DL= Width, DH = Height }
   </i></font><font color="#FF00FF">INC SI
   INC SI                  </font><font color="#008000"><i>{ Make SI point to sprite data }

   </i></font><font color="#FF00FF">CLD                     </font><font color="#008000"><i>{ Make sure writes are descending }

   </i></font><font color="#FF00FF">MOV CL,DL

@Outer:
   MOV DI,BX               </font><font color="#008000"><i>{ DI = Offset into Source Bitmap }
   </i></font><font color="#FF00FF">MOV DL,CL

</font><font color="#008000"><i>{ Check if any long words can be checked }

   </i></font><font color="#FF00FF">CMP DL,4                </font><font color="#008000"><i>{ Is width at least 4 bytes ? }
   </i></font><font color="#FF00FF">JB @CantCheckLong       </font><font color="#008000"><i>{ No }
   </i></font><font color="#FF00FF">SHR DL,2                </font><font color="#008000"><i>{ Otherwise, divide width by 4 so that
                             DL will hold number of LONGs to check }


</i></font><font color="#FF00FF">@CheckLong:
   DB $66; LODSW           </font><font color="#008000"><i>{ LODSD : Load EAX from DS:SI }
   </i></font><font color="#FF00FF">DB $66; OR AX,AX        </font><font color="#008000"><i>{ OR EAX,EAX }
   </i></font><font color="#FF00FF">JZ @NoCheckBackLong     </font><font color="#008000"><i>{ If EAX is zero then no point in checking
                             background is there ? }

   </i></font><font color="#FF00FF">DB $66
   MOV BP,AX               </font><font color="#008000"><i>{ Make a copy of EAX }
   </i></font><font color="#FF00FF">DB $66
   XOR AX,[ES:DI]          </font><font color="#008000"><i>{ XOR EAX, [ES:DI]  (Xor EAX with Background) }
   </i></font><font color="#FF00FF">DB $66
   CMP BP,AX               </font><font color="#008000"><i>{ Is EAX unaffected by the XOR - i.e.
                             No collision }
   </i></font><font color="#FF00FF">JNZ @CollisionOccurred


@NoCheckBackLong:
   ADD DI,4                </font><font color="#008000"><i>{ Bump DI to next long word }
   </i></font><font color="#FF00FF">DEC DL                  </font><font color="#008000"><i>{ Reduce long word count }
   </i></font><font color="#FF00FF">JNZ @CheckLong          </font><font color="#008000"><i>{ And now do the collision check for long word }



   </i></font><font color="#FF00FF">MOV DL,CL               </font><font color="#008000"><i>{ Restore DL to it's previous contents }
   </i></font><font color="#FF00FF">AND DL,3                </font><font color="#008000"><i>{ Mask out all but bits 0 &amp; 1 }


{ Any words left to be checked ? }

</i></font><font color="#FF00FF">@CantCheckLong:
   CMP DL,2                </font><font color="#008000"><i>{ Is there at least 2 bytes left to move ? }
   </i></font><font color="#FF00FF">JB @CantCheckWord       </font><font color="#008000"><i>{ No }

</i></font><font color="#FF00FF">@CheckWord:
   LODSW                   </font><font color="#008000"><i>{ Read word from DS:SI into AX }
   </i></font><font color="#FF00FF">OR AX,AX                </font><font color="#008000"><i>{ Is Shape data non zero ? }
   </i></font><font color="#FF00FF">JZ @CantCheckWord       </font><font color="#008000"><i>{ Yes, so can't be a collision }

   </i></font><font color="#FF00FF">MOV BP,AX
   XOR AX,[ES:DI]          </font><font color="#008000"><i>{ Otherwise, check background too }
   </i></font><font color="#FF00FF">CMP BP,AX               </font><font color="#008000"><i>{ Is AX different ? }
   </i></font><font color="#FF00FF">JNZ @CollisionOccurred  </font><font color="#008000"><i>{ Yes, so this means a collision }
   </i></font><font color="#FF00FF">ADD DI,2                </font><font color="#008000"><i>{ Otherwise add 1 byte }

</i></font><font color="#FF00FF">@CantCheckWord:
   TEST CL,1               </font><font color="#008000"><i>{ Is there a single byte left to check }
   </i></font><font color="#FF00FF">JZ @AllChecksDone       </font><font color="#008000"><i>{ Nope }
   </i></font><font color="#FF00FF">LODSB                   </font><font color="#008000"><i>{ Otherwise, read it }
   </i></font><font color="#FF00FF">OR AL,AL                </font><font color="#008000"><i>{ Zero ? }
   </i></font><font color="#FF00FF">JZ @AllChecksDone       </font><font color="#008000"><i>{ Yes, so basically no more checks to do }

   </i></font><font color="#FF00FF">MOV CH,AL
   XOR AL,[ES:DI]          </font><font color="#008000"><i>{ No, so check background byte }
   </i></font><font color="#FF00FF">CMP CH,AL               </font><font color="#008000"><i>{ Is AL different ? }
   </i></font><font color="#FF00FF">JNZ @CollisionOccurred  </font><font color="#008000"><i>{ Yes, so a collision has occurred }


</i></font><font color="#FF00FF">@AllChecksDone:
   ADD BX,320              </font><font color="#008000"><i>{ 320 is the number of bytes in one scan-line }
   </i></font><font color="#FF00FF">DEC DH                  </font><font color="#008000"><i>{ Reduce vertical count (Counts from height of Shape) }
   </i></font><font color="#FF00FF">JNZ @Outer              </font><font color="#008000"><i>{ If &lt;&gt;0 then check for next line of Shape }
   </i></font><font color="#FF00FF">MOV AL,False            </font><font color="#008000"><i>{ If all lines have been done then this means
                             that no collision has occurred }

   </i></font><font color="#FF00FF">JMP @Exit               </font><font color="#008000"><i>{ And exit. Don't insert a RET here -
                             you'll crash the program ! }

</i></font><font color="#FF00FF">@CollisionOccurred:
   MOV AL,True             </font><font color="#008000"><i>{ This part is only reached if a collision has
                             occurred. }

</i></font><font color="#FF00FF">@Exit:
   POP BP                 </font><font color="#008000"><i>{ Restore Base Pointer }
   </i></font><font color="#FF00FF">POP DS                 </font><font color="#008000"><i>{ Restore data segment }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
De-allocate memory for an Shape.

Expects  : DataPtr is an Shape pointer.

Returns  : A crash if you're not careful !! :-(

Corrupts : The assembler part uses AX,DI and ES. Don't know about
           the Pascal part however.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>FreeShape<font color="#000080">(</font>DataPtr<font color="#000080">:</font>pointer<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>ImWidth<font color="#000080">,
    </font>ImHeight<font color="#000080">: </font>byte<font color="#000080">;
</font><font color="#FF0000"><b>Begin
     Asm
     </b></font><font color="#FF00FF">LES DI,DataPtr
     MOV AX,[ES:DI]
     MOV ImWidth,AL
     MOV ImHeight,AH
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
     </font>FreeMem<font color="#000080">(</font>DataPtr<font color="#000080">,</font>ExtShapeSize<font color="#000080">(</font>ImWidth<font color="#000080">,</font>ImHeight<font color="#000080">));
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Load in a .IMG file from disk.

WARNING! This is NOT the IMG file type used by some paint packages!
It is a non-standard file (albeit very simple) format that NEWGRAPH
writes, so trying to load a shape created from a paint package
etc. will not work.


Expects  :  FileName to be a valid MS-DOS path.
            DataPtr to be a valid pointer to where data will be stored.

Returns  :  Nothing, although sprite may have loaded into memory.

Corrupts :  Don't know.

}

</i></font><font color="#FF0000"><b>Procedure </b></font>LoadShape<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>String</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>DataPtr<font color="#000080">: </font>Pointer<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>F<font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
    </font>DestSeg<font color="#000080">,
    </font>DestOffset<font color="#000080">,
    </font>ImgSize<font color="#000080">: </font>word<font color="#000080">;
    </font>ShapeWidth<font color="#000080">,
    </font>ShapeHeight<font color="#000080">: </font>byte<font color="#000080">;

</font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>F<font color="#000080">,</font>FileName<font color="#000080">);
     </font>Reset<font color="#000080">(</font>F<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>BlockRead<font color="#000080">(</font>F<font color="#000080">,</font>ShapeWidth<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);       </font><font color="#008000"><i>{ Read in width &amp; height }
     </i></font>BlockRead<font color="#000080">(</font>F<font color="#000080">,</font>ShapeHeight<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);


     </font><font color="#008000"><i>{
     Calculate number of bytes that need to be reserved for the
     Shape.
     }

     </i></font>ImgSize<font color="#000080">:= </font>ExtShapeSize<font color="#000080">(</font>ShapeWidth<font color="#000080">,</font>ShapeHeight<font color="#000080">);
     </font><font color="#FF0000"><b>If </b></font>ImgSize <font color="#000080">&lt; </font>MaxAvail <font color="#FF0000"><b>Then
        Begin

        </b></font>GetMem<font color="#000080">(</font>DataPtr<font color="#000080">,</font>ImgSize<font color="#000080">);
        </font>GetPtrData<font color="#000080">(</font>DataPtr<font color="#000080">,</font>DestSeg<font color="#000080">,</font>DestOffset<font color="#000080">);

        </font>Reset<font color="#000080">(</font>F<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
        </font>BlockRead<font color="#000080">(</font>F<font color="#000080">,</font>Mem<font color="#000080">[</font>DestSeg<font color="#000080">:</font>DestOffset<font color="#000080">], </font>ImgSize<font color="#000080">);
        </font>Close<font color="#000080">(</font>F<font color="#000080">);
        </font><font color="#FF0000"><b>End
     Else
         Asm
         </b></font><font color="#FF00FF">DB $66
         MOV WORD [OFFSET DataPtr],0         </font><font color="#008000"><i>{ Signal no memory claimed }
         </i></font><font color="#FF00FF">DW 0
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

</font><font color="#FF0000"><b>End</b></font><font color="#000080">;








</font><font color="#008000"><i>{
Write an Shape to disk, where you could convert it if you like
to a PCX. With the reg. version, there is a command to do this.

Expects :  FileName is a standard DOS filename.
           P is a pointer to where the sprite data exists in memory.

Returns :  Nothing.

Corrupts : Don't know.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>SaveShape<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font>DataPtr<font color="#000080">:</font>Pointer<font color="#000080">);
</font><font color="#FF0000"><b>Var </b></font>F<font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;
    </font>SourceSeg<font color="#000080">, </font>SourceOffset<font color="#000080">: </font>word<font color="#000080">;
</font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>F<font color="#000080">,</font>FileName<font color="#000080">);
     </font>Rewrite<font color="#000080">(</font>F<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font>GetPtrData<font color="#000080">(</font>DataPtr<font color="#000080">,</font>SourceSeg<font color="#000080">,</font>SourceOffset<font color="#000080">);

     </font>BlockWrite<font color="#000080">(</font>F<font color="#000080">, </font>Mem<font color="#000080">[</font>SourceSeg<font color="#000080">:</font>SourceOffset<font color="#000080">],
                   </font>ExtShapeSize<font color="#000080">(</font>mem<font color="#000080">[</font>SourceSeg<font color="#000080">:</font>SourceOffset<font color="#000080">],
                   </font>mem<font color="#000080">[</font>SourceSeg<font color="#000080">:</font>SourceOffset<font color="#000080">+</font><font color="#800000">1</font><font color="#000080">]));
     </font>Close<font color="#000080">(</font>F<font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;









</font><font color="#008000"><i>{
***************************************
PCX LOAD AND SAVE ROUTINES - WHICH WORK
***************************************
}



{
This will put a mode 13h 256 colour PCX at position X,Y and
show a defined area. Useful for low res multimedia applications. :-)
This PCX loader can handle PCX's of variable dimensions up to
width 320 and height 200 so you could design sprites
with a graphics package and save them as a PCX then grab them
off the screen as Shapes. Also, this PCX loader is far faster than
Norman Yen's effort and intelligently uses memory. (Note: How can
a program dumbly use memory? Hmm?)

Expects: Filename is an MS-DOS filespec relating to the PCX's name,
         i.e. 'C:\WORK\SHEEP.PCX' (Oh well explained Scott :^( )
         ThePalette is a PaletteType record used to hold the PCX's
         palette data.
         X,Y specifies the top left coordinates on screen of where
         the PCX is to be drawn. X should be in the range of 0 to
         319, Y should be in the range of 0 to 199. The picture
         will be clipped as necessary.

Returns: Your program will halt with an error message if the PCX file
         does not exist, or if the PCX is not of the correct &quot;type&quot;.
         (I.E. It's not mode 13h or it's not 256 colour etc.).
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LocatePCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">;
          </font>x<font color="#000080">,</font>y<font color="#000080">,</font>widthtoshow<font color="#000080">,</font>heighttoshow<font color="#000080">:</font>word<font color="#000080">);

</font><font color="#FF0000"><b>var </b></font>PCXFile<font color="#000080">: </font><font color="#FF0000"><b>file</b></font><font color="#000080">;

    </font>ReadingFromMem  <font color="#000080">: </font>Boolean<font color="#000080">;      </font><font color="#008000"><i>{ If True it means All/Some PCX
                                      Data is in RAM }
    </i></font>MemRequired     <font color="#000080">: </font>longint<font color="#000080">;      </font><font color="#008000"><i>{ Size of PCX bitmap data }
    </i></font>BytesRead       <font color="#000080">: </font>longint<font color="#000080">;      </font><font color="#008000"><i>{ Number of PCX bytes read }
    </i></font>PCXFileSize     <font color="#000080">: </font>longint<font color="#000080">;      </font><font color="#008000"><i>{ How many bytes PCX uses }
    </i></font>Count           <font color="#000080">: </font>integer<font color="#000080">;      </font><font color="#008000"><i>{ I is a general counter used to set
                                      the PCX's palette and then count
                                      scan lines }
    </i></font>RedVal          <font color="#000080">: </font>byte<font color="#000080">;         </font><font color="#008000"><i>{ Used for ColourMap, Palette values }
    </i></font>GreenVal        <font color="#000080">: </font>byte<font color="#000080">;         </font><font color="#008000"><i>{ which define a colour }
    </i></font>BlueVal         <font color="#000080">: </font>byte<font color="#000080">;

    </font>MemoryAccessVar <font color="#000080">: </font>pointer<font color="#000080">;      </font><font color="#008000"><i>{ Pointer to read bitmap data }
    </i></font>BufferSeg<font color="#000080">,                      </font><font color="#008000"><i>{ Where PCX will be loaded to }
    </i></font>BufferOffset    <font color="#000080">: </font>word<font color="#000080">;

    </font>VidOffset       <font color="#000080">: </font>word<font color="#000080">;         </font><font color="#008000"><i>{ Screen offset }

    </i></font>Width<font color="#000080">,</font>Height<font color="#000080">,                   </font><font color="#008000"><i>{ Width is number of horizontal bytes to grab
                                      Height is number of vertical bytes to grab }
    </i></font>N<font color="#000080">,</font>Bytes             <font color="#000080">: </font>word<font color="#000080">;     </font><font color="#008000"><i>{ N counts up to Bytes }
    </i></font>RunLength<font color="#000080">,</font>c     <font color="#000080">: </font>byte<font color="#000080">;         </font><font color="#008000"><i>{ RunLength is the Run Length Encoding
                                      byte, C is the character read from
                                      PCX data }
    </i></font>PastHorizontalLimit <font color="#000080">: </font>boolean<font color="#000080">;  </font><font color="#008000"><i>{ Set true this means no more
                                     horizontal pixel writes to do, advance 
                                     to next line as soon as poss.}

</i></font><font color="#FF0000"><b>begin
    </b></font>assign<font color="#000080">(</font>PCXFile<font color="#000080">,</font>FileName<font color="#000080">);

</font><font color="#008000"><i>{$i-}
    </i></font>reset <font color="#000080">(</font>PCXFile<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
</font><font color="#008000"><i>{$i+}
    </i></font><font color="#FF0000"><b>If </b></font>IOResult <font color="#000080">= </font><font color="#800000">0 </font><font color="#FF0000"><b>Then
       Begin

       </b></font>blockread <font color="#000080">(</font>PCXFile<font color="#000080">, </font>header<font color="#000080">, </font>sizeof <font color="#000080">(</font>header<font color="#000080">));       </font><font color="#008000"><i>{ Read in PCX header }

       </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>header<font color="#000080">.</font>manufacturer<font color="#000080">=</font><font color="#800000">10</font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>header<font color="#000080">.</font>version<font color="#000080">=</font><font color="#800000">5</font><font color="#000080">) </font><font color="#FF0000"><b>and
          </b></font><font color="#000080">(</font>header<font color="#000080">.</font>bits_per_pixel<font color="#000080">=</font><font color="#800000">8</font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>header<font color="#000080">.</font>colour_planes<font color="#000080">=</font><font color="#800000">1</font><font color="#000080">) </font><font color="#FF0000"><b>then
          begin
               </b></font>seek <font color="#000080">(</font>PCXFile<font color="#000080">, </font>filesize <font color="#000080">(</font>PCXFile<font color="#000080">)-</font><font color="#800000">769</font><font color="#000080">);     </font><font color="#008000"><i>{ Move to palette data }
               </i></font>blockread <font color="#000080">(</font>PCXFile<font color="#000080">, </font>c<font color="#000080">, </font><font color="#800000">1</font><font color="#000080">);                  </font><font color="#008000"><i>{ Read Colourmap type }
               </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>c<font color="#000080">=</font><font color="#800000">12</font><font color="#000080">) </font><font color="#FF0000"><b>then                              </b></font><font color="#008000"><i>{ 12 is correct type }
               </i></font><font color="#FF0000"><b>begin
                    </b></font><font color="#008000"><i>{
                    Read palette data and write to palette
                    structure.
                    }

                    </i></font><font color="#FF0000"><b>for </b></font>Count<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#800000">255 </font><font color="#FF0000"><b>do
                        Begin
                          </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>RedVal<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
                          </font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>GreenVal<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
                          </font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>BlueVal<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

                          </font>ThePalette<font color="#000080">.</font>RedLevel<font color="#000080">[</font>Count<font color="#000080">]:=</font>RedVal <font color="#FF0000"><b>SHR </b></font><font color="#800000">2</font><font color="#000080">;
                          </font>ThePalette<font color="#000080">.</font>GreenLevel<font color="#000080">[</font>Count<font color="#000080">]:=</font>GreenVal <font color="#FF0000"><b>SHR </b></font><font color="#800000">2</font><font color="#000080">;
                          </font>ThePalette<font color="#000080">.</font>BlueLevel<font color="#000080">[</font>Count<font color="#000080">]:=</font>BlueVal <font color="#FF0000"><b>SHR </b></font><font color="#800000">2</font><font color="#000080">;
                      </font><font color="#FF0000"><b>End</b></font><font color="#000080">;


                  </font>seek <font color="#000080">(</font>PCXFile<font color="#000080">, </font><font color="#800000">128</font><font color="#000080">);

                  </font><font color="#008000"><i>{
                  If entire size of PCX is less than 64K in length then
                  it can be stored in a memory buffer and uncompacted
                  from there. However, if PCX exceeds 64K then it must
                  be split into several chunks. If your machine does
                  not have 64K left for the buffer used (You're in trouble !!)
                  then the system will read the PCX from disk continually,
                  which works OK but is very slow. So there.
                  }

                  </i></font>MemRequired<font color="#000080">:=</font>Filesize<font color="#000080">(</font>PCXFile<font color="#000080">)-</font><font color="#800000">897</font><font color="#000080">;
                  </font>PCXFileSize<font color="#000080">:=</font>MemRequired<font color="#000080">;
                  </font>BytesRead<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;

                  </font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>MemRequired <font color="#000080">&lt; </font><font color="#800000">65528</font><font color="#000080">) </font><font color="#FF0000"><b>And </b></font><font color="#000080">(</font>MaxAvail <font color="#000080">&gt; </font>MemRequired<font color="#000080">) </font><font color="#FF0000"><b>Then
                     Begin
                     </b></font>getmem<font color="#000080">(</font>MemoryAccessVar<font color="#000080">,</font>MemRequired<font color="#000080">);
                     </font>GetPtrData<font color="#000080">(</font>MemoryAccessVar<font color="#000080">, </font>BufferSeg<font color="#000080">, </font>BufferOffset<font color="#000080">);
                     </font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font>BufferOffset<font color="#000080">],</font>MemRequired<font color="#000080">);
                     </font>ReadingFromMem<font color="#000080">:=</font>True<font color="#000080">;
                     </font><font color="#FF0000"><b>End
                  Else

                  </b></font><font color="#008000"><i>{
                  If the PCX occupies more than approx. 64K bytes then it
                  is necessary to read the data into memory in 64K chunks
                  which is still considerably faster than the
                  final method (continual reading from disk)
                  }

                      </i></font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>MaxAvail <font color="#000080">&gt; </font><font color="#800000">65527</font><font color="#000080">) </font><font color="#FF0000"><b>Then
                         Begin
                         </b></font>GetMem<font color="#000080">(</font>MemoryAccessVar<font color="#000080">,</font><font color="#800000">65528</font><font color="#000080">);
                         </font>GetPtrData<font color="#000080">(</font>MemoryAccessVar<font color="#000080">, </font>BufferSeg<font color="#000080">, </font>BufferOffset<font color="#000080">);
                         </font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font>BufferOffset<font color="#000080">],</font><font color="#800000">65528</font><font color="#000080">);
                         </font>BytesRead<font color="#000080">:=</font><font color="#800000">65528</font><font color="#000080">;
                         </font>MemRequired<font color="#000080">:=</font><font color="#800000">65528</font><font color="#000080">;
                         </font>ReadingFromMem<font color="#000080">:=</font>True<font color="#000080">;
                         </font><font color="#FF0000"><b>End
                      Else
                          </b></font><font color="#008000"><i>{ CLUCK!! Oh well, system is just going to have
                          to read from disk as there is not even 64K
                          memory left. (A very bad situation) }

                          </i></font>ReadingFromMem<font color="#000080">:=</font>False<font color="#000080">;

                  </font><font color="#008000"><i>{
                  Find out width &amp; height of PCX.
                  }

                  </i></font>width<font color="#000080">:=(</font>header<font color="#000080">.</font>xmax <font color="#000080">- </font>header<font color="#000080">.</font>xmin<font color="#000080">)+</font><font color="#800000">1</font><font color="#000080">;
                  </font>height<font color="#000080">:=(</font>header<font color="#000080">.</font>ymax <font color="#000080">- </font>header<font color="#000080">.</font>ymin<font color="#000080">)+</font><font color="#800000">1</font><font color="#000080">;
                  </font>bytes<font color="#000080">:=</font>header<font color="#000080">.</font>bytes_per_line<font color="#000080">;

                  </font><font color="#008000"><i>{
                  Adjust width &amp; height of PCX if necessary so that PCX
                  &quot;fits&quot; on screen.

                  }

                  </i></font><font color="#FF0000"><b>if </b></font>widthtoshow <font color="#000080">&gt; </font>width <font color="#FF0000"><b>Then
                     </b></font>widthtoshow<font color="#000080">:=</font>width<font color="#000080">;

                  </font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>widthtoshow <font color="#000080">+ </font>x<font color="#000080">) &gt; </font><font color="#800000">320 </font><font color="#FF0000"><b>Then
                     </b></font>widthtoshow<font color="#000080">:=</font>width<font color="#000080">-</font>x<font color="#000080">;

                  </font><font color="#FF0000"><b>if </b></font>heighttoshow <font color="#000080">&gt; </font>height <font color="#FF0000"><b>Then
                     </b></font>heighttoshow<font color="#000080">:=</font>height<font color="#000080">;

                  </font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>heighttoshow <font color="#000080">+ </font>y<font color="#000080">)&gt; </font><font color="#800000">200 </font><font color="#FF0000"><b>Then
                     </b></font>heighttoshow<font color="#000080">:=</font>height<font color="#000080">-</font>y<font color="#000080">;


                  </font><font color="#008000"><i>{
                  Do all scan lines.
                  }

                  </i></font><font color="#FF0000"><b>for </b></font>Count<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#000080">(</font>heighttoshow<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">) </font><font color="#FF0000"><b>do
                  begin
                      </b></font>n<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
                      </font>PastHorizontalLimit<font color="#000080">:=</font>False<font color="#000080">;
                      </font>vidoffset<font color="#000080">:= </font>SourceBitmapOffset<font color="#000080">+((</font>Y<font color="#000080">+</font>Count<font color="#000080">)* </font><font color="#800000">320</font><font color="#000080">)+</font>X<font color="#000080">;

                      </font><font color="#FF0000"><b>while </b></font><font color="#000080">(</font>n<font color="#000080">&lt;</font>bytes<font color="#000080">) </font><font color="#FF0000"><b>do
                      begin

                           </b></font><font color="#008000"><i>{ Display any more pixels width wise from PCX ? }

                           </i></font><font color="#FF0000"><b>If </b></font>N <font color="#000080">&gt;= </font>WidthToShow <font color="#FF0000"><b>Then
                              </b></font>PastHorizontalLimit<font color="#000080">:=</font>True<font color="#000080">;

                           </font><font color="#FF0000"><b>If </b></font>ReadingFromMem <font color="#FF0000"><b>Then
                               Begin
                               </b></font>c<font color="#000080">:=</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font>BufferOffset<font color="#000080">];
                               </font>Inc<font color="#000080">(</font>BufferOffset<font color="#000080">);
                               </font><font color="#FF0000"><b>If </b></font>BufferOffset <font color="#000080">= </font><font color="#800000">65528 </font><font color="#FF0000"><b>Then
                                  Begin
                                  </b></font><font color="#008000"><i>{ End of buffer has been reached, so
                                    it's time to load another part of the
                                    PCX }

                                  </i></font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>PCXFileSize <font color="#000080">- </font>BytesRead<font color="#000080">)&gt; </font><font color="#800000">65527 </font><font color="#FF0000"><b>Then
                                     Begin
                                     </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font><font color="#800000">0</font><font color="#000080">],</font><font color="#800000">65528</font><font color="#000080">);
                                     </font>Inc<font color="#000080">(</font>BytesRead<font color="#000080">,</font><font color="#800000">65528</font><font color="#000080">);
                                     </font><font color="#FF0000"><b>End
                                  Else
                                      </b></font><font color="#008000"><i>{ Load last chunk of PCX }

                                      </i></font><font color="#FF0000"><b>Begin
                                      </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font><font color="#800000">0</font><font color="#000080">],
                                      (</font>PCXFileSize <font color="#000080">- </font>BytesRead<font color="#000080">));
                                      </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

                                  </font><font color="#008000"><i>{
                                  Now reset buffer pointer to start
                                  }

                                  </i></font>BufferOffset<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
                                  </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
                               </font><font color="#FF0000"><b>End
                            Else
                                </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>c<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

</font><font color="#008000"><i>{
At this point one element of data has been read, and stored in
variable C. If bits 6 &amp; 7 of C are set then this means to the system
a &quot;run of bytes&quot; has been found. (i.e. a number sequence - for example,
four 1's, twenty 15's, any sequence of identical numbers).

In this case, the 6 least significant bits of C indicate how long the run
of bytes is. For example, if a sequence of five bytes has been found
the run = 5. Of course, using 6 bits limits you to a maximum run length
of 63 bytes but that should be more than enough for most pictures.

Quite a simple method of compaction eh? Definitely the easiest format to
understand!

}

                            </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">((</font>c <font color="#FF0000"><b>and </b></font><font color="#800000">192</font><font color="#000080">)=</font><font color="#800000">192</font><font color="#000080">) </font><font color="#FF0000"><b>then
                            begin

                               </b></font><font color="#008000"><i>{ Get the 6 least significant bits }
                               </i></font>RunLength<font color="#000080">:=</font>c <font color="#FF0000"><b>and </b></font><font color="#800000">63</font><font color="#000080">;

                               </font><font color="#008000"><i>{ get the run byte }

                               </i></font><font color="#FF0000"><b>If </b></font>ReadingFromMem <font color="#FF0000"><b>Then
                                  Begin
                                  </b></font>c<font color="#000080">:=</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font>BufferOffset<font color="#000080">];
                                  </font>Inc<font color="#000080">(</font>BufferOffset<font color="#000080">);

                               </font><font color="#008000"><i>{ Time to read in more data from disk ? }

                                  </i></font><font color="#FF0000"><b>If </b></font>BufferOffset <font color="#000080">= </font><font color="#800000">65528 </font><font color="#FF0000"><b>Then
                                     Begin
                                     If </b></font><font color="#000080">(</font>PCXFileSize <font color="#000080">- </font>BytesRead<font color="#000080">)&gt; </font><font color="#800000">65527 </font><font color="#FF0000"><b>Then
                                        Begin
                                        </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font><font color="#800000">0</font><font color="#000080">],</font><font color="#800000">65528</font><font color="#000080">);
                                        </font>Inc<font color="#000080">(</font>BytesRead<font color="#000080">,</font><font color="#800000">65528</font><font color="#000080">);
                                        </font><font color="#FF0000"><b>End
                                     Else
                                         Begin
                                         </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>Mem<font color="#000080">[</font>BufferSeg<font color="#000080">:</font><font color="#800000">0</font><font color="#000080">],
                                         (</font>PCXFileSize <font color="#000080">- </font>BytesRead<font color="#000080">));
                                     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

                                     </font>BufferOffset<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
                                     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
                                  </font><font color="#FF0000"><b>End
                               Else
                                   </b></font>BlockRead<font color="#000080">(</font>PCXFile<font color="#000080">,</font>c<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

                               </font><font color="#008000"><i>{
                               Can't do blit if past the horizontal limit
                               of the window.
                               }

                               </i></font><font color="#FF0000"><b>If Not </b></font>PastHorizontalLimit <font color="#FF0000"><b>Then
                                  Begin
                                  If </b></font>n<font color="#000080">+</font>RunLength <font color="#000080">&gt; </font>widthtoshow <font color="#FF0000"><b>Then
                                     </b></font>fillchar<font color="#000080">(</font>Mem<font color="#000080">[</font>SourceBitmapSegment<font color="#000080">:</font>VidOffset<font color="#000080">],</font>WidthToShow<font color="#000080">-</font>n<font color="#000080">,</font>c<font color="#000080">)
                                  </font><font color="#FF0000"><b>else
                                      </b></font>fillchar<font color="#000080">(</font>Mem<font color="#000080">[</font>SourceBitmapSegment<font color="#000080">:</font>VidOffset<font color="#000080">],</font>RunLength<font color="#000080">,</font>c<font color="#000080">);

                                  </font>inc<font color="#000080">(</font>vidoffset<font color="#000080">,</font>RunLength<font color="#000080">);
                               </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

                               </font>inc<font color="#000080">(</font>n<font color="#000080">,</font>RunLength<font color="#000080">);
                               </font><font color="#FF0000"><b>end
                            else
                                begin
                                If Not </b></font>PastHorizontalLimit <font color="#FF0000"><b>Then
                                   Begin
                                   </b></font>mem <font color="#000080">[</font>SourceBitmapSegment<font color="#000080">:</font>vidoffset<font color="#000080">]:=</font>c<font color="#000080">;
                                   </font>inc <font color="#000080">(</font>vidoffset<font color="#000080">);
                                </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
                                </font>inc <font color="#000080">(</font>n<font color="#000080">);
                            </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

                      </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

                  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;

                  </font><font color="#FF0000"><b>If </b></font>ReadingFromMem <font color="#FF0000"><b>Then
                     </b></font>freemem<font color="#000080">(</font>MemoryAccessVar<font color="#000080">,</font>MemRequired<font color="#000080">);
               </font><font color="#FF0000"><b>end
          else
              Begin
              </b></font>DirectVideo<font color="#000080">:=</font>False<font color="#000080">;
              </font>Writeln<font color="#000080">(</font><font color="#800000">'The PCX''s ColourMap is not of the correct type !'</font><font color="#000080">);
              </font>Close<font color="#000080">(</font>PCXFile<font color="#000080">);
              </font>Halt<font color="#000080">(</font><font color="#800000">0</font><font color="#000080">);
              </font><font color="#FF0000"><b>End</b></font><font color="#000080">;
          </font><font color="#FF0000"><b>end
       Else
           Begin
           </b></font>DirectVideo<font color="#000080">:=</font>False<font color="#000080">;
           </font>Writeln<font color="#000080">(</font><font color="#800000">'PCX unsuitable for loading.'</font><font color="#000080">);
           </font>Close<font color="#000080">(</font>PCXFile<font color="#000080">);
           </font>Halt<font color="#000080">(</font><font color="#800000">0</font><font color="#000080">);
       </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

       </font>close <font color="#000080">(</font>PCXFile<font color="#000080">);  </font><font color="#008000"><i>{ Do this anyway ! }

       </i></font><font color="#FF0000"><b>end
    Else
        Begin
        </b></font>DirectVideo<font color="#000080">:=</font>False<font color="#000080">;
        </font>Writeln<font color="#000080">(</font><font color="#800000">'File not found ?'</font><font color="#000080">);
        </font>Close<font color="#000080">(</font>PCXFile<font color="#000080">);
        </font>Halt<font color="#000080">(</font><font color="#800000">0</font><font color="#000080">);
        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

</font><font color="#FF0000"><b>end</b></font><font color="#000080">;













</font><font color="#008000"><i>{
What this does is load a PCX at the TOP LEFT of the source Bitmap,
very quickly. If you need to put the PCX somewhere else use LocatePCX.


Expects:  FileName to be a standard MS-DOS filename, relating to a
          320 x 200 PCX.
          ThePalette to be of type Palette. This holds the colour
          information of the PCX file you are loading.

You can then use SetAllPalette to set the VGA palette so that
the pic can display properly.
}

</i></font><font color="#FF0000"><b>Procedure </b></font>LoadPCX<font color="#000080">(</font>FileName<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">; </font><font color="#FF0000"><b>Var </b></font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Begin
     </b></font>LocatePCX<font color="#000080">(</font>Filename<font color="#000080">,</font>ThePalette<font color="#000080">,</font><font color="#800000">0</font><font color="#000080">,</font><font color="#800000">0</font><font color="#000080">,</font><font color="#800000">320</font><font color="#000080">,</font><font color="#800000">200</font><font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Home grown PCX packer.

This PCX routine is able to cope with the full 256 colours,
unlike some other SWAG PCX packers I could mention.. !

Expects:    FileName is the name of the PCX to save.
            ThePalette is a PaletteType variable, which has been
            initialised by, for example, the GetAllPalette routine.
            X,Y specify the horizontal and vertical positions of where to
            begin grabbing the PCX data from.
            PCXWidth and PCXHeight specify the width &amp; height of the
            window to grab. Easy eh?

            For example, to grab one half of the VGA screen you could use:
            SaveAreaAsPCX('1STHALF.PCX',MyPalette,0,0,160,200);

            And the other half with :

            SaveAreaAsPCX('2NDHALF.PCX',MyPalette,160,0,160,200);

            These files can then be loaded into a paint package such
            as PC Paintbrush or Neopaint (great program!) and manipulated.

            Use the SAVEPCX routine below to save an entire PCX screen.


Returns:    Program will halt if the PCX is not found.


P.S. This routine manages to save a 256 colour screen properly,
     unlike some other PCX writing routines I could mention. Do you
     programmers actually TEST your code before sending it into the
     SWAG ? (Like, are there any GIF loaders that work ?!!)
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SaveAreaAsPCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">;</font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">;
          </font>x<font color="#000080">,</font>y<font color="#000080">, </font>PCXWidth<font color="#000080">,</font>PCXHeight<font color="#000080">: </font>word<font color="#000080">);

</font><font color="#FF0000"><b>Var </b></font>f<font color="#000080">: </font><font color="#FF0000"><b>File</b></font><font color="#000080">;                    </font><font color="#008000"><i>{ File for writing PCX to }
    </i></font>ColourMapID<font color="#000080">: </font>byte<font color="#000080">;           </font><font color="#008000"><i>{ Always holds 12, for the PCX }
    </i></font>ColourCount<font color="#000080">: </font>byte<font color="#000080">;           </font><font color="#008000"><i>{ Counts up to number of colours on
                                  screen (255) }
    </i></font>RedValue<font color="#000080">: </font>byte<font color="#000080">;             </font><font color="#008000"><i>{ Palette Values of a colour }
    </i></font>GreenValue<font color="#000080">: </font>byte<font color="#000080">;
    </font>BlueValue<font color="#000080">: </font>byte<font color="#000080">;

    </font>LastOffset<font color="#000080">: </font>word<font color="#000080">;           </font><font color="#008000"><i>{ Used as a latch for VidOffset }
    </i></font>VidOffset<font color="#000080">: </font>word<font color="#000080">;            </font><font color="#008000"><i>{ Offset into Source Bitmap }
    </i></font>VerticalCount<font color="#000080">: </font>byte<font color="#000080">;        </font><font color="#008000"><i>{ Number of scan lines to use }
    </i></font>LastByte <font color="#000080">: </font>byte<font color="#000080">;            </font><font color="#008000"><i>{ The last byte read from Source Bitmap }
    </i></font>NewByte<font color="#000080">: </font>byte<font color="#000080">;              </font><font color="#008000"><i>{ The current byte }
    </i></font>RunLength <font color="#000080">: </font>byte<font color="#000080">;           </font><font color="#008000"><i>{ Counter for run length compression }
    </i></font>ByteCount<font color="#000080">: </font>word<font color="#000080">;            </font><font color="#008000"><i>{ Counts up to bytes per scan line (320) }



</i></font><font color="#FF0000"><b>Begin
     </b></font>Assign<font color="#000080">(</font>f<font color="#000080">,</font>filename<font color="#000080">);
     </font>Rewrite<font color="#000080">(</font>f<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

     </font><font color="#FF0000"><b>With </b></font>header <font color="#FF0000"><b>do
     Begin
          </b></font>Manufacturer <font color="#000080">:= </font><font color="#800000">10</font><font color="#000080">;
          </font>Version <font color="#000080">:= </font><font color="#800000">5</font><font color="#000080">;
          </font>Encoding <font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
          </font>Bits_per_pixel<font color="#000080">:=</font><font color="#800000">8</font><font color="#000080">;    </font><font color="#008000"><i>{ 8 bits = 256 colours }
          </i></font>XMin<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
          </font>YMin<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;

          </font><font color="#008000"><i>{
          Can't save a PCX more than 320 x 200 in size.
          }

          </i></font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>PCXwidth <font color="#000080">+ </font>x<font color="#000080">) &gt; </font><font color="#800000">320 </font><font color="#FF0000"><b>Then
             </b></font>PCXwidth<font color="#000080">:=</font><font color="#800000">320</font><font color="#000080">-</font>x<font color="#000080">;
          </font><font color="#FF0000"><b>if </b></font><font color="#000080">(</font>PCXheight<font color="#000080">+ </font>y<font color="#000080">) &gt; </font><font color="#800000">200 </font><font color="#FF0000"><b>Then
             </b></font>PCXheight<font color="#000080">:=</font><font color="#800000">200</font><font color="#000080">-</font>y<font color="#000080">;

          </font>XMax<font color="#000080">:=(</font>PCXWidth<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);
          </font>YMax<font color="#000080">:=(</font>PCXHeight<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);
          </font>Hres<font color="#000080">:=</font><font color="#800000">320</font><font color="#000080">;                        </font><font color="#008000"><i>{ Hres/Vres could be used to
                                              determine screen mode -
                                              probably :-( }
          </i></font>VRes<font color="#000080">:=</font><font color="#800000">200</font><font color="#000080">;

          </font>Colour_planes<font color="#000080">:=</font><font color="#800000">1</font><font color="#000080">;                 </font><font color="#008000"><i>{ Mode 13h is not planar }
          </i></font>Bytes_per_line<font color="#000080">:=</font>PCXWidth<font color="#000080">;         </font><font color="#008000"><i>{ One byte per pixel }
          </i></font>Palette_type<font color="#000080">:=</font><font color="#800000">12</font><font color="#000080">;                 </font><font color="#008000"><i>{ Dunno what 12 is for }
     </i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font>BlockWrite<font color="#000080">(</font>F<font color="#000080">,</font>Header<font color="#000080">,</font>SizeOf<font color="#000080">(</font>Header<font color="#000080">));

     </font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV AX,X
     MOV BX,Y
     CALL CalculateOffset
     MOV VidOffset,BX
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#FF0000"><b>For </b></font>VerticalCount<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font>PCXHeight<font color="#000080">-</font><font color="#800000">1 </font><font color="#FF0000"><b>do
     Begin
          </b></font>LastOffset<font color="#000080">:=</font>VidOffset<font color="#000080">;
          </font>ByteCount<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
          </font>LastByte<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;

          </font><font color="#FF0000"><b>Repeat
                </b></font>NewByte<font color="#000080">:=</font>Mem<font color="#000080">[</font>SourceBitmapSegment<font color="#000080">:</font>Vidoffset<font color="#000080">];

                </font><font color="#008000"><i>{
                If the last byte read is equal to the new byte read
                then a run of bytes has been identified and so the
                system needs to count how many identical bytes (up
                to a total of 63) follow. When finished, the
                system writes this count to disk PLUS a value of
                192 (which is the signal to the PCX reader that
                a run of bytes follows) then writes the byte that
                was prevalent in the run.

                For example, say in the data stream there were 10
                values :

                0 1 2 6 9 8 7 7 7 4

                When the system gets to 8 it would then compare
                that number with the next value (7) and see that 8 is
                not equal to 7, then the computer would move to said 7
                (after the 8) and compare it to the next digit, which
                is also a 7.

                As a match has been found, the system counts the
                number of 7s there, which is (all together now !)
                3!! and then adds 192 to the result.. to give 195.

                As stated before, bits 6 + 7 of the byte have
                been set in order to &quot;flag&quot; to the PCX reader that
                a run of bytes have been found.

                The value 195 is written to disk, then value 7 so the
                PCX reader that loads this file knows what value (and
                how many times) to write to the screen during unpacking.

                I hope this has explained one of the PCX mysteries. If
                it hasn't I typed all that for nothing!! :-)
                }

                </i></font><font color="#FF0000"><b>If </b></font>NewByte <font color="#000080">= </font>LastByte <font color="#FF0000"><b>Then
                   Begin

                   </b></font>RunLength<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">;
                   </font><font color="#FF0000"><b>While </b></font><font color="#000080">(</font>NewByte <font color="#000080">= </font>LastByte<font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>RunLength <font color="#000080">&lt; </font><font color="#800000">63</font><font color="#000080">)
                      </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>ByteCount <font color="#000080">&lt;&gt; </font>PCXWidth<font color="#000080">) </font><font color="#FF0000"><b>do
                      Begin
                      </b></font>Inc<font color="#000080">(</font>RunLength<font color="#000080">);
                      </font>Inc<font color="#000080">(</font>ByteCount<font color="#000080">);

                      </font><font color="#008000"><i>{
                      Move to next byte on Source Bitmap
                      }

                      </i></font>Inc<font color="#000080">(</font>vidoffset<font color="#000080">);

                      </font>NewByte<font color="#000080">:=</font>Mem<font color="#000080">[</font>SourceBitmapSegment<font color="#000080">:</font>Vidoffset<font color="#000080">];
                   </font><font color="#FF0000"><b>End</b></font><font color="#000080">;


                   </font><font color="#FF0000"><b>Asm
                   </b></font><font color="#FF00FF">OR Byte Ptr RunLength, 192
                   </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

                   </font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>RunLength<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
                   </font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>LastByte<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

                   </font>LastByte<font color="#000080">:=</font>NewByte<font color="#000080">;
                   </font><font color="#FF0000"><b>End
                Else

                </b></font><font color="#008000"><i>{ How to deal with colours &gt; 191. }
                    </i></font><font color="#FF0000"><b>If </b></font><font color="#000080">(</font>NewByte <font color="#000080">&gt; </font><font color="#800000">191</font><font color="#000080">) </font><font color="#FF0000"><b>Then
                       Begin
                       </b></font>Inc<font color="#000080">(</font>ByteCount<font color="#000080">);
                       </font>Inc<font color="#000080">(</font>VidOffset<font color="#000080">);                </font><font color="#008000"><i>{ Point to next byte on screen }
                       </i></font>RunLength<font color="#000080">:=</font><font color="#800000">193</font><font color="#000080">;
                       </font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>RunLength<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);     </font><font color="#008000"><i>{ Write run length byte of 1  ! }
                       </i></font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>NewByte<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);       </font><font color="#008000"><i>{ The ONLY way to get round }
                       </i></font>LastByte<font color="#000080">:=</font>NewByte<font color="#000080">;
                       </font><font color="#FF0000"><b>End
                    Else
                        Begin
                        </b></font>Inc<font color="#000080">(</font>ByteCount<font color="#000080">);
                        </font>Inc<font color="#000080">(</font>vidoffset<font color="#000080">);
                        </font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>NewByte<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
                        </font>LastByte<font color="#000080">:=</font>NewByte<font color="#000080">;
                        </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

          </font><font color="#FF0000"><b>Until </b></font>ByteCount <font color="#000080">= </font>PCXWidth<font color="#000080">;

          </font>VidOffset<font color="#000080">:=</font>LastOffset<font color="#000080">+</font><font color="#800000">320</font><font color="#000080">;
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font><font color="#008000"><i>{
     12 is Colourmap ID.
     }

     </i></font>ColourMapID<font color="#000080">:=</font><font color="#800000">12</font><font color="#000080">;
     </font>BlockWrite<font color="#000080">(</font>f<font color="#000080">,</font>ColourMapID<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);

     </font><font color="#008000"><i>{
     Now write Palette R,G,B values to disk. The only reason
     I didn't implement :

     BlockWrite(F,Palette,SizeOf(Palette))

     was that all the palette entries had to be shifted LEFT
     twice (To represent a 16.7 million colour palette..) 
     
                                DAMN!
     }

     </i></font><font color="#FF0000"><b>For </b></font>ColourCount<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>to </b></font><font color="#800000">255 </font><font color="#FF0000"><b>do
         Begin

         </b></font>RedValue<font color="#000080">:=</font>ThePalette<font color="#000080">.   </font>RedLevel<font color="#000080">[</font>ColourCount<font color="#000080">] </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">;
         </font>GreenValue<font color="#000080">:=</font>ThePalette<font color="#000080">. </font>GreenLevel<font color="#000080">[</font>ColourCount<font color="#000080">] </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">;
         </font>BlueValue<font color="#000080">:=</font>ThePalette<font color="#000080">.  </font>BlueLevel<font color="#000080">[</font>ColourCount<font color="#000080">] </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">;

         </font>BlockWrite<font color="#000080">(</font>F<font color="#000080">,</font>RedValue<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
         </font>BlockWrite<font color="#000080">(</font>F<font color="#000080">,</font>GreenValue<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
         </font>BlockWrite<font color="#000080">(</font>F<font color="#000080">,</font>BlueValue<font color="#000080">,</font><font color="#800000">1</font><font color="#000080">);
     </font><font color="#FF0000"><b>End</b></font><font color="#000080">;

     </font>Close<font color="#000080">(</font>F<font color="#000080">);         </font><font color="#008000"><i>{ That's it - it's not over, not over yet .. :-) }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Save a PCX file to disk.

Expects  :  Filename is the MS-DOS filespec , i.e. &quot;C:\PICS\MYFILE.PCX&quot;
           ThePalette specifies a PaletteType record to save to disk in
           the PCX file.

Returns  :  Nothing

Corrupts :  Don't know !!
}


</i></font><font color="#FF0000"><b>Procedure </b></font>SavePCX<font color="#000080">(</font>filename<font color="#000080">:</font><font color="#FF0000"><b>string</b></font><font color="#000080">;</font>ThePalette<font color="#000080">: </font>PaletteType<font color="#000080">);
</font><font color="#FF0000"><b>Begin
     </b></font>SaveAreaAsPCX<font color="#000080">(</font>filename<font color="#000080">,</font>ThePalette<font color="#000080">,</font><font color="#800000">0</font><font color="#000080">,</font><font color="#800000">0</font><font color="#000080">,</font><font color="#800000">320</font><font color="#000080">,</font><font color="#800000">200</font><font color="#000080">);
</font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
**********************
MISCELLANEOUS ROUTINES
**********************
}

{
Wait for a certain number of vertical retraces, specified by
the number in TimeOut. (A vertical retrace occurs when the
monitor begins to draw the screen; If you wait for this
retrace and then update the screen your graphics will not
flicker - well not as much as before ;-) )


Corrupts AL,CX,DX
}


</i></font><font color="#FF0000"><b>Procedure </b></font>Vwait<font color="#000080">(</font>TimeOut<font color="#000080">:</font>word<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
         </b></font><font color="#FF00FF">MOV CX,TimeOut         </font><font color="#008000"><i>{ CX = Number of times to wait }

         </i></font><font color="#FF00FF">MOV DX,$3DA            </font><font color="#008000"><i>{ Port $3DA holds vertical &amp; horizontal
                                  retrace status bits }
</i></font><font color="#FF00FF">@WaitEnd:
         IN AL,DX               </font><font color="#008000"><i>{ Read port }
         </i></font><font color="#FF00FF">TEST AL,8              </font><font color="#008000"><i>{ Test for bit 3 being set: If
                                  it is then that means the system may
                                  be in the middle of it's refresh
                                  and so writing to the screen now may
                                  cause flicker. }
         </i></font><font color="#FF00FF">JNZ @WaitEnd           </font><font color="#008000"><i>{ If set, go back to @waitend }

{
When the routine gets to here it's the end of the retrace.
}

</i></font><font color="#FF00FF">@WaitStart:
         IN AL,DX               </font><font color="#008000"><i>{ Read port again }
         </i></font><font color="#FF00FF">TEST AL,8              </font><font color="#008000"><i>{ Is the bit set ? }
         </i></font><font color="#FF00FF">JZ @WaitStart          </font><font color="#008000"><i>{ No ! So go back }

         </i></font><font color="#FF00FF">DEC CX
         JNZ @WaitEnd          </font><font color="#008000"><i>{ Reduce count in CX, if &lt;&gt;0 go back
                                  to WaitEnd ! }

</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;






</font><font color="#008000"><i>{
Clear the Source Bitmap with Colour 0 (Always).

Expects : SourceBitmapSegment, SourceBitmapOffset to point to the source
          Bitmap (of course).

Returns : Nothing.

Corrupts : AX,CX,DI,ES


}

</i></font><font color="#FF0000"><b>Procedure </b></font>Cls<font color="#000080">; </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
     </b></font><font color="#FF00FF">MOV ES,SourceBitmapSegment
     MOV DI,SourceBitmapOffset

     MOV CX,4000         </font><font color="#008000"><i>{ 4000 x 16 byte moves are executed }
     </i></font><font color="#FF00FF">DB $66
     XOR AX,AX           </font><font color="#008000"><i>{ XOR EAX,EAX - Colour 0 used to clear screen }

</i></font><font color="#FF00FF">@ClearLoop:
     DB $66; STOSW       </font><font color="#008000"><i>{ STOSD }
     </i></font><font color="#FF00FF">DB $66; STOSW
     DB $66; STOSW
     DB $66; STOSW
     DEC CX
     JNZ @ClearLoop

</font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
Clear the screen with the graphics colour specified.

Expects : CurrentColour set to non-zero value
          Source Bitmap initialised with Bitmap

Returns : Nothing

Corrupts : AX,BX,CX,DI,ES
}

</i></font><font color="#FF0000"><b>Procedure </b></font>CCls<font color="#000080">(</font>TheColour <font color="#000080">: </font>byte<font color="#000080">); </font><font color="#FF0000"><b>Assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>Asm
   </b></font><font color="#FF00FF">MOV ES,SourceBitmapSegment
   MOV DI,SourceBitmapOffset

   MOV CX,4000
   MOV AH,TheColour
   MOV AL,AH
   MOV BX,AX

   DB $66; SHL AX,16            </font><font color="#008000"><i>{ SHL EAX,16 -&gt; Move AH &amp; AL into
                                  upper word of EAX}
   </i></font><font color="#FF00FF">MOV AX,BX                    </font><font color="#008000"><i>{ Now EAX is fully set }

</i></font><font color="#FF00FF">@FillLoop:
   DB $66; STOSW                </font><font color="#008000"><i>{ STOSD }
   </i></font><font color="#FF00FF">DB $66; STOSW
   DB $66; STOSW
   DB $66; STOSW
   DEC CX
   JNZ @FillLoop                </font><font color="#008000"><i>{ You could use LOOP but I heard this
                                  method is faster }
</i></font><font color="#FF0000"><b>End</b></font><font color="#000080">;





</font><font color="#008000"><i>{
This is the initialisation part of the unit.
}

</i></font><font color="#FF0000"><b>Begin
     </b></font>SetSourceBitmapAddr<font color="#000080">(</font><font color="#800000">$a000</font><font color="#000080">,</font><font color="#800000">0</font><font color="#000080">);
     </font>DoubleBufferOff<font color="#000080">;
     </font>Cls<font color="#000080">;                            </font><font color="#008000"><i>{ Flush video mem }
     </i></font>MoveTo<font color="#000080">(</font><font color="#800000">0</font><font color="#000080">,</font><font color="#800000">0</font><font color="#000080">);                    </font><font color="#008000"><i>{ Graphics Cursor to top left }
     </i></font>SetColour<font color="#000080">(</font><font color="#800000">1</font><font color="#000080">);                   </font><font color="#008000"><i>{ Use Colour 1 }
     </i></font>UseFont<font color="#000080">(</font>Font8x8<font color="#000080">);               </font><font color="#008000"><i>{ standard 8 x 8 }

     </i></font>Writeln<font color="#000080">(</font><font color="#800000">'NewGraph unit (C) 1995, 1996 Scott Tunstall. All rights'</font><font color="#000080">);
     </font>Writeln<font color="#000080">(</font><font color="#800000">'reserved. Unauthorised editing/duplication of this code'</font><font color="#000080">);
     </font>Writeln<font color="#000080">(</font><font color="#800000">'is PROHIBITED.'</font><font color="#000080">);
     </font>Writeln<font color="#000080">;

</font><font color="#FF0000"><b>End</b></font><font color="#000080">.  </font><font color="#008000"><i>{ of unit }</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to GRAPHICS SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0222.PAS">Original</a><b>]</b></p></body>
</html>
