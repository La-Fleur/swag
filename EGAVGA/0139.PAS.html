<html>
<head><title> "ANIVGA Updates" by KAI ROHRBACHER</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to EGAVGA SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0139.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#008000"><i>{
&gt; Would you please repost code of:
&gt; &quot;the SpriteWidth, SpriteHeight, SpriteWidthExact, and flipping functions
&gt; you posted here quite a while ago&quot; ?
  Scanning  through  my database resulted in the following 2 snippets of
  code  for  AniVGA V1.2 (again: it's only a quick-'n-dirty hack, use on
  your  own  risk,  no  support,  no guarantees that the next version of
  AniVGA will have these routines!):
}
{for the INTERFACE-section:}
 </i></font><font color="#FF0000"><b>FUNCTION </b></font>SpriteHeight<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
 </font><font color="#FF0000"><b>FUNCTION </b></font>SpriteWidth<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
 </font><font color="#FF0000"><b>FUNCTION </b></font>SpriteWidthExact<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
 </font><font color="#FF0000"><b>PROCEDURE </b></font>ExchangeColor<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">; </font>oldColor<font color="#000080">,</font>newColor<font color="#000080">:</font>BYTE<font color="#000080">);
 </font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteVertical<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">);

</font><font color="#008000"><i>{for the IMPLEMENTATION-section:}
</i></font><font color="#FF0000"><b>FUNCTION </b></font>SpriteHeight<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, dessen Hoehe ermittelt werden soll}
{out: Die Hoehe des Sprites in Zeilen oder 0, wenn gar kein Sprite geladen}
</i></font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">:</font>WORD<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">=</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN </b></font>SpriteHeight<font color="#000080">:=</font><font color="#800000">0  </font><font color="#008000"><i>{Sprite noch nicht geladen}
  </i></font><font color="#FF0000"><b>ELSE </b></font>SpriteHeight<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Hoehe<font color="#000080">]
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>FUNCTION </b></font>SpriteWidth<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, dessen Breite ermittelt werden soll}
{out: Die Breite des Sprites in Zeilen oder 0, wenn gar kein Sprite geladen}
{rem: Der ermittelte Wert kann um bis zu 3 Punkte zu gross sein}
</i></font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">:</font>WORD<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">=</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN </b></font>SpriteWidth<font color="#000080">:=</font><font color="#800000">0  </font><font color="#008000"><i>{Sprite noch nicht geladen}
  </i></font><font color="#FF0000"><b>ELSE </b></font>SpriteWidth<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Breite<font color="#000080">] </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">2
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>FUNCTION </b></font>SpriteWidthExact<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">):</font>WORD<font color="#000080">;
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, dessen Breite ermittelt werden soll}
{out: Die Breite des Sprites in Zeilen oder 0, wenn gar kein Sprite geladen}
{rem: Der ermittelte Wert ist exakt, allerdings dauert die Routine etwas}
{     laenger als SpriteWidth() }
</i></font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">,</font>i<font color="#000080">,</font>temp<font color="#000080">,</font>planeOFS<font color="#000080">:</font>WORD<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">=</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN </b></font>SpriteWidthExact<font color="#000080">:=</font><font color="#800000">0  </font><font color="#008000"><i>{Sprite noch nicht geladen}
  </i></font><font color="#FF0000"><b>ELSE BEGIN
        </b></font>temp<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">; </font>planeOFS<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Right<font color="#000080">];
        </font><font color="#FF0000"><b>FOR </b></font>i<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Hoehe<font color="#000080">]-</font><font color="#800000">1 </font><font color="#FF0000"><b>DO
         BEGIN
          IF </b></font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>planeOFS<font color="#000080">]&gt;</font>temp
           <font color="#FF0000"><b>THEN </b></font>temp<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>planeOFS<font color="#000080">];
          </font>INC<font color="#000080">(</font>planeOFS<font color="#000080">,</font><font color="#800000">2</font><font color="#000080">)
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
        </font>SpriteWidthExact<font color="#000080">:=</font>temp<font color="#000080">+</font><font color="#800000">1
       </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>ExchangeColor<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">; </font>oldColor<font color="#000080">,</font>newColor<font color="#000080">:</font>BYTE<font color="#000080">);
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer des Sprites}
{     oldColor = auszutauschende Farbe}
{     newColor = neue Farbe}
{out: Alle oldColor Farbwerte des Sprites Sp wurden gegen newColor ersetzt}
{rem: Evtl. neue Grenzen, die sich daraus ergeben koennten, wenn eine der}
{     Farben 0 ist, werden nicht neuberechnet}
</i></font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">,</font>i<font color="#000080">,</font>oneplanesize<font color="#000080">,</font>planeOFS<font color="#000080">:</font>WORD<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">&lt;&gt;</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN BEGIN
        </b></font>oneplanesize<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Breite<font color="#000080">]*</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Hoehe<font color="#000080">]; </font><font color="#008000"><i>{Groesse einer
Spriteplane}        </i></font><font color="#FF0000"><b>FOR </b></font>i<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font><font color="#800000">3 </font><font color="#FF0000"><b>DO
         BEGIN
          </b></font>planeOFS<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>i <font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">];
          </font><font color="#FF0000"><b>ASM
           </b></font><font color="#FF00FF">MOV ES,ad
           MOV DI,planeOFS
           CLD
           MOV AL,oldColor
           MOV DL,newColor
           MOV CX,oneplanesize
          @goon:
           REPNE SCASB
           JNZ @nomatch
           MOV ES:[DI-1],DL
          @nomatch:
           JCXZ @done
           JMP @goon
          @done:
          </font><font color="#FF0000"><b>END</b></font><font color="#000080">; </font><font color="#008000"><i>{of ASM}
         </i></font><font color="#FF0000"><b>END</b></font><font color="#000080">; </font><font color="#008000"><i>{of FOR}
       </i></font><font color="#FF0000"><b>END</b></font><font color="#000080">; </font><font color="#008000"><i>{of IF}
</i></font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>RevertWordArray<font color="#000080">(</font>p<font color="#000080">:</font>POINTER<font color="#000080">; </font>len<font color="#000080">:</font>WORD<font color="#000080">); </font><font color="#FF0000"><b>ASSEMBLER</b></font><font color="#000080">;
</font><font color="#008000"><i>{ in: p = Anfangsadresse eines Speicherbereichs,}
{     len = Laenge dieses Bereichs in Worten}
{out: Die Reihenfolge der Worte p[0*2]..p[(len-1)*2] wurde gespiegelt}
</i></font><font color="#FF0000"><b>ASM
  </b></font><font color="#FF00FF">MOV CX,len
  MOV BX,CX
  DEC BX
  SHL BX,1
  SHR CX,1
  JCXZ @fertig
  LDS SI,p
  MOV DI,DS
  MOV ES,DI
  MOV DI,SI
  ADD DI,BX
  </font><font color="#008000"><i>{DS:SI = 1.Word des Arrays, ES:DI = letztes Word des Arrays}
  </i></font><font color="#FF00FF">STD
 @oneword:
  MOV AX,ES:[DI]
  XCHG AX,[SI]
  STOSW
  INC SI
  INC SI
  LOOP @oneword
  CLD
  MOV AX,SEG @Data
  MOV DS,AX
 @fertig:
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>RevertByteGroups<font color="#000080">(</font>p<font color="#000080">:</font>POINTER<font color="#000080">; </font>GroupsCount<font color="#000080">, </font>GroupLen<font color="#000080">:</font>WORD<font color="#000080">); </font><font color="#FF0000"><b>ASSEMBLER</b></font><font color="#000080">;
</font><font color="#008000"><i>{ in: p = Anfangsadresse eines Speicherbereichs,}
{     GroupsCount = Anzahl Gruppen innerhalb dieses Bereichs,}
{     GroupLen = Laenge einer einzelnen Gruppe in Bytes}
{out: Die Reihenfolge der Gruppen wurde gespiegelt}
{rem: Bsp.: 4 Gruppen a 3 Bytes: 01,02,03, 04,05,06, 07,08,09, 10,11,12}
{           nach dem Aufruf    : 10,11,12, 07,08,09, 04,05,06, 01,02,03}
</i></font><font color="#FF0000"><b>ASM
  </b></font><font color="#FF00FF">MOV CX,GroupsCount
  MOV AX,CX
  SHR CX,1
  JCXZ @fertig
  DEC AX
  MOV BX,GroupLen
  MUL BX
  LDS SI,p
  MOV DI,DS
  MOV ES,DI
  MOV DI,SI
  ADD DI,AX
  </font><font color="#008000"><i>{DS:SI = 1.Byte der 1.Gruppe, ES:DI = 1.Byte der letzten Gruppe,}
  {BX = Breite einer Gruppe, CX = Anzahl Gruppen}
  </i></font><font color="#FF00FF">CLD
 @outer:
  MOV DX,BX
 @inner:
  MOV AL,ES:[DI]
  XCHG AL,[SI]
  STOSB
  INC SI
  DEC DX
  JNZ @inner
  SUB DI,BX
  SUB DI,BX
  LOOP @outer
  MOV AX,SEG @Data
  MOV DS,AX
 @fertig:
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorBoundaries<font color="#000080">(</font>p<font color="#000080">:</font>POINTER<font color="#000080">; </font>len<font color="#000080">,</font>m<font color="#000080">:</font>WORD<font color="#000080">); </font><font color="#FF0000"><b>ASSEMBLER</b></font><font color="#000080">;
</font><font color="#008000"><i>{ in: p = Zeiger auf Anfang eines Wort-Bereiches,}
{     len = Anzahl zu bearbeitende Worte,}
{     m = Maximalwert, um den gespiegelt werden soll}
{out: Die Werte des Bereichs wurden um (m-0)/2 gespiegelt;}
{     Bsp.: [....a...b.] mit m=9 sollte gespiegelt (bei (9-0)/2 = 4.5) so aus-}
{            0123456789
{     sehen:[.b...a....]}
{     Dadurch veraendern sich die Grenzen: Ist m der Maximalwert, so gilt fuer}
{     die neuen Grenzen: neu:=(m-0)-alt}
{rem: Die Sentinelwerte *16000 werden nicht veraendert!}
</i></font><font color="#FF0000"><b>ASM
  </b></font><font color="#FF00FF">MOV CX,len
  JCXZ @fertig
  CLD
  MOV DX,m
  LES DI,p
  LDS SI,p
 @oneword:
  LODSW
  CMP AX,+16000
  JE @next
  CMP AX,-16000
  JE @next
  NEG AX
  ADD AX,DX
  STOSW
 @next:
  LOOP @oneword
  MOV AX,SEG @Data
  MOV DS,AX
 @fertig:
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteVertical<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">);
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, das vertikal gespiegelt werden soll}
{out: Das Sprites Sp wurde vertikal gespiegelt}
</i></font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">,</font>i<font color="#000080">,</font>zeilen<font color="#000080">,</font>spalten<font color="#000080">:</font>WORD<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">&lt;&gt;</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN BEGIN
        </b></font>zeilen <font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Hoehe<font color="#000080">];
        </font>spalten<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Breite<font color="#000080">];
        </font><font color="#008000"><i>{Zeilendaten per &quot;Butterfly&quot; vertauschen, fuer alle 4 Ebenen:}
        </i></font><font color="#FF0000"><b>FOR </b></font>i<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font><font color="#800000">3 </font><font color="#FF0000"><b>DO
         </b></font>RevertByteGroups<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>i <font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">]),</font>zeilen<font color="#000080">,</font>spalten<font color="#000080">);

        </font><font color="#008000"><i>{Grenzdaten des oberen und unteren Spriterandes korrigieren:}
        </i></font>MirrorBoundaries<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Top<font color="#000080">]),</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">,</font>zeilen<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);
        </font>MirrorBoundaries<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Bottom<font color="#000080">]),</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">,</font>zeilen<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);

        </font><font color="#008000"><i>{nun obere gegen untere Grenzdaten austauschen:}
        </i></font>i<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Top<font color="#000080">]; </font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Top<font color="#000080">]:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Bottom<font color="#000080">]; </font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Bottom<font color="#000080">]:=</font>i<font color="#000080">;

        </font><font color="#008000"><i>{Grenzdaten des linken und rechten Spriterandes mittauschen:}
        </i></font>RevertWordArray<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Left<font color="#000080">]),</font>zeilen<font color="#000080">);
        </font>RevertWordArray<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Right<font color="#000080">]),</font>zeilen<font color="#000080">);
       </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;


</font><font color="#008000"><i>{___snippet two___}

{The difference between the two routines is solely *where* the mirroring
takes place: as default, the axis will be placed exactly in the midst of
the sprite. However, as sprites are stored in multiples of 4 pixels in
the X-direction, this &quot;slack&quot; of up to 3 pixels may be used to shift the
mirror axes a bit to the right. --Don't think much about it: just use a
sprite with a width of 5 pixels. (This will be rounded up to 2*4=8 pixels
by MAKES automatically). Then run a small demo program and use Xshift
values 0..3 to see what happens}


{for the INTERFACE-section:}

 </i></font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteHorizontalWithXShift<font color="#000080">(</font>Sp<font color="#000080">,</font>Xshift<font color="#000080">:</font>WORD<font color="#000080">);
 </font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteHorizontal<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">);

</font><font color="#008000"><i>{for the IMPLEMENTATION-section:}

</i></font><font color="#FF0000"><b>PROCEDURE </b></font>RevertByteArray<font color="#000080">(</font>p<font color="#000080">:</font>POINTER<font color="#000080">; </font>len<font color="#000080">:</font>WORD<font color="#000080">); </font><font color="#FF0000"><b>ASSEMBLER</b></font><font color="#000080">;
</font><font color="#008000"><i>{ in: p = Anfangsadresse eines Speicherbereichs,}
{     len = Laenge dieses Bereichs in Bytes}
{out: Die Reihenfolge der Bytes p[0]..p[len-1] wurde gespiegelt}
</i></font><font color="#FF0000"><b>ASM
  </b></font><font color="#FF00FF">MOV CX,len
  MOV BX,CX
  DEC BX
  SHR CX,1
  JCXZ @fertig
  LDS SI,p
  MOV DI,DS
  MOV ES,DI
  MOV DI,SI
  ADD DI,BX
  </font><font color="#008000"><i>{DS:SI = 1.Byte des Arrays, ES:DI = letztes Byte des Arrays}
  </i></font><font color="#FF00FF">STD
 @onebyte:
  MOV AL,ES:[DI]
  XCHG AL,[SI]
  STOSB
  INC SI
  LOOP @onebyte
  CLD
  MOV AX,SEG @Data
  MOV DS,AX
 @fertig:
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteHorizontalWithXShift<font color="#000080">(</font>Sp<font color="#000080">,</font>Xshift<font color="#000080">:</font>WORD<font color="#000080">);
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, das horizontal gespiegelt werden soll}
{     Xshift = Offset, um die Spiegelachse zusaetzlich verschoben werden soll}
{out: Das Sprite Sp wurde horizontal gespiegelt}
{rem: Normalerweise wird das Sprite um seine _tatsaechliche_ Mitte gespiegelt}
{     (=per SpriteSpriteWidthExact() ermittelt). Da das Sprite jedoch in X- }
{     Richtung als Vielfaches von 4 gespeichert wird, kann das Zentrum der  }
{     Spiegelung noch geringfuegig verschoben werden!}
{     Bsp.: Sprite ist 5 Punkte breit -&gt; abgespeichert in 2 4er-Gruppen -&gt;  }
{           Spiegelung kann so erfolgen, als ob es 5,6,7 oder 8 Punkte breit}
{           waere; XShift kann somit die Werte 5-5=0 .. 8-5=3 annehmen!}
</i></font><font color="#FF0000"><b>TYPE </b></font>ByteAt<font color="#000080">=</font><font color="#FF0000"><b>ARRAY</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">65534</font><font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>BYTE<font color="#000080">;
</font><font color="#FF0000"><b>VAR </b></font>ad<font color="#000080">,</font>i<font color="#000080">,</font>j<font color="#000080">,</font>index<font color="#000080">,</font>zeilen<font color="#000080">,</font>spalten<font color="#000080">,</font>exBreite<font color="#000080">,</font>plane0<font color="#000080">,</font>plane1<font color="#000080">,</font>plane2<font color="#000080">,</font>plane3<font color="#000080">:</font>WORD<font color="#000080">;
    </font>p<font color="#000080">:</font>POINTER<font color="#000080">;
</font><font color="#FF0000"><b>BEGIN
 </b></font>ad<font color="#000080">:=</font>SPRITEAD<font color="#000080">[</font>Sp<font color="#000080">];
 </font><font color="#FF0000"><b>IF </b></font><font color="#000080">(</font>ad<font color="#000080">&lt;&gt;</font><font color="#800000">0</font><font color="#000080">)
  </font><font color="#FF0000"><b>THEN BEGIN
        </b></font>zeilen <font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Hoehe<font color="#000080">];
        </font>spalten<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Breite<font color="#000080">];
        </font>exBreite<font color="#000080">:=</font>SpriteWidthExact<font color="#000080">(</font>Sp<font color="#000080">)+</font>Xshift<font color="#000080">;
        </font><font color="#008000"><i>{Xshift-Addition darf nicht dazu fuehren, dass Sprite &quot;aus dem }
        {Rahmen&quot; faellt:}
        </i></font><font color="#FF0000"><b>IF </b></font>exBreite<font color="#000080">&gt;</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2
         </font><font color="#FF0000"><b>THEN </b></font>exBreite<font color="#000080">:=</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">;
        </font>GetMem<font color="#000080">(</font>p<font color="#000080">,</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">);  </font><font color="#008000"><i>{Speicher fuer 1 Zeile}
        </i></font>plane0<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">: </font><font color="#800000">0 </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">];
        </font>plane1<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">: </font><font color="#800000">1 </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">];
        </font>plane2<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">: </font><font color="#800000">2 </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">];
        </font>plane3<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">: </font><font color="#800000">3 </font><font color="#FF0000"><b>SHL </b></font><font color="#800000">1</font><font color="#000080">];
        </font>index<font color="#000080">:=</font><font color="#800000">0</font><font color="#000080">; </font><font color="#008000"><i>{Invariante: index = i*spalten + j}

        </i></font><font color="#FF0000"><b>FOR </b></font>i<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font>zeilen<font color="#000080">-</font><font color="#800000">1 </font><font color="#FF0000"><b>DO
    BEGIN
          </b></font><font color="#008000"><i>{Zeile expandieren:}
          </i></font><font color="#FF0000"><b>FOR </b></font>j<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font>spalten<font color="#000080">-</font><font color="#800000">1 </font><font color="#FF0000"><b>DO
      BEGIN
            </b></font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">0</font><font color="#000080">]:=</font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane0 <font color="#000080">+</font>index<font color="#000080">];
            </font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">1</font><font color="#000080">]:=</font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane1 <font color="#000080">+</font>index<font color="#000080">];
            </font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">2</font><font color="#000080">]:=</font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane2 <font color="#000080">+</font>index<font color="#000080">];
            </font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">3</font><font color="#000080">]:=</font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane3 <font color="#000080">+</font>index<font color="#000080">];
            </font>INC<font color="#000080">(</font>index<font color="#000080">)
           </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
          </font><font color="#008000"><i>{Zeile spiegeln:}
          </i></font>RevertByteArray<font color="#000080">(</font>p<font color="#000080">,</font>exBreite<font color="#000080">);
          </font><font color="#008000"><i>{Zeile zurueckspeichern:}
          </i></font>DEC<font color="#000080">(</font>index<font color="#000080">,</font>spalten<font color="#000080">);  </font><font color="#008000"><i>{auf Anfang der Zeile positionieren}
          </i></font><font color="#FF0000"><b>FOR </b></font>j<font color="#000080">:=</font><font color="#800000">0 </font><font color="#FF0000"><b>TO </b></font>spalten<font color="#000080">-</font><font color="#800000">1 </font><font color="#FF0000"><b>DO
      BEGIN
            </b></font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane0 <font color="#000080">+</font>index<font color="#000080">]:=</font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">0</font><font color="#000080">];
            </font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane1 <font color="#000080">+</font>index<font color="#000080">]:=</font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">1</font><font color="#000080">];
            </font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane2 <font color="#000080">+</font>index<font color="#000080">]:=</font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">2</font><font color="#000080">];
            </font>MEM<font color="#000080">[</font>ad<font color="#000080">:</font>plane3 <font color="#000080">+</font>index<font color="#000080">]:=</font>ByteAt<font color="#000080">(</font>p<font color="#000080">^)[</font>j <font color="#FF0000"><b>SHL </b></font><font color="#800000">2 </font><font color="#000080">+</font><font color="#800000">3</font><font color="#000080">];
            </font>INC<font color="#000080">(</font>index<font color="#000080">)
           </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
         </font><font color="#FF0000"><b>END</b></font><font color="#000080">;

        </font>FreeMem<font color="#000080">(</font>p<font color="#000080">,</font>spalten <font color="#FF0000"><b>SHL </b></font><font color="#800000">2</font><font color="#000080">);

        </font><font color="#008000"><i>{Grenzdaten des linken und rechten Spriterandes korrigieren:}
        </i></font>MirrorBoundaries<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Left<font color="#000080">]),</font>zeilen<font color="#000080">,</font>exBreite<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);
        </font>MirrorBoundaries<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Right<font color="#000080">]),</font>zeilen<font color="#000080">,</font>exBreite<font color="#000080">-</font><font color="#800000">1</font><font color="#000080">);

        </font><font color="#008000"><i>{nun linke gegen rechte Grenzdaten austauschen:}
        </i></font>i<font color="#000080">:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Left<font color="#000080">]; </font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Left<font color="#000080">]:=</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Right<font color="#000080">]; </font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Right<font color="#000080">]:=</font>i<font color="#000080">;

        </font><font color="#008000"><i>{Grenzdaten des oberen und unteren Spriterandes mittauschen:}
        </i></font>RevertWordArray<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Top<font color="#000080">]),</font>exBreite<font color="#000080">);
        </font>RevertWordArray<font color="#000080">(</font>PTR<font color="#000080">(</font>ad<font color="#000080">,</font>MEMW<font color="#000080">[</font>ad<font color="#000080">:</font>Bottom<font color="#000080">]),</font>exBreite<font color="#000080">);
       </font><font color="#FF0000"><b>END</b></font><font color="#000080">;
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>PROCEDURE </b></font>MirrorSpriteHorizontal<font color="#000080">(</font>Sp<font color="#000080">:</font>WORD<font color="#000080">);
</font><font color="#008000"><i>{ in: Sp = SpriteLADEnummer, das horizontal gespiegelt werden soll}
{out: Das Sprites Sp wurde horizontal gespiegelt}
</i></font><font color="#FF0000"><b>BEGIN
 </b></font>MirrorSpriteHorizontalWithXShift<font color="#000080">(</font>Sp<font color="#000080">,</font><font color="#800000">0</font><font color="#000080">)
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;


</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to EGAVGA SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0139.PAS">Original</a><b>]</b></p></body>
</html>
