<html>
<head><title> "Drives unit" by MARTIN RICHARDSON</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to DRIVES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0092.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#FF0000"><b>USES </b></font>CRT<font color="#000080">;

</font><font color="#008000"><i>{
Here is my DRIVES routine again to return all valid drive letters on a
PC. This is a fix from the last version which incorrectly addressed
the local variables and wound up hosing memory. I also added some
extensive comments for readability. Enjoy! }

{*****************************************************************************
 * Function ...... Drives
 * Purpose ....... To return a string containing the valid drives for the
 * current system.
 * Parameters .... None
 * Returns ....... A string of the valid drive letters.
 * Notes ......... Rather than changing to each drive to see if it exists, we
 * can instead call DOS Function 26h - Parse a file name.
 * If the file name is invalid (eg, F:), then DOS will say
 * so. So, by testing each drive letter as a file name,
 * DOS will tell us which are good and which are bad!
 * Author ........ Martin Richardson
 * Date .......... August 6, 1993
 * Update ........ 02-01-94: Corrected problem where local VAR variables were
 *  not being used, but a random memory location was
 *  instead!
 * : Added comments for clarity.
 *****************************************************************************}
</i></font><font color="#FF0000"><b>FUNCTION </b></font>Drives<font color="#000080">: </font><font color="#FF0000"><b>STRING</b></font><font color="#000080">; </font><font color="#FF0000"><b>ASSEMBLER</b></font><font color="#000080">;
</font><font color="#FF0000"><b>VAR
  </b></font>DriveInfo<font color="#000080">:  </font><font color="#FF0000"><b>ARRAY</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">2</font><font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>CHAR<font color="#000080">;
  </font>Buffer<font color="#000080">: </font><font color="#FF0000"><b>ARRAY</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">40</font><font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>CHAR<font color="#000080">;
  </font>DriveString<font color="#000080">: </font><font color="#FF0000"><b>ARRAY</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">25</font><font color="#000080">] </font><font color="#FF0000"><b>OF </b></font>CHAR<font color="#000080">;
</font><font color="#FF0000"><b>ASM
 </b></font><font color="#FF00FF">PUSH  SI </font><font color="#008000"><i>{ Save Important Registers }
 </i></font><font color="#FF00FF">PUSH  DI
 PUSH  ES
 PUSH  DS

 MOV SI, SS </font><font color="#008000"><i>{ The Stack Segment (SS) points to the }
 </i></font><font color="#FF00FF">MOV DS, SI </font><font color="#008000"><i>{ VAR's above. Point DS to it... }
 </i></font><font color="#FF00FF">PUSH  DS
 POP ES </font><font color="#008000"><i>{ ...and ES as well. }

 </i></font><font color="#FF00FF">LEA SI, DriveInfo </font><font color="#008000"><i>{ DS:SI - Where we test each drive letter }
 </i></font><font color="#FF00FF">LEA DI, Buffer </font><font color="#008000"><i>{ ES:DI - FCB Buffer }
 </i></font><font color="#FF00FF">LEA BX, DriveString</font><font color="#008000"><i>{ DS:BX - Our resultant string }

 </i></font><font color="#FF00FF">MOV BYTE PTR [SI], '@' </font><font color="#008000"><i>{ The character before 'A' }
 </i></font><font color="#FF00FF">XOR CX, CX </font><font color="#008000"><i>{ Zero out CX }

</i></font><font color="#FF00FF">@Scan:
 INC BYTE PTR [SI] </font><font color="#008000"><i>{ Next Drive Letter }
 </i></font><font color="#FF00FF">MOV BYTE PTR [SI+1], ':'
 MOV AX, $2906 </font><font color="#008000"><i>{ DOS Function 29h - Parse Filename }
 </i></font><font color="#FF00FF">INT 21h </font><font color="#008000"><i>{  DS:SI - String to be parsed }
  {  ES:DI - FCB }
 </i></font><font color="#FF00FF">LEA SI, DriveInfo </font><font color="#008000"><i>{ DS:SI }
 </i></font><font color="#FF00FF">CMP AL, $FF</font><font color="#008000"><i>{ AL = FFh if function fails (invalid }
 </i></font><font color="#FF00FF">JE @NotValid </font><font color="#008000"><i>{ drive letter) }

 </i></font><font color="#FF00FF">INC CX </font><font color="#008000"><i>{ Add one more to our string length... }
 </i></font><font color="#FF00FF">PUSH  CX </font><font color="#008000"><i>{ ...and save it. }
 </i></font><font color="#FF00FF">MOV CL, BYTE PTR DS:[SI]  </font><font color="#008000"><i>{ Grab the valid drive letter... }
 </i></font><font color="#FF00FF">MOV [BX], CL  </font><font color="#008000"><i>{ ...and stuff it into our result }
 </i></font><font color="#FF00FF">INC BX </font><font color="#008000"><i>{ Next position in result string }
 </i></font><font color="#FF00FF">POP CX </font><font color="#008000"><i>{ Get our length counter back }

</i></font><font color="#FF00FF">@NotValid:
 CMP BYTE PTR [SI], 'Z' </font><font color="#008000"><i>{ Did we go through all letters? }
 </i></font><font color="#FF00FF">JNE @Scan </font><font color="#008000"><i>{ Nope, so next letter }

 </i></font><font color="#FF00FF">LEA SI, DriveString</font><font color="#008000"><i>{ Store DriveString to #Result }
 </i></font><font color="#FF00FF">LES DI, @Result
 INC DI
 REP MOVSB

 XCHG  AX, DI </font><font color="#008000"><i>{ This is the only way to store the }
 </i></font><font color="#FF00FF">MOV DI, WORD PTR @Result  </font><font color="#008000"><i>{  length that I can get to work. }
 </i></font><font color="#FF00FF">SUB AX, DI
 DEC AX
 STOSB

 POP DS </font><font color="#008000"><i>{ Restore Important Registers }
 </i></font><font color="#FF00FF">POP ES
 POP DI
 POP SI
</font><font color="#FF0000"><b>END</b></font><font color="#000080">;

</font><font color="#FF0000"><b>function </b></font>DriveValid<font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">): </font>Boolean<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;
</font><font color="#FF0000"><b>asm
</b></font><font color="#FF00FF">mov  ah, 19h </font><font color="#008000"><i>{ Select DOS function 19h }
</i></font><font color="#FF00FF">int  21h </font><font color="#008000"><i>{ Call DOS for current disk drive }
</i></font><font color="#FF00FF">mov  bl, al </font><font color="#008000"><i>{ Save drive code in bl }
</i></font><font color="#FF00FF">mov  al, Drive  </font><font color="#008000"><i>{ Assign requested drive to al }
</i></font><font color="#FF00FF">sub  al, 'A' </font><font color="#008000"><i>{ Adjust so A:=0, B:=1, etc. }
</i></font><font color="#FF00FF">mov  dl, al </font><font color="#008000"><i>{ Save adjusted result in dl }
</i></font><font color="#FF00FF">mov  ah, 0eh </font><font color="#008000"><i>{ Select DOS function 0eh }
</i></font><font color="#FF00FF">int  21h </font><font color="#008000"><i>{ Call DOS to set default drive }
</i></font><font color="#FF00FF">mov  ah, 19h </font><font color="#008000"><i>{ Select DOS function 19h }
</i></font><font color="#FF00FF">int  21h </font><font color="#008000"><i>{ Get current drive again }
</i></font><font color="#FF00FF">mov  cx, 0  </font><font color="#008000"><i>{ Preset result to False }
</i></font><font color="#FF00FF">cmp  al, dl </font><font color="#008000"><i>{ Check if drives match }
</i></font><font color="#FF00FF">jne  @@1 </font><font color="#008000"><i>{ Jump if not--drive not valid }
</i></font><font color="#FF00FF">mov  cx, 1  </font><font color="#008000"><i>{ Preset result to True }
</i></font><font color="#FF00FF">@@1:
mov  dl, bl </font><font color="#008000"><i>{ Restore original default drive }
</i></font><font color="#FF00FF">mov  ah, 0eh </font><font color="#008000"><i>{ Select DOS function 0eh }
</i></font><font color="#FF00FF">int  21h </font><font color="#008000"><i>{ Call DOS to set default drive }
</i></font><font color="#FF00FF">xchg ax, cx </font><font color="#008000"><i>{ Return function result in ax }
</i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>BEGIN
     </b></font>Clrscr<font color="#000080">;
     </font>Writeln<font color="#000080">(</font>Drives<font color="#000080">);
</font><font color="#FF0000"><b>END</b></font><font color="#000080">.</font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to DRIVES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0092.PAS">Original</a><b>]</b></p></body>
</html>
