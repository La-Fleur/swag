<html>
<head><title> "A complete drives unit for DOS & Win95" by SALVATORE BESSO</title><link rel="STYLESHEET" type="text/css" href="../swagsource.css"></head>
<body><p align="center"><b>[</b><a href="index.html">Back to DRIVES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0124.PAS">Original</a><b>]</b></p><!--StartFragment--><pre><code><font color="#FF0000"><b>unit </b></font>Drives<font color="#000080">;

</font><font color="#008000"><i>{ see TEST program below !! }

{ Unit Drives, written by Salvatore Besso   }
{ mc8505@mclink.it                          }

{ This unit is freeware and is donated to   }
{ the SWAG archival group.                  }

{ Finally, a Drives unit that correctly     }
{ works in both real and protected mode,    }
{ in a Windows 95 DOS box, and that doesn't }
{ require a media to be present in the      }
{ removable drive.                          }

{ This unit is still not able to correctly  }
{ recognize Iomega Zip drives in a Windows  }
{ 95 DOS box for now (they are recognized   }
{ as removable media). As soon as new       }
{ informations will be available from the   }
{ interrupt list of Ralph Brown, the unit   }
{ will be modified. Actually informations   }
{ about Iomega interrupt are very scarce.   }

{ A new Dpmi unit is beyond the end of this }
{ unit                                      }

{ Test program is beyond the end of the     }
{ Drives and Dpmi units                     }

{ If you have any feedback, feel free to    }
{ e-mail me                                 }

</i></font><font color="#FF0000"><b>interface

uses
  </b></font><font color="#008000"><i>{$IFDEF DPMI}
  </i></font>Dpmi<font color="#000080">,
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>Dos<font color="#000080">;

</font><font color="#FF0000"><b>const

  </b></font><font color="#008000"><i>{ dtXXXX constants - Drive Type }

  </i></font>dtInvalid   <font color="#000080">= </font><font color="#800000">$0</font><font color="#000080">;
  </font>dtUnknown   <font color="#000080">= </font><font color="#800000">$1</font><font color="#000080">;

  </font><font color="#008000"><i>{ Floppy disk }

  </i></font>dt8Single   <font color="#000080">= </font><font color="#800000">$2</font><font color="#000080">;
  </font>dt8Double   <font color="#000080">= </font><font color="#800000">$4</font><font color="#000080">;
  </font>dt360       <font color="#000080">= </font><font color="#800000">$8</font><font color="#000080">;
  </font>dt1200      <font color="#000080">= </font><font color="#800000">$10</font><font color="#000080">;
  </font>dt720       <font color="#000080">= </font><font color="#800000">$20</font><font color="#000080">;
  </font>dt1440      <font color="#000080">= </font><font color="#800000">$40</font><font color="#000080">;
  </font>dt2880      <font color="#000080">= </font><font color="#800000">$80</font><font color="#000080">;
  </font>dtAnyFloppy <font color="#000080">= </font><font color="#800000">$FE</font><font color="#000080">;

  </font><font color="#008000"><i>{ Other media }

  </i></font>dtTape      <font color="#000080">= </font><font color="#800000">$100</font><font color="#000080">;
  </font>dtFloptical <font color="#000080">= </font><font color="#800000">$200</font><font color="#000080">;
  </font>dtRamDisk   <font color="#000080">= </font><font color="#800000">$400</font><font color="#000080">;
  </font>dtCdRom     <font color="#000080">= </font><font color="#800000">$800</font><font color="#000080">;
  </font>dtIomegaZip <font color="#000080">= </font><font color="#800000">$1000</font><font color="#000080">;

  </font>dtHardDisk  <font color="#000080">= </font><font color="#800000">$80000</font><font color="#000080">;

  </font><font color="#008000"><i>{ Other attributes }

  </i></font>dtRemovable <font color="#000080">= </font><font color="#800000">$100000</font><font color="#000080">;
  </font>dtRemote    <font color="#000080">= </font><font color="#800000">$200000</font><font color="#000080">;

</font><font color="#FF0000"><b>type

  </b></font>PParamBlock <font color="#000080">= ^</font>TParamBlock<font color="#000080">;
  </font>TParamBlock <font color="#000080">= </font><font color="#FF0000"><b>record
    </b></font>SpecialFunctions<font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Special functions }
    </i></font>DeviceType      <font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Device type }
    </i></font>DeviceAttributes<font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Device attributes }
    </i></font>MaxCylinders    <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of cylinders }
    </i></font>MediaType       <font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Media type }
    { Beginning of BIOS parameter block (BPB) }
    </i></font>BytesPerSector  <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Bytes per sector }
    </i></font>SectPerCluster  <font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Sectors per cluster }
    </i></font>ReservedSectors <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of reserved sectors }
    </i></font>NumberFats      <font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Number of FATs }
    </i></font>RootDirEntries  <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of root-directory entries }
    </i></font>TotalSectors    <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Total number of sectors }
    </i></font>MediaDescriptor <font color="#000080">: </font>Byte<font color="#000080">;     </font><font color="#008000"><i>{ Media descriptor }
    </i></font>SectorsPerFat   <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of sectors per FAT }
    </i></font>SectorsPerTrack <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of sectors per track }
    </i></font>NumberHeads     <font color="#000080">: </font>Word<font color="#000080">;     </font><font color="#008000"><i>{ Number of heads }
    </i></font>HiddenSectors   <font color="#000080">: </font>LongInt<font color="#000080">;  </font><font color="#008000"><i>{ Number of hidden sectors }
    </i></font>HugeSectors     <font color="#000080">: </font>LongInt   <font color="#008000"><i>{ Number of sectors if TotalSectors = 0 }
    { End of BIOS parameter block (BPB) }
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font>PtrRec <font color="#000080">= </font><font color="#FF0000"><b>record   </b></font><font color="#008000"><i>{ replicated from OBJECTS.PAS to avoid using the unit }
    </i></font>Ofs<font color="#000080">,</font>Seg<font color="#000080">: </font>Word
  <font color="#FF0000"><b>end</b></font><font color="#000080">;

  </font>DriveLetters <font color="#000080">= </font><font color="#800000">'A'</font><font color="#000080">..</font><font color="#800000">'Z'</font><font color="#000080">;
  </font>DriveSet     <font color="#000080">= </font><font color="#FF0000"><b>Set of </b></font>DriveLetters<font color="#000080">;

</font><font color="#008000"><i>{ returns all available drives in a DriveSet type variable }

</i></font><font color="#FF0000"><b>procedure </b></font>GetDrives <font color="#000080">(</font><font color="#FF0000"><b>var </b></font>Drive<font color="#000080">: </font>DriveSet<font color="#000080">);

</font><font color="#008000"><i>{ returns drive type }

</i></font><font color="#FF0000"><b>function </b></font>GetDriveType <font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">): </font>LongInt<font color="#000080">;

</font><font color="#FF0000"><b>implementation

procedure </b></font>GetDrives <font color="#000080">(</font><font color="#FF0000"><b>var </b></font>Drive<font color="#000080">: </font>DriveSet<font color="#000080">);

</font><font color="#FF0000"><b>var
  </b></font>DriveName<font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">1</font><font color="#000080">..</font><font color="#800000">2</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>Char<font color="#000080">;
  </font>FCB      <font color="#000080">: </font><font color="#FF0000"><b>array</b></font><font color="#000080">[</font><font color="#800000">0</font><font color="#000080">..</font><font color="#800000">43</font><font color="#000080">] </font><font color="#FF0000"><b>of </b></font>Char<font color="#000080">;
  </font>Dr       <font color="#000080">: </font>LongInt<font color="#000080">;

</font><font color="#FF0000"><b>begin
  asm
        </b></font><font color="#FF00FF">PUSH    SI
        PUSH    DI
        PUSH    ES
        PUSH    DS
        MOV     SI,SS     </font><font color="#008000"><i>{ Stack points to local variables }
        </i></font><font color="#FF00FF">MOV     DS,SI     </font><font color="#008000"><i>{ also DS ... }
        </i></font><font color="#FF00FF">PUSH    DS
        POP     ES        </font><font color="#008000"><i>{ ...and ES }
        </i></font><font color="#FF00FF">MOV     BYTE PTR [DriveName],'A'
        MOV     BYTE PTR [DriveName + 1],':'
        MOV     WORD PTR [Dr],0
        MOV     WORD PTR [Dr + 2],0
        MOV     DX,1
        XOR     CX,CX
  @@1:  LEA     SI,DriveName
        LEA     DI,FCB
        MOV     AX,290EH  </font><font color="#008000"><i>{ Function 29H - Parse Filename - AL = options }
        </i></font><font color="#FF00FF">INT     21H
        CMP     AL,0FFH
        JE      @@2
        PUSH    DX
        PUSH    CX
        MOV     AX,4409H  </font><font color="#008000"><i>{ SUBST drives are ignored }
        </i></font><font color="#FF00FF">MOV     BL,BYTE PTR [DriveName]
        SUB     BL,'@'
        INT     21H
        JC      @@2
        TEST    DH,10000000B
        POP     CX
        POP     DX
        JNZ     @@2
        OR      WORD PTR [Dr],DX
        OR      WORD PTR [Dr + 2],CX
  @@2:  SHL     DX,1
        RCL     CX,1
        INC     BYTE PTR [DriveName]
        CMP     BYTE PTR [DriveName],'Z'
        JBE     @@1
        SHL     WORD PTR [Dr],1
        RCL     WORD PTR [Dr + 2],1
        POP     DS
        POP     ES
        POP     DI
        POP     SI
  </font><font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font>Drive <font color="#000080">:= </font>DriveSet <font color="#000080">(</font>Dr<font color="#000080">)
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>function </b></font>GetDriveType <font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">): </font>LongInt<font color="#000080">;

</font><font color="#FF0000"><b>var
  </b></font>DPB    <font color="#000080">: </font>PParamBlock<font color="#000080">;
  </font>SegInfo<font color="#000080">: </font>Word<font color="#000080">;
  </font>Regs   <font color="#000080">: </font>Registers<font color="#000080">;
  </font>Temp   <font color="#000080">: </font>Byte<font color="#000080">;
  </font>Result <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#008000"><i>{$IFDEF DPMI}
  </i></font>Size   <font color="#000080">: </font>LongInt<font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}

</i></font><font color="#FF0000"><b>function </b></font>GetDevParms <font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">; </font><font color="#FF0000"><b>var </b></font>DPB<font color="#000080">: </font>PParamBlock<font color="#000080">; </font>Segm<font color="#000080">: </font>Word<font color="#000080">): </font>Boolean<font color="#000080">;

</font><font color="#FF0000"><b>var
  </b></font>Regs<font color="#000080">: </font>Registers<font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font>GetDevParms <font color="#000080">:= </font>False<font color="#000080">;
  </font>FillChar <font color="#000080">(</font>Regs<font color="#000080">,</font>SizeOf <font color="#000080">(</font>Registers<font color="#000080">),</font><font color="#800000">0</font><font color="#000080">);
  </font>Regs<font color="#000080">.</font>AX <font color="#000080">:= </font><font color="#800000">$440D</font><font color="#000080">;
  </font>Regs<font color="#000080">.</font>BL <font color="#000080">:= </font>Byte <font color="#000080">(</font>Drive<font color="#000080">) - </font><font color="#800000">64</font><font color="#000080">;
  </font>Regs<font color="#000080">.</font>CH <font color="#000080">:= </font><font color="#800000">$08</font><font color="#000080">;                       </font><font color="#008000"><i>{ category: disk drive }
  </i></font>Regs<font color="#000080">.</font>CL <font color="#000080">:= </font><font color="#800000">$60</font><font color="#000080">;                       </font><font color="#008000"><i>{ device parameters    }
  {$IFNDEF DPMI}
  </i></font>Regs<font color="#000080">.</font>DS <font color="#000080">:= </font>PtrRec <font color="#000080">(</font>DPB<font color="#000080">).</font>Seg<font color="#000080">;
  </font>Regs<font color="#000080">.</font>DX <font color="#000080">:= </font>PtrRec <font color="#000080">(</font>DPB<font color="#000080">).</font>Ofs<font color="#000080">;
  </font>MsDos <font color="#000080">(</font>Regs<font color="#000080">);
  </font><font color="#008000"><i>{$ELSE}
  </i></font>Regs<font color="#000080">.</font>DS <font color="#000080">:= </font>Segm<font color="#000080">;
  </font>Regs<font color="#000080">.</font>DX <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font><font color="#FF0000"><b>if NOT </b></font>DpmiMsDos <font color="#000080">(</font>Regs<font color="#000080">) </font><font color="#FF0000"><b>then </b></font>Exit<font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>GetDevParms <font color="#000080">:= </font>Regs<font color="#000080">.</font>Flags <font color="#FF0000"><b>and </b></font>fCarry <font color="#000080">= </font><font color="#800000">0
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>function </b></font>IsDriveRemote <font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">): </font>Boolean<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;

</font><font color="#FF0000"><b>asm
        </b></font><font color="#FF00FF">MOV     AX,4409H  </font><font color="#008000"><i>{ IOCTL - Check if block device remote }
        </i></font><font color="#FF00FF">MOV     BL,Drive  </font><font color="#008000"><i>{ BL = drive                           }
        </i></font><font color="#FF00FF">SUB     BL,'@'    </font><font color="#008000"><i>{ 1 = A:, 2 = B:, etc...               }
        </i></font><font color="#FF00FF">INT     21H
        XOR     AX,AX
        JC      @@1
        AND     DH,00010000B
        JZ      @@1
        INC     AX
  @@1:
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>function </b></font>IsCDRomDrive <font color="#000080">(</font>Drive<font color="#000080">: </font>Char<font color="#000080">): </font>Boolean<font color="#000080">; </font><font color="#FF0000"><b>assembler</b></font><font color="#000080">;

</font><font color="#FF0000"><b>asm
        </b></font><font color="#FF00FF">MOV     AX,150BH  </font><font color="#008000"><i>{ MSCDEX.EXE installation test }
        </i></font><font color="#FF00FF">XOR     CH,CH     </font><font color="#008000"><i>{ CX = drive                   }
        </i></font><font color="#FF00FF">MOV     CL,Drive
        SUB     CL,'A'    </font><font color="#008000"><i>{ 0 = A:, 1 = B:, etc...       }
        </i></font><font color="#FF00FF">INT     2FH
        PUSH    AX
        POP     CX
        XOR     AX,AX
        JCXZ    @@1
        TEST    BX,0ADADH
        JZ      @@1
        INC     AX
  @@1:
</font><font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>function </b></font>IsIomegaZip<font color="#000080">: </font>Boolean<font color="#000080">;

</font><font color="#FF0000"><b>var
  </b></font>Regs  <font color="#000080">: </font>Registers<font color="#000080">;
  </font>Result<font color="#000080">: </font>Boolean<font color="#000080">;

</font><font color="#FF0000"><b>begin
  </b></font><font color="#008000"><i>{ Find first GUEST.EXE... }
  </i></font>FillChar <font color="#000080">(</font>Regs<font color="#000080">,</font>SizeOf <font color="#000080">(</font>Registers<font color="#000080">),</font><font color="#800000">0</font><font color="#000080">);
  </font>Regs<font color="#000080">.</font>AX <font color="#000080">:= </font><font color="#800000">$5700</font><font color="#000080">;                      </font><font color="#008000"><i>{ GUEST.EXE installation test }
  </i></font>Regs<font color="#000080">.</font>BX <font color="#000080">:= </font><font color="#800000">$0201</font><font color="#000080">;                      </font><font color="#008000"><i>{ Iomega ID ???               }
  </i></font>Regs<font color="#000080">.</font>DX <font color="#000080">:= </font><font color="#800000">$496F</font><font color="#000080">;                      </font><font color="#008000"><i>{ 'Io'                        }
  {$IFNDEF DPMI}
  </i></font>Intr <font color="#000080">(</font><font color="#800000">$2F</font><font color="#000080">,</font>Regs<font color="#000080">);
  </font><font color="#008000"><i>{$ELSE}
  </i></font><font color="#FF0000"><b>if NOT </b></font>DpmiIntr <font color="#000080">(</font><font color="#800000">$2F</font><font color="#000080">,</font>Regs<font color="#000080">) </font><font color="#FF0000"><b>then </b></font>Exit<font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>Result <font color="#000080">:= </font>Regs<font color="#000080">.</font>AL <font color="#000080">= </font><font color="#800000">$FF</font><font color="#000080">;
  </font><font color="#FF0000"><b>if NOT </b></font>Result <font color="#FF0000"><b>then
  begin
    </b></font><font color="#008000"><i>{ ...GUEST.EXE not found: Find GUEST95.EXE...  }
    { Interrupt informations for GUEST95.EXE still }
    { not available                                }
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font>IsIomegaZip <font color="#000080">:= </font>Result
<font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>begin </b></font><font color="#008000"><i>{ GetDriveType }
  </i></font>GetDriveType <font color="#000080">:= </font>dtInvalid<font color="#000080">;
  </font><font color="#008000"><i>{$IFNDEF DPMI}
  </i></font>New <font color="#000080">(</font>DPB<font color="#000080">);
  </font>SegInfo <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font><font color="#008000"><i>{$ELSE}
  </i></font>Size <font color="#000080">:= </font>SizeOf <font color="#000080">(</font>TParamBlock<font color="#000080">);
  </font><font color="#FF0000"><b>if NOT </b></font>DpmiGetMem <font color="#000080">(</font>Pointer <font color="#000080">(</font>DPB<font color="#000080">),</font>SegInfo<font color="#000080">,</font>Size<font color="#000080">) </font><font color="#FF0000"><b>then </b></font>Exit<font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>FillChar <font color="#000080">(</font>DPB<font color="#000080">^,</font>SizeOf <font color="#000080">(</font>TParamBlock<font color="#000080">),</font><font color="#800000">0</font><font color="#000080">);
  </font>FillChar <font color="#000080">(</font>Regs<font color="#000080">,</font>SizeOf <font color="#000080">(</font>Regs<font color="#000080">),</font><font color="#800000">0</font><font color="#000080">);
  </font>Regs<font color="#000080">.</font>AX <font color="#000080">:= </font><font color="#800000">$4408</font><font color="#000080">;                     </font><font color="#008000"><i>{ removable media ? }
  </i></font>Regs<font color="#000080">.</font>BL <font color="#000080">:= </font>Byte <font color="#000080">(</font>Drive<font color="#000080">) - </font><font color="#800000">64</font><font color="#000080">;
  </font><font color="#008000"><i>{$IFNDEF DPMI}
  </i></font>MsDos <font color="#000080">(</font>Regs<font color="#000080">);
  </font><font color="#008000"><i>{$ELSE}
  </i></font><font color="#FF0000"><b>if NOT </b></font>DpmiMsDos <font color="#000080">(</font>Regs<font color="#000080">) </font><font color="#FF0000"><b>then
  begin
    </b></font>DpmiFreeMem <font color="#000080">(</font>Pointer <font color="#000080">(</font>DPB<font color="#000080">));
    </font>Exit
  <font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>Temp <font color="#000080">:= </font><font color="#800000">0</font><font color="#000080">;
  </font><font color="#FF0000"><b>if </b></font>Regs<font color="#000080">.</font>Flags <font color="#FF0000"><b>and </b></font>fCarry <font color="#000080">&lt;&gt; </font><font color="#800000">0 </font><font color="#FF0000"><b>then  </b></font><font color="#008000"><i>{ error, check error code in AX }
  </i></font><font color="#FF0000"><b>begin
    </b></font><font color="#008000"><i>{ Driver does NOT support this call, so guess as a hard disk }
    </i></font><font color="#FF0000"><b>if </b></font>Regs<font color="#000080">.</font>AX <font color="#000080">= </font><font color="#800000">1 </font><font color="#FF0000"><b>then </b></font>Temp <font color="#000080">:= </font><font color="#800000">3
  </font><font color="#FF0000"><b>end
  else begin
    if </b></font>Regs<font color="#000080">.</font>AX <font color="#000080">= </font><font color="#800000">0 </font><font color="#FF0000"><b>then
      </b></font>Temp <font color="#000080">:= </font><font color="#800000">2          </font><font color="#008000"><i>{ removable media, floppy, WORM, Floptical, ZIP }
    </i></font><font color="#FF0000"><b>else </b></font>Temp <font color="#000080">:= </font><font color="#800000">3       </font><font color="#008000"><i>{ or hard disk, ramdisk or CD-ROM               }
  </i></font><font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font>Result <font color="#000080">:= </font>dtInvalid<font color="#000080">;
  </font><font color="#FF0000"><b>case </b></font>Temp <font color="#FF0000"><b>of
    </b></font><font color="#008000"><i>{ Removable }
    </i></font><font color="#800000">2</font><font color="#000080">: </font><font color="#FF0000"><b>if </b></font>GetDevParms <font color="#000080">(</font>Drive<font color="#000080">,</font>DPB<font color="#000080">,</font>SegInfo<font color="#000080">) </font><font color="#FF0000"><b>then
    begin
      case </b></font>DPB<font color="#000080">^.</font>DeviceType <font color="#FF0000"><b>of
        </b></font><font color="#800000">0</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt360<font color="#000080">;
        </font><font color="#800000">1</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt1200<font color="#000080">;
        </font><font color="#800000">2</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt720<font color="#000080">;
        </font><font color="#800000">3</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt8Single<font color="#000080">;
        </font><font color="#800000">4</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt8Double<font color="#000080">;
        </font><font color="#800000">5</font><font color="#000080">: </font><font color="#FF0000"><b>if </b></font>IsIomegaZip <font color="#FF0000"><b>then </b></font>Result <font color="#000080">:= </font>dtIomegaZip <font color="#FF0000"><b>else </b></font>Result <font color="#000080">:= </font>dtHardDisk<font color="#000080">;
        </font><font color="#800000">6</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dtTape<font color="#000080">;
        </font><font color="#800000">7</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dt1440<font color="#000080">;
        </font><font color="#800000">8</font><font color="#000080">: </font>Result <font color="#000080">:= </font>dtFloptical<font color="#000080">;
        </font><font color="#800000">9</font><font color="#000080">: </font><font color="#FF0000"><b>begin
          if </b></font><font color="#000080">(</font>DPB<font color="#000080">^.</font>MaxCylinders <font color="#000080">= </font><font color="#800000">80</font><font color="#000080">) </font><font color="#FF0000"><b>and </b></font><font color="#000080">(</font>DPB<font color="#000080">^.</font>NumberHeads <font color="#000080">= </font><font color="#800000">2</font><font color="#000080">) </font><font color="#FF0000"><b>then
            </b></font>Result <font color="#000080">:= </font>dt2880
          <font color="#FF0000"><b>else if </b></font>IsIomegaZip <font color="#FF0000"><b>then
            </b></font>Result <font color="#000080">:= </font>dtIomegaZip
          <font color="#FF0000"><b>else </b></font>Result <font color="#000080">:= </font>dtUnknown
        <font color="#FF0000"><b>end
        else </b></font>Result <font color="#000080">:= </font>dtUnknown
      <font color="#FF0000"><b>end</b></font><font color="#000080">;
      </font><font color="#FF0000"><b>if </b></font>Result <font color="#000080">&gt; </font>dtUnknown <font color="#FF0000"><b>then </b></font>Result <font color="#000080">:= </font>Result <font color="#FF0000"><b>or </b></font>dtRemovable
    <font color="#FF0000"><b>end</b></font><font color="#000080">;
    </font><font color="#008000"><i>{ Fixed }
    </i></font><font color="#800000">3</font><font color="#000080">: </font><font color="#FF0000"><b>if </b></font>GetDevParms <font color="#000080">(</font>Drive<font color="#000080">,</font>DPB<font color="#000080">,</font>SegInfo<font color="#000080">) </font><font color="#FF0000"><b>then
      if </b></font>DPB<font color="#000080">^.</font>DeviceType <font color="#000080">= </font><font color="#800000">5 </font><font color="#FF0000"><b>then
        </b></font>Result <font color="#000080">:= </font>dtHardDisk
      <font color="#FF0000"><b>else </b></font>Result <font color="#000080">:= </font>dtUnknown
    <font color="#FF0000"><b>else </b></font>Result <font color="#000080">:= </font>dtRamDisk
  <font color="#FF0000"><b>end</b></font><font color="#000080">;
  </font><font color="#FF0000"><b>if </b></font>IsDriveRemote <font color="#000080">(</font>Drive<font color="#000080">) </font><font color="#FF0000"><b>then
    if </b></font>IsCDRomDrive <font color="#000080">(</font>Drive<font color="#000080">) </font><font color="#FF0000"><b>then
      </b></font>Result <font color="#000080">:= </font>dtCdRom <font color="#FF0000"><b>or </b></font>dtRemovable
    <font color="#FF0000"><b>else </b></font>Result <font color="#000080">:= </font>Result <font color="#FF0000"><b>or </b></font>dtRemote<font color="#000080">;
  </font><font color="#008000"><i>{$IFNDEF DPMI}
  </i></font>Dispose <font color="#000080">(</font>DPB<font color="#000080">);
  </font><font color="#008000"><i>{$ELSE}
  </i></font><font color="#FF0000"><b>if NOT </b></font>DpmiFreeMem <font color="#000080">(</font>Pointer <font color="#000080">(</font>DPB<font color="#000080">)) </font><font color="#FF0000"><b>then </b></font>Exit<font color="#000080">;
  </font><font color="#008000"><i>{$ENDIF}
  </i></font>GetDriveType <font color="#000080">:= </font>Result
<font color="#FF0000"><b>end</b></font><font color="#000080">;

</font><font color="#FF0000"><b>end</b></font><font color="#000080">.

</font><font color="#008000"><i>(*

unit Dpmi;

{$IFNDEF DPMI}
  Error ! this code works in Protected Mode only
{$ENDIF}

{$G+,S-}

interface

uses
  Dos;

{ Virtual interrupt state values for use with the SetInterruptState and
  GetInterruptState functions. }

const
  intDisabled = False;
  intEnabled  = True;

{ Return values for MemInitSwapFile and MemCloseSwapFile }

const
  rtmOK          = $0;
  rtmNoMemory    = $1;
  rtmFileIOError = $22;

{ TRealModeRegs is a real mode registers data structure for use with the
  RealModeInt, RealModeCall, RealModeIntCall, and AllocRealCallback
  functions. }

type
  PRealModeRegs = ^TRealModeRegs;
  TRealModeRegs = record
    case Integer of
      0: (
        EDI,ESI,EBP,EXX,EBX,EDX,ECX,EAX: LongInt;
        Flags,ES,DS,FS,GS,IP,CS,SP,SS  : Word
      );
      1: (
        DI,DIH,SI,SIH,BP,BPH,XX,XXH: Word;
        case Integer of
          0: (
            BX,BXH,DX,DXH,CX,CXH,AX,AXH: Word
          );
          1: (
            BL,BH,BLH,BHH,DL,DH,DLH,DHH,CL,CH,CLH,CHH,AL,AH,ALH,AHH: Byte
          )
      )
  end;

{ TDescriptor is an 8-byte structure for use with the GetDescriptor and
  SetDescriptor procedures. }

type
  PDescriptor = ^TDescriptor;
  TDescriptor = array[0..7] of Byte;

{ TVersionInfo is a DPMI version information structure for use with the
  GetVersionInfo procedure. }

type
  PVersionInfo = ^TVersionInfo;
  TVersionInfo = record
    MinorVersion : Byte;          { AL }
    MajorVersion : Byte;          { AH }
    Flags        : Word;          { BX }
    ProcessorType: Byte;          { CL }
    Reserved     : Byte;          { CH }
    SlaveBaseInt : Byte;          { DL }
    MasterBaseInt: Byte           { DH }
  end;

{ Corresponds to procedure Intr but uses Registers instead of TRealModeRegs }

function DpmiIntr (IntNo: Byte; var Regs: Registers): Boolean;

{ Corresponds to procedure MsDos but uses Registers instead of TRealModeRegs }

function DpmiMsDos (var Regs: Registers): Boolean;

{ Corresponds to procedure GetMem; allocates memory in the first }
{ megabyte, accessible in both protected - through P - and real  }
{ mode - through Segment:$0000                                   }

function DpmiGetMem (var P: Pointer; var Segment: Word;
  var Size: Longint): Boolean;

{ Corresponds to procedure FreeMem; you must use it to deallocate }
{ memory allocated with DpmiGetMem                                }

function DpmiFreeMem (var P: Pointer): Boolean;

{ IncSelector returns the value to add to the first selector, and to    }
{ the next ones, to access the descriptor array allocated by DpmiGetMem }
{ when blocks greater than 64 K are requested                           }

procedure IncSelector (var Selector: Word);

{ AllocSelectors allocates one or more selectors using Dpmi function  }
{ 0000H. The return value is the base selector of the allocated block }
{ of selectors, or zero if the function is unsuccessful               }

function AllocSelectors (Count: Word): Word;

{ FreeSelector frees a selector using Dpmi function 0001H. }

function FreeSelector (Selector: Word): Boolean;

{ SegmentToSelector maps a real mode segment onto a selector using Dpmi    }
{ function 0002H. The return value is a selector, or zero if the function  }
{ is unsuccessful. Selectors allocated with this function are permanent    }
{ and can never be freed. If you need a temporary selector or pointer, use }
{ the AllocRealSelector or AllocRealPtr functions instead                  }

function SegmentToSelector (Segment: Word): Word;

{ SelectorToSegment returns the real mode segment address (paragraph) that }
{ corresponds to the base address of the given selector. The selector is   }
{ assumed to be a valid selector that references real mode memory. If this }
{ is not the case, the return value is undefined                           }

function SelectorToSegment (Selector: Word): Word;

{ GetSelectorBase returns the 32-bit linear base address of a selector }
{ using Dpmi function 0006H. The return value is zero if the function  }
{ is unsuccessful                                                      }

function GetSelectorBase (Selector: Word): LongInt;

{ SetSelectorBase sets the 32-bit linear base address of a selector }
{ using Dpmi function 0007H                                         }

function SetSelectorBase (Selector: Word; Base: LongInt): Boolean;

{ GetSelectorLimit returns the limit of the specified selector. The }
{ return value is zero if the selector is invalid                   }

function GetSelectorLimit (Selector: Word): LongInt;

{ SetSelectorLimit sets the limit of a selector using Dpmi function 0008H }

function SetSelectorLimit (Selector: Word; Limit: LongInt): Boolean;

{ GetAccessRights returns the access rights for a selector. The return }
{ value is zero if the selector is invalid                             }

function GetAccessRights (Selector: Word): Word;

{ SetAccessRights sets the access rights for a selector using Dpmi }
{ function 0009H                                                   }

function SetAccessRights (Selector: Word; AccessRights: Word): Boolean;

{ AllocSelectorAlias creates an aliased selector using Dpmi function }
{ 000AH. The return value is a selector, or zero if the function is  }
{ unsuccessful                                                       }

function AllocSelectorAlias (Selector: Word): Word;

{ GetDescriptor copies the LDT entry for the given selector into the }
{ given descriptor record using Dpmi function 000BH                  }

function GetDescriptor (Selector: Word; var Descriptor: TDescriptor): Boolean;

{ SetDescriptor copies the given descriptor record into the LDT entry }
{ for the given selector using Dpmi function 000CH                    }

function SetDescriptor (Selector: Word; var Descriptor: TDescriptor): Boolean;

{ AllocSpecificSelector allocates a specific selector using Dpmi function  }
{ 000DH. The return value is True if the selector was allocated. Otherwise }
{ the return value is False                                                }

function AllocSpecificSelector (Selector: Word): Boolean;

{ GetRealModeInt returns the contents of the given real mode interrupt }
{ vector using Dpmi function 0200H                                     }

function GetRealModeInt (Int: Byte): Pointer;

{ SetRealModeInt sets the interrupt vector for the specified real mode }
{ interrupt using Dpmi function 0201H                                  }

function SetRealModeInt (Int: Byte; Vector: Pointer): Boolean;

{ GetException returns the contents of the given exception vector using }
{ Dpmi function 0202H                                                   }

function GetException (Exception: Byte): Pointer;

{ SetException sets the exception vector for the specified exception }
{ using Dpmi function 0203H                                          }

function SetException (Exception: Byte; Vector: Pointer): Boolean;

{ GetProtModeInt returns the contents of the given protected mode }
{ interrupt vector using Dpmi function 0204H                      }

function GetProtModeInt (Int: Byte): Pointer;

{ SetProtModeInt sets the interrupt vector for the specified protected }
{ mode interrupt using Dpmi function 0205H                             }

function SetProtModeInt (Int: Byte; Vector: Pointer): Boolean;

{ RealModeInt simulates a software interrupt instruction in real mode }
{ using Dpmi function 0300H                                           }

function RealModeInt (Int: Byte; var Regs: TRealModeRegs): Boolean;

{ RealModeCall calls a real mode procedure with a far return frame using }
{ Dpmi function 0301H                                                    }

function RealModeCall (Proc: Pointer; var Regs: TRealModeRegs): Boolean;

{ RealModeIntCall calls a real mode procedure with an interrupt return }
{ frame using Dpmi function 0302H                                      }

function RealModeIntCall (Proc: Pointer; var Regs: TRealModeRegs): Boolean;

{ AllocCallback allocates a real mode callback using Dpmi function 0303H. }
{ The return value is the real mode address of the callback, or zero if   }
{ the function is unsuccessful                                            }

function AllocCallback (Proc: Pointer; var Regs: TRealModeRegs): Pointer;

{ FreeCallback frees a real mode callback using DPMI function 0304H }

function FreeCallback (Callback: Pointer): Boolean;

{ GetVersionInfo returns Dpmi version information in the specified version }
{ information record using Dpmi function 0400H                             }

procedure GetVersionInfo (var Info: TVersionInfo);

{ SetInterruptState sets the virtual interrupt state to the specified   }
{ value and returns the previous virtual interrupt state, corresponding }
{ to Dpmi functions 0900H and 0901H                                     }

function SetInterruptState (Enable: Boolean): Boolean;

{ GetInterruptState returns the current virtual interrupt state using }
{ Dpmi function 0902H                                                 }

function GetInterruptState: Boolean;

{ AllocRealSelector allocates a new selector and maps it onto the given    }
{ real mode segment address. The return value is a selector, or zero if    }
{ the function is unsuccessful. This function corresponds to Dpmi function }
{ 0002H, except that the resulting selector can be freed (using Dpmi       }
{ function 0001H) if required                                              }

function AllocRealSelector (Segment: Word): Word;

{ AllocRealPtr corresponds to AllocRealSelector, except that it works on  }
{ pointers instead of segments and selectors. The return value is a       }
{ protected mode pointer that points to the same physical memory location }
{ as the specified real mode pointer. If the function is unsuccessful the }
{ return value is NIL                                                     }

function AllocRealPtr (RealAddr: Pointer): Pointer;

{ FreeRealPtr frees the selector used in a pointer that was allocated by }
{ AllocRealPtr                                                           }

function FreeRealPtr (RealPtr: Pointer): Boolean;

{ MemInitSwapFile opens a swapfile of size FileSize. If file exists and }
{ new size is larger, this function will grow the swap file, otherwise  }
{ the call has no effect. File size is limited to 2 gigabytes.          }
{                                                                       }
{                                                                       }
{ Returns:                                                              }
{     rtmOK           - Successful                                      }
{     rtmNoMemory     - Not enough disk space                           }
{     rtmFileIOError  - Could not open/grow file                        }

function MemInitSwapFile (FileName: PChar; FileSize: LongInt): Integer;

{ MemCloseSwapFile closes the swapfile if it was created by the current }
{ task. If Delete is non 0, the swap file is deleted.                   }
{                                                                       }
{                                                                       }
{ Returns:                                                              }
{     rtmOK           - Successful                                      }
{     rtmNoMemory     - Not enough physical memory to run without       }
{                       swap file                                       }
{     rtmFileIOError  - Could not close/delete the file                 }

function MemCloseSwapFile (Delete: Integer): Integer;

implementation

var
  VersionInfo : TVersionInfo;
  Regs        : Registers;
  RealModeRegs: TRealModeRegs;
  DPMIBits    : Integer;
  SelIncr     : Integer;

function DpmiIntr (IntNo: Byte; var Regs: Registers): Boolean;

var
  Err: Integer;

begin
  FillChar (RealModeRegs,SizeOf (TRealModeRegs),0);
  RealModeRegs.AX := Regs.AX;
  RealModeRegs.BX := Regs.BX;
  RealModeRegs.CX := Regs.CX;
  RealModeRegs.DX := Regs.DX;
  RealModeRegs.DI := Regs.DI;
  RealModeRegs.SI := Regs.SI;
  RealModeRegs.BP := Regs.BP;
  RealModeRegs.DS := Regs.DS;
  RealModeRegs.ES := Regs.ES;
  asm
        MOV     AX,SEG RealModeRegs
        MOV     ES,AX
        CMP     DPMIBits,16
        JE      @@1
        DB      66H
        MOV     DI,OFFSET RealModeRegs
        DW      0000H
        JMP     @@2
  @@1:  MOV     DI,OFFSET RealModeRegs
  @@2:  MOV     BL,IntNo
        XOR     BH,BH
        XOR     CX,CX
        MOV     AX,0300H
        INT     31H
        XOR     AX,AX
        JNC     @@3
        MOV     AX,-31
  @@3:  MOV     Err,AX
  end;
  if Err = 0 then
  begin
    Regs.AX := RealModeRegs.AX;
    Regs.BX := RealModeRegs.BX;
    Regs.CX := RealModeRegs.CX;
    Regs.DX := RealModeRegs.DX;
    Regs.DI := RealModeRegs.DI;
    Regs.SI := RealModeRegs.SI;
    Regs.BP := RealModeRegs.BP;
    Regs.DS := RealModeRegs.DS;
    Regs.ES := RealModeRegs.ES;
    Regs.Flags := RealModeRegs.Flags
  end;
  DpmiIntr := Err = 0
end;

function DpmiMsDos (var Regs: Registers): Boolean;

begin
  DpmiMsDos := DpmiIntr ($21,Regs)
end;

function DpmiGetMem (var P: Pointer; var Segment: Word;
  var Size: Longint): Boolean;

begin
  Regs.AX := $0100;
  Regs.BX := (Size + 15) div 16;
  if Regs.BX = 0 then Regs.BX := $FFFF;     { Size &gt; $000FFFF0      }
  Size := Regs.BX;                          { calculates memory     }
  Size := Size * 16;                        { effectively allocated }
  Intr ($31,Regs);
  DpmiGetMem := Regs.Flags and fCarry = 0;
  if Regs.Flags and fCarry = 0 then
  begin
    P := Ptr (Regs.DX,0);                   { selector:offset pointer }
    Segment := Regs.AX                      { segment for real mode   }
  end
  else begin
    Size := Regs.BX;                        { size of the largest }
    Size := Size * 16                       { available block     }
  end
end;

function DpmiFreeMem (var P: Pointer): Boolean;

begin
  Regs.AX := $0101;
  Regs.DX := Seg (P^);
  Intr ($31,Regs);
  P := NIL;
  DpmiFreeMem := Regs.Flags and fCarry = 0
end;

procedure IncSelector (var Selector: Word);

begin
  Inc (Selector,SelIncr)
end;

function AllocSelectors (Count: Word): Word; assembler;

asm
      MOV     CX,Count
      MOV     AX,0000H
      INT     31H
      JNC     @@1
      XOR     AX,AX
@@1:
end;

function FreeSelector (Selector: Word): Boolean; assembler;

asm
      MOV     BX,Selector
      MOV     AX,0001H
      INT     31H
      SBB     AX, AX
      INC     AX
end;

function SegmentToSelector (Segment: Word): Word; assembler;

asm
      MOV     BX,Segment
      MOV     AX,0002H
      INT     31H
      JNC     @@1
      XOR     AX,AX
@@1:
end;

function SelectorToSegment (Selector: Word): Word; assembler;

asm
      MOV     BX,Selector
      MOV     AX,0006H
      INT     31H
      MOV     AX,DX
      OR      AX,CX
      ROR     AX,4
end;

function GetSelectorBase (Selector: Word): LongInt; assembler;

asm
      MOV     BX,Selector
      MOV     AX,0006H
      INT     31H
      JNC     @@1
      XCHG    AX,CX
      XCHG    AX,DX
      JNC     @@1
      XOR     AX,AX
      CWD
@@1:
end;

function SetSelectorBase (Selector: Word; Base: LongInt): Boolean; assembler;

asm
      MOV     BX,Selector
      MOV     DX,Base.Word[0]
      MOV     CX,Base.Word[2]
      MOV     AX,0007H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function GetSelectorLimit (Selector: Word): LongInt; assembler;

asm
      XOR     AX,AX
      LSL     AX,Selector
      XOR     DX,DX
end;

function SetSelectorLimit (Selector: Word; Limit: LongInt): Boolean; assembler;

asm
      MOV     BX,Selector
      MOV     DX,Limit.Word[0]
      MOV     CX,Limit.Word[2]
      MOV     AX,0008H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function GetAccessRights (Selector: Word): Word; assembler;

asm
      XOR     AX,AX
      LAR     AX,Selector
      XCHG    AL,AH
end;

function SetAccessRights (Selector: Word; AccessRights: Word): Boolean;
  assembler;

asm
      MOV     BX,Selector
      MOV     CX,AccessRights
      MOV     AX,0009H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function AllocSelectorAlias (Selector: Word): Word; assembler;

asm
      MOV     BX,Selector
      MOV     AX,000AH
      INT     31H
      JNC     @@1
      XOR     AX,AX
@@1:
end;

function GetDescriptor (Selector: Word; var Descriptor: TDescriptor): Boolean;
  assembler;

asm
      MOV     BX,Selector
      LES     DI,Descriptor
      MOV     AX,000BH
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function SetDescriptor (Selector: Word; var Descriptor: TDescriptor): Boolean;
  assembler;

asm
      MOV     BX,Selector
      LES     DI,Descriptor
      MOV     AX,000CH
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function AllocSpecificSelector (Selector: Word): Boolean; assembler;

asm
      MOV     BX,Selector
      MOV     AX,000DH
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function GetRealModeInt (Int: Byte): Pointer; assembler;

asm
      MOV     BL,Int
      MOV     AX,0200H
      INT     31H
      XCHG    AX,CX
      XCHG    AX,DX
      JNC     @@1
      XOR     AX,AX
      CWD
@@1:
end;

function SetRealModeInt (Int: Byte; Vector: Pointer): Boolean; assembler;

asm
      MOV     BL,Int
      MOV     DX,Vector.Word[0]
      MOV     CX,Vector.Word[2]
      MOV     AX,0201H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function GetException (Exception: Byte): Pointer; assembler;

asm
      MOV     BL,Exception
      MOV     AX,0202H
      INT     31H
      XCHG    AX,CX
      XCHG    AX,DX
      JNC     @@1
      XOR     AX,AX
      CWD
@@1:
end;

function SetException (Exception: Byte; Vector: Pointer): Boolean; assembler;

asm
      MOV     BL,Exception
      MOV     DX,Vector.Word[0]
      MOV     CX,Vector.Word[2]
      MOV     AX,0203H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function GetProtModeInt (Int: Byte): Pointer; assembler;

asm
      MOV     BL,Int
      MOV     AX,0204H
      INT     31H
      MOV     AX,DX
      MOV     DX,CX
end;

function SetProtModeInt (Int: Byte; Vector: Pointer): Boolean; assembler;

asm
      MOV     BL,Int
      MOV     DX,Vector.Word[0]
      MOV     CX,Vector.Word[2]
      MOV     AX,0205H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function RealModeInt (Int: Byte; var Regs: TRealModeRegs): Boolean; assembler;

asm
      MOV     BL,Int
      XOR     BH,BH
      XOR     CX,CX
      LES     DI,Regs
      MOV     AX,0300H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function RealModeCall (Proc: Pointer; var Regs: TRealModeRegs): Boolean;
  assembler;

asm
      XOR     BH,BH
      XOR     CX,CX
      LES     DI,Regs
      MOV     AX,Proc.Word[0]
      MOV     ES:[DI].TRealModeRegs.&amp;IP,AX
      MOV     AX,Proc.Word[2]
      MOV     ES:[DI].TRealModeRegs.&amp;CS,AX
      MOV     AX,0301H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function RealModeIntCall (Proc: Pointer; var Regs: TRealModeRegs): Boolean;
  assembler;

asm
      XOR     BH,BH
      XOR     CX,CX
      LES     DI,Regs
      MOV     AX,Proc.Word[0]
      MOV     ES:[DI].TRealModeRegs.&amp;IP,AX
      MOV     AX,Proc.Word[2]
      MOV     ES:[DI].TRealModeRegs.&amp;CS,AX
      MOV     AX,0302H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

function AllocCallback (Proc: Pointer; var Regs: TRealModeRegs): Pointer;
  assembler;

asm
      PUSH    DS
      LDS     SI,Proc
      LES     DI,Regs
      MOV     AX,0303H
      INT     31H
      POP     DS
      XCHG    AX,CX
      XCHG    AX,DX
      JNC     @@1
      XOR     AX,AX
      CWD
@@1:
end;

function FreeCallback (Callback: Pointer): Boolean; assembler;

asm
      MOV     DX,Callback.Word[0]
      MOV     CX,Callback.Word[2]
      MOV     AX,0304H
      INT     31H
      SBB     AX,AX
      INC     AX
end;

procedure GetVersionInfo (var Info: TVersionInfo); assembler;

asm
      MOV     AX,0400H
      INT     31H
      LES     DI,Info
      CLD
      STOSW
      XCHG    AX,BX
      STOSW
      XCHG    AX,CX
      STOSW
      XCHG    AX,DX
      STOSW
end;

function SetInterruptState (Enable: Boolean): Boolean; assembler;

asm
      MOV     AL,Enable
      MOV     AH,09H
      INT     31H
end;

function GetInterruptState: Boolean; assembler;

asm
      MOV     AX,0902H
      INT     31H
end;

function AllocRealSelector (Segment: Word): Word; assembler;

asm
      XOR     BX,BX
      MOV     AX,0000H
      MOV     CX,1
      INT     31H
      JC      @@1
      MOV     BX,AX
      MOV     DX,Segment
      ROL     DX,4
      MOV     CX,DX
      AND     DL,0F0H
      AND     CX,0FH
      MOV     AX,0007H
      INT     31H
      MOV     DX,0FFFFH
      XOR     CX,CX
      MOV     AX,0008H
      INT     31H
@@1:  MOV     AX,BX
end;

function AllocRealPtr (RealAddr: Pointer): Pointer; assembler;

asm
      PUSH    RealAddr.Word[2]
      CALL    AllocRealSelector
      MOV     DX,AX
      OR      AX,AX
      JE      @@1
      MOV     AX,RealAddr.Word[0]
@@1:
end;

function FreeRealPtr (RealPtr: Pointer): Boolean; assembler;

asm
      PUSH    RealPtr.Word[2]
      CALL    FreeSelector
end;

function MemInitSwapFile;  external 'RTM' index 35;
function MemCloseSwapFile; external 'RTM' index 36;

begin
  GetVersionInfo (VersionInfo);          { info on Dpmi services }
  if VersionInfo.Flags and 1 &lt;&gt; 0 then   { 16 or 32 bit implementation }
    DPMIBits := 32
  else DPMIBits := 16;
  Regs.AX := $0003;              { calculates the value to add to a }
  Intr ($31,Regs);               { selector if memory allocation is }
  SelIncr := Regs.AX             { greater than 64 K                }
end.

*)

{ ---------------------------- }
{ Test program for Drives unit }
{ ---------------------------- }

(*

program Test;

uses
  Dos,
  Drives;

var
  AllDrives: DriveSet;
  D        : DriveLetters;
  DriveType: LongInt;
  S        : String;

function GetVolumeLabel (Drive: Char): String;

var
  SR: SearchRec;

begin
  GetVolumeLabel := '';
  FindFirst (Drive + ':\*.*',VolumeID,SR);
  if DosError = 0 then GetVolumeLabel := SR.Name
end;

begin
  GetDrives (AllDrives);
  for D := 'A' to 'Z' do
  begin
    if NOT (D in AllDrives) then Continue;
    DriveType := GetDriveType (D);
    if DriveType = dtInvalid then Continue;
    if DriveType and dtUnknown = dtUnknown then
    begin
      S := 'unknown drive';
      if DriveType and dtRemote = dtRemote then
        S := 'remote ' + S
      else S := 'local ' + S
    end
    else if DriveType and dtAnyFloppy &lt;&gt; 0 then
    begin
      S := ' floppy disk';
      case DriveType and dtAnyFloppy of
        dt8Single: S := '8&quot; single density' + S;
        dt8Double: S := '8&quot; double density' + S;
        dt360    : S := '320/360 KB' + S;
        dt720    : S := '720 KB' + S;
        dt1200   : S := '1.2 MB' + S;
        dt1440   : S := '1.44 MB' + S;
        dt2880   : S := '2.88 MB' + S
      end
    end
    else if DriveType and dtTape = dtTape then
    begin
      S := ' tape drive';
      if DriveType and dtRemote = dtRemote then
        S := 'remote' + S
      else S := 'local' + S
    end
    else if DriveType and dtFloptical = dtFloptical then
    begin
      S := ' floptical drive';
      if DriveType and dtRemote = dtRemote then
        S := 'remote' + S
      else S := 'local' + S
    end
    else if DriveType and dtCDRom = dtCDRom then
    begin
      S := ' CD-ROM drive';
      if DriveType and dtRemote = dtRemote then
        S := 'remote' + S
      else S := 'local' + S
    end
    else if DriveType and dtIomegaZip = dtIomegaZip then
    begin
      S := ' Iomega Zip drive';
      if DriveType and dtRemote = dtRemote then
        S := 'remote' + S
      else S := 'local' + S
    end
    else begin
      if DriveType and dtRemovable = dtRemovable then
      begin
        S := ' removable media';
        if DriveType and dtRemote = dtRemote then
          S := 'remote' + S
        else S := 'local' + S
      end
      else begin
        S := 'volume ' + GetVolumeLabel (D) + ' (';
        if DriveType and dtRemote = dtRemote then
          S := S + 'remote '
        else S := S + 'local ';
        if DriveType and dtRamDisk = dtRamDisk then
        begin
          S := S + 'ram';
          if Pos ('.',S) &gt; 0 then Delete (S,Pos ('.',S),1)
        end
        else S := S + 'hard';
        S := S + ' disk)'
      end
    end;
    S := D + ': ' + S;
    WriteLn (S)
  end
end.

*)
</i></font>
</code></pre><!--EndFragment--><p align="center"><b>[</b><a href="index.html">Back to DRIVES SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="../index.html">Back to Main SWAG index</a><b>]</b>&nbsp;&nbsp;<b>[</b><a href="0124.PAS">Original</a><b>]</b></p></body>
</html>
